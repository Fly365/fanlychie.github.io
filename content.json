[{"title":"Spring Cloud Ribbon — 客户端负载均衡器","date":"2017-07-20T05:57:18.000Z","path":"post/spring-cloud-netflix-ribbon.html","text":"Ribbon 是 Netflix 开源的项目，主要用于为提供客户端软件提供负载均衡算法。Spring Cloud Ribbon 是基于 Netflix Ribbon 实现的一个基于 HTTP 和 TCP 的客户端负载均衡器。 1. Ribbon 单独使用创建两个项目：order-service（订单服务，作为服务提供者）、user-center（用户中心，作为服务消费者）。并在 user-center（服务消费者）端使用 Spring Cloud Ribbon 做客户端负载均衡。 1.1 服务提供者在 order-service/pom.xml 中声明依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 在 order-service/src/main/resources/application.yml 配置两个端口以便启动两个不同实例用于测试： 123456789101112131415spring: application: name: order-service profiles: active: service1---spring: profiles: service1server: port: 8881---spring: profiles: service2server: port: 8882 编写查询用户订单的服务方法： 12345678910111213141516@RestController@RequestMapping(\"/order\")public class OrderController &#123; @Autowired private OrderRepository orderRepository; @GetMapping(\"/find/&#123;uid:[1-9]\\\\d+&#125;\") public List&lt;Order&gt; findByUid(@PathVariable Integer uid) &#123; System.out.println(\"------------------------------------------------\"); System.out.println(\"------------------ 方法被调用 ------------------\"); System.out.println(\"------------------------------------------------\"); return orderRepository.findByUid(uid); &#125; &#125; 配置根路径的访问许可，以便客户端负载均衡器能够 PING 通本服务： 123456789@Configurationpublic class WebConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addStatusController(\"/\", HttpStatus.OK); &#125; &#125; 编写 Spring Boot 应用启动类： 12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 1.2 服务消费者在 user-center/pom.xml 中声明依赖： 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 在 user-center/src/main/resources/application.yml 配置客户端负载均衡： 12345678910111213server: port: 8888spring: application: name: user-centerorder-service: ribbon: eureka: enabled: false # 微服务的服务器列表 listOfServers: localhost:8881,localhost:8882 # 刷新微服务的服务器列表信息间隔的毫秒数 ServerListRefreshInterval: 3000 默认情况下，Spring Cloud Ribbon 使用 NoOpPing 作为 IPing 的实现，NoOpPing 实际上并没有 PING 服务器而是一直返回 true。而 PingUrl 则会通过 PING 服务器根路径地址来检查每一台服务器的状态以确认服务是否还在线。默认情况下，Spring Cloud Ribbon 使用 ZoneAvoidanceRule 作为 IRule 的实现，ZoneAvoidanceRule 基于 AZ（可用区）过滤服务器最大程度避免区域服务器故障。由于本地环境测试，这里采用 AvailabilityFilteringRule，它使用 Ribbon 内置的断路器功能来过滤掉处于开路状态（无法 PING 通）的服务器。 12345678910111213141516public class RibbonConfiguration &#123; @Autowired private IClientConfig ribbonClientConfig; @Bean public IPing ribbonPing(IClientConfig config) &#123; return new PingUrl(); &#125; @Bean public IRule ribbonRule(IClientConfig config) &#123; return new AvailabilityFilteringRule(); &#125; &#125; 编写用户订单查询服务： 12345678910111213@RestController@RequestMapping(\"/user\")public class UserController &#123; @Autowired private RestTemplate restTemplate; @GetMapping(\"/orders/&#123;uid:[1-9]\\\\d+&#125;\") public List&lt;Order&gt; orders(@PathVariable Integer uid) &#123; return restTemplate.getForObject(String.format(\"http://order-service/order/find/%d\", uid), List.class); &#125; &#125; 编写 Spring Boot 应用启动类，使用@LoadBalanced注解，为 RestTemplate 开启负载均衡的能力： 123456789101112131415@SpringBootApplication@RibbonClient(name = \"order-service\", configuration = RibbonConfiguration.class)public class Application &#123; @Bean @LoadBalanced public RestTemplate proviceRestTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 1.3 启动服务启动两个服务提供者服务： 12$ java -jar order-service-0.0.1-SNAPSHOT.jar$ java -Dspring.profiles.active=service2 -jar order-service-0.0.1-SNAPSHOT.jar 启动一个服务消费者服务： 1$ java -jar user-center-0.0.1-SNAPSHOT.jar 你可以尝试多次访问用户订单服务，或尝试途中关闭其中一个服务提供者服务再访问用户订单服务，以便查看其效果。 1$ curl -i -X GET http://localhost:8888/user/orders/1001 2. 整合 Eureka创建三个项目：eureka-server（服务注册中心）、order-service（订单服务，作为服务提供者）、user-center（用户中心，作为服务消费者）。并在 user-center（服务消费者）端使用 Spring Cloud Ribbon 做客户端负载均衡。 2.1 服务注册中心在 eureka-server/pom.xml 中声明依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; eureka-server/src/main/resources/application.yml 配置示例： 12345678910111213141516171819server: port: 8761spring: application: name: eureka-servereureka: instance: hostname: localhost server: renewal-percent-threshold: 0.49 client: register-with-eureka: false fetch-registry: false service-url: default-zone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/logging: level: com.netflix.eureka: 'off' com.netflix.discovery: 'off' Spring Boot 应用启动类： 12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 2.2 服务提供者在 order-service/pom.xml 中声明依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 在 order-service/src/main/resources/application.yml 配置两个端口以便启动两个不同实例用于测试： 12345678910111213141516171819spring: application: name: order-service profiles: active: service1eureka: client: service-url: defaultZone: http://localhost:8761/eureka/---spring: profiles: service1server: port: 8881---spring: profiles: service2server: port: 8882 编写查询用户订单的服务方法： 12345678910111213141516@RestController@RequestMapping(\"/order\")public class OrderController &#123; @Autowired private OrderRepository orderRepository; @GetMapping(\"/find/&#123;uid:[1-9]\\\\d+&#125;\") public List&lt;Order&gt; findByUid(@PathVariable Integer uid) &#123; System.out.println(\"------------------------------------------------\"); System.out.println(\"------------------ 方法被调用 ------------------\"); System.out.println(\"------------------------------------------------\"); return orderRepository.findByUid(uid); &#125; &#125; 编写 Spring Boot 应用启动类： 12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 2.3 服务消费者在 user-center/pom.xml 中声明依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; user-center/src/main/resources/application.yml 配置示例： 12345678910server: port: 8888spring: application: name: user-centereureka: client: register-with-eureka: false serviceUrl: defaultZone: http://localhost:8761/eureka/ 编写用户订单查询服务： 12345678910111213@RestController@RequestMapping(\"/user\")public class UserController &#123; @Autowired private RestTemplate restTemplate; @GetMapping(\"/orders/&#123;uid:[1-9]\\\\d+&#125;\") public List&lt;Order&gt; orders(@PathVariable Integer uid) &#123; return restTemplate.getForObject(String.format(\"http://order-service/order/find/%d\", uid), List.class); &#125; &#125; 编写 Spring Boot 应用启动类，使用@LoadBalanced注解，为 RestTemplate 开启负载均衡的能力： 123456789101112131415@SpringBootApplication@RibbonClient(name = \"order-service\", configuration = RibbonConfiguration.class)public class Application &#123; @Bean @LoadBalanced public RestTemplate proviceRestTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 2.4 启动服务启动服务注册中心： 1$ java -jar eureka-server-0.0.1-SNAPSHOT.jar 启动两个服务提供者服务： 12$ java -jar order-service-0.0.1-SNAPSHOT.jar$ java -Dspring.profiles.active=service2 -jar order-service-0.0.1-SNAPSHOT.jar 启动一个服务消费者服务： 1$ java -jar user-center-0.0.1-SNAPSHOT.jar 你可以尝试多次访问用户订单服务，或尝试途中关闭其中一个服务提供者服务再访问用户订单服务，以便查看其效果。 1$ curl -i -X GET http://localhost:8888/user/orders/1001 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Cloud-Dalston.SR1完整示例项目链接：spring-cloud-netflix-ribbon-sample、spring-cloud-netflix-ribbon-with-eureka-sample参考文档文献链接：client-side-load-balancing、spring-cloud-ribbon","tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://yoursite.com/tags/Spring-Cloud/"}]},{"title":"Spring Cloud Eureka — 服务发现","date":"2017-06-21T13:57:47.000Z","path":"post/spring-cloud-netflix-eureka.html","text":"Spring Cloud 是一套基于 Spring Boot 实现的微服务开发工具。微服务（也称微服务架构），简单的说，就是将一个系统按照一定的规则有效的拆分成多个不同的服务，每个服务都能够独立的进行开发、部署、扩展和维护。服务与服务之间可以通过 RESTful API 等方式进行相互调用。 Spring Cloud 没有重复制造轮子，它只是将业界内多个开源的微服务框架集成起来，再通过 Spring Boot 进行包装屏蔽掉了复杂的配置和实现原理，目的是给开发者予一套简单易懂、易部署和易维护的分布式系统开发工具包。它提供了微服务开发所需的配置管理、服务发现、断路器、智能路由、微代理、控制总线等组件。 1. EurekaEureka 是一种基于 REST 的服务，主要用于定位服务，以实现中间层服务器的负载均衡和故障转移。它是由 Spring Cloud Netflix（Spring Cloud 的子项目） 项目提供的。 1.1 Spring Cloud Netflix它主要是对 Netflix 开源的一系列产品进行包装，为 Spring Boot 应用程序提供自动配置的 Netflix OSS 集成。通过一些简单的注解，就能快速启用并构建大型的分布式系统。它提供的模块有：服务发现（Eureka）、断路器（Hystrix）、智能路由（Zuul）、客户端负载均衡（Ribbon）。 1.2 样例项目结构 1.3 服务注册中心在 pom.xml 中声明使用spring-cloud-starter-eureka-server启动器（本示例对应的项目是eureka-server）： pom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; 使用@EnableEurekaServer注解将应用声明为 Eureka 服务器端（Eureka Server），从而启动 Eureka 服务注册中心的组件，对外提供服务注册和发现的功能。 123456789@SpringBootApplication@EnableEurekaServerpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 在默认的模式中，Eureka 服务器端也充当客户端并向给定的 serviceUrl 注册自己。在生产环境中，我们通常会有多台服务器端应用，但是为了简单起见，本示例使用单台服务器，因此需要禁掉 Eureka 服务器端应用的客户端行为： src/main/resources/application.yml12345678910server: port: 8761eureka: instance: hostname: localhost client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 配置项 默认值 简述 eureka.instance.hostname - 实例的主机名。 eureka.client.register-with-eureka true 该实例是否向 Eureka 服务器注册自己，以供外部应用发现自己。在某些情况下，你可能不希望当前的应用被外部的其他应用发现，而只是想从服务器发现其他服务的实例，此时你可以将此值设为 false。 eureka.client.fetch-registry true 该实例是否向 Eureka 服务器获取所有的注册信息表。 eureka.client.service-url.defaultZone - 该实例与 Eureka 服务器通讯的 URL 地址列表。如果 Eureka 服务器地址不止一个，则使用英文的逗号分隔。 Eureka 服务器默认监听 8761 端口来接收服务注册，除此之外它还提供一个可视化的直观页面，可以方便的查看注册的服务。启动EurekaServerApplication，访问：http://localhost:8761/ 从上图可以看到，此时还没有任何服务注册到 Eureka 服务器。 1.4 客户端（服务提供者）在 pom.xml 中声明使用spring-cloud-starter-eureka启动器（本示例对应的项目是order-service）： pom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 使用@EnableEurekaClient或@EnableDiscoveryClient注解可以将应用声明为 Eureka 客户端（Eureka Client）。当客户端向 Eureka 服务器注册时，它会提供关于自身的一些元数据，例如主机和端口，健康指示符 URL，主页等信息。 123456789@SpringBootApplication@EnableEurekaClientpublic class OrderServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 除此之外，还需要配置才能找到 Eureka 服务器： src/main/resources/application.yml123456789server: port: 8881spring: application: name: order-serviceeureka: client: service-url: defaultZone: http://localhost:8761/eureka/ spring.application.name是 Eureka 客户端向服务器注册的服务ID和虚拟主机的名称。在 Eureka 服务器中，服务ID相同的实例将集群在一起。启动OrderServiceApplication，再次访问：http://localhost:8761/ 从上图可以看到，客户端应用程序已经成功被注册了。 1.5 高可用以上示例都是单点运行的，不适合于生产环境。Eureka 官方给出的应用部署架构图是这样的： 下面对这个架构图来作一些解读，希望能帮助你更好的理解。 1．Region 和 Zone在 Eureka 中有 Region（区域）和 Zone（Availability Zone，可用区）的区分。这是由于 Netflix 开源的 Eureka 旨在 AWS（Amazon Web Services，现在通常称为云计算）中运行，因此使用了一些 AWS 特有的概念术语。在非 AWS 的环境下，我们可以简单的将 Region 理解成大区或地域（如阿里云服务器的华南、华北地区），Zone 可以简单的理解成机房。如需了解更多相关信息，可参考：AWS的区域和可用区概念解释。上图是一个 Eureka 集群的部署架构图，它面有 3 个 Zone（us-east-1c、us-east-1d、us-east-1e），它们都属于 us-east-1 这个 Region。 2．Eureka Server 每个 Zone 至少有一个 Eureka Server，能够对外提供服务发现和处理区域故障。在 Eureka Server 集群中（eureka.client.register-with-eureka不能设置为 false），没有 Master/Slave 的区分，每个 Eureka Server 都是对等（Peer）的。它们除了可以作为服务注册中心外还可以充当客户端向其他 Eureka Server 注册自己，并且会从它的对等的节点（由eureka.client.service-url.defaultZone配置指定）中 Replicate（复制）所有的服务注册表信息以达到同步的目的，如果因为某种原因导致同步失败，默认等待 5 分钟（可以通过eureka.server.wait-time-in-ms-when-sync-empt配置），在这期间，它不向客户端提供服务注册信息。并且默认失败重试 5 次（可以通过eureka.server.number-of-replication-retries配置）。 3．Eureka Client Eureka 客户端应用分两种，Applicaton Service（服务提供者）和 Application Client（服务消费者）。Applicaton Service（服务提供者）通常需要向给定的 serviceUrl 对应的 Eureka Server 来 Register（注册）自己，以供外部应用可以发现自己。其注册信息包含主机名和端口信息等元数据。然后默认以每隔 30 秒的频率向注册的 Eureka Server 发送一次心跳（可以通过eureka.instance.lease-renewal-interval-in-seconds配置）来 Renew（续约）服务。Eureka Server 默认为 90 秒内如果没有收到客户端的心跳，则它会将该客户端实例从它的注册表中剔除，以禁止该实例的流量（可以通过eureka.instance.lease-expiration-duration-in-seconds配置。注意，如果该值设置的太大，即使实例已经不存在了，流量也可以路由到该实例；如果设置的太小，很可能因为网络问题导致实例被服务器剔除；该值至少应该比发送心跳频率的间隔值要大）。Eureka 客户端默认会从注册的 Eureka Server 中获取所有的服务注册表信息（可以通过eureka.client.fetch-registry配置），默认是以每隔 30 秒的频率去 Get Registry（获取注册表） 一次（可以通过eureka.client.registry-fetch-interval-seconds配置）。Application Client（服务消费者）可以不向任何 Eureka Server 注册自己，它可以只从 Eureka Server 获取注册过的服务列表，通过 RESTful API 的方式远程调用 Applicaton Service（服务提供者）。 1.5.1 Eureka Server 高可用样例本示例是在同一主机运行多个 Eureka Server 实例，由于 Eureka 会过滤同一主机的相同主机名（详见com.netflix.eureka.cluster.PeerEurekaNodes#isThisMyUrl），但是它不检查端口，因此需要先行定义至少两个不同的主机名，并使它们映射到127.0.0.1。这里采用修改 hosts 文件的方式。Windows 操作系统的 hosts 文件路径是C:\\Windows\\System32\\drivers\\etc\\hosts。找到并打开系统的 hosts 文件，在最后添加如下行： hosts1127.0.0.1 peer1 peer2 peer3 修改eureka-server项目的配置文件： src/main/resources/application.yml123456789101112131415161718192021222324252627282930313233343536373839404142spring: application: name: eureka-server profiles: active: peer1logging: level: com.netflix.eureka: 'off' com.netflix.discovery: 'off'---spring: profiles: peer1server: port: 8761eureka: instance: hostname: peer1 client: service-url: defaultZone: http://peer2:8762/eureka/,http://peer3:8763/eureka/---spring: profiles: peer2server: port: 8762eureka: instance: hostname: peer2 client: service-url: defaultZone: http://peer1:8761/eureka/,http://peer3:8763/eureka/---spring: profiles: peer3server: port: 8763eureka: instance: hostname: peer3 client: service-url: defaultZone: http://peer1:8761/eureka/,http://peer2:8762/eureka/ 这里配置了 3 个 Eureka Server 实例，每个实例与其他两个实例分别进行两两的相互注册，关系如图示： 需要注意的是，Eureka Server 的服务注册信息不能进行二次传播。如下图的实例关系配置是不可取的： 此图的每个 Eureka Server 实例是单向的向另外一个实例注册，假如现有一个新的客户端实例 C 向 1 注册，那么，1 和 2 中都会有 C 的注册信息，但是 3 中是没有 C 的注册信息的（详见com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl#replicateToPeers）。 启动 3 个 Eureka Server 实例： cmd123456# 启动 peer1 实例&gt; java -jar eureka-server-0.0.1-SNAPSHOT.jar# 启动 peer2 实例&gt; java -jar -Dspring.profiles.active=peer2 eureka-server-0.0.1-SNAPSHOT.jar# 启动 peer3 实例&gt; java -jar -Dspring.profiles.active=peer3 eureka-server-0.0.1-SNAPSHOT.jar 1.5.2 Eureka Client 高可用样例修改order-service项目的配置文件： src/main/resources/application.yml12345678910111213141516171819spring: application: name: order-service profiles: active: client1eureka: client: service-url: defaultZone: http://peer1:8761/eureka/---spring: profiles: client1server: port: 8881---spring: profiles: client2server: port: 8882 客户端的eureka.client.service-url.defaultZone指定为当前 Zone 中任意一台服务注册中心的地址就可以，因为上例中配置的每台服务注册中心的服务注册表是两两相互进行复制的。 启动 2 个 Eureka Client 实例： cmd1234# 启动 client1 实例&gt; java -jar order-service-0.0.1-SNAPSHOT.jar# 启动 client2 实例&gt; java -jar -Dspring.profiles.active=client2 order-service-0.0.1-SNAPSHOT.jar 重新刷新http://localhost:8761/： 1.6 自我保护模式Eureka 默认开启了自我保护模式（可以通过eureka.server.enable-self-preservation配置）。该模式被激活的条件是：在 1 分钟后，Renews (last min)&lt;Renews threshold。你可以在 Eureka Server 首页的右上侧可以看到： 参数 简述 Renews threshold Eureka Server 期望每分钟收到客户端实例续约的总数 Renews (last min) Eureka Server 最后 1 分钟收到客户端实例续约的总数 1．服务器端续约阀值的计算源码（Renews threshold） com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl#openForTraffic12this.expectedNumberOfRenewsPerMin = count * 2;this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold()); 其中，count 为 服务器的数量。数值 2 表示每 30 秒 1 个心跳，每分钟 2 个心跳的固定频率因子。 归纳公式：2M * renewalPercentThreshold。其中，M 为服务器的个数，计算结果只保留整数位。 renewalPercentThreshold 默认是 0.85（可以通过eureka.server.renewal-percent-threshold配置）。 其实这就是个固定值，因为对于每个 Eureka Server 来说，M 只能取 1。这段代码达到的效果是： 1．expectedNumberOfRenewsPerMin 重置为固定值 2；2．numberOfRenewsPerMinThreshold 的值被设置为 1； 2．客户端续约阀值的计算源码（Renews threshold） com.netflix.eureka.registry.AbstractInstanceRegistry#register1234if (this.expectedNumberOfRenewsPerMin &gt; 0) &#123; this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin + 2; this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());&#125; 注：上面贴出的 PeerAwareInstanceRegistryImpl 继承自 AbstractInstanceRegistry。它们共享 expectedNumberOfRenewsPerMin 和 numberOfRenewsPerMinThreshold 属性，具体可自行翻阅源码。 设有 N 个客户端，服务器端先启动，expectedNumberOfRenewsPerMin 被重置为固定值 2。接着客户端依次启动： N = 1–&gt;(2 + 2) * renewalPercentThresholdN = 2–&gt;(2 + 2 + 2) * renewalPercentThresholdN = 3–&gt;(2 + 2 + 2 + 2) * renewalPercentThreshold 归纳公式：2(N + 1) * renewalPercentThreshold，计算结果只保留整数位。 即，如果只有 1 个 Eureka Server 或者有多个 Eureka Server 但它们之间没有相互注册： 当 N = 0 时，只计算服务器端。Renews threshold= 1。由于没有客户端向服务器发送心跳，Renews (last min)&lt;Renews threshold，Eureka 自我保护模式被激活； 当 N ≠ 0 时，服务器端的计算结果被客户端覆盖，即只计算客户端； 当 N = 2 时，Renews threshold= 2(N + 1) * renewalPercentThreshold = 2 * 3 * 0.85 = 5。2 个客户端以每 30 秒发送 1 个心跳，1 分钟后总共向服务器发送 4 个心跳，Renews (last min)&lt;Renews threshold，Eureka 自我保护模式被激活； 所以如果 N &lt; 3，在 1 分钟后，服务器端收到的客户端实例续约的总数总是小于期望的阀值，因此 Eureka 的自我保护模式自动被激活。首页会出现警告信息： EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE. 这种情况下，由于 Eureka Server 没有对等的节点，同步不到服务注册信息，默认需等待 5 分钟（可以通过eureka.server.wait-time-in-ms-when-sync-empty配置）。即 5 分钟后你应该看到此信息。 为避免这种情况发生，你可以： 关闭自我保护模式（eureka.server.enable-self-preservation设为 false） 降低 renewalPercentThreshold 的比例（eureka.server.renewal-percent-threshold设置为 0.5 以下，比如 0.49） 部署多个 Eureka Server 并开启其客户端行为（eureka.client.register-with-eureka不要设为 false，默认为 true） 如果是采取部署多个 Eureka Server 并开启其客户端行为使其相互注册。假设有 M 个 Eureka Server，那么，每个 Eureka Server 每分钟可以额外收到 2 * (M - 1) 个心跳。例如： 当 M = 1，N = 2 时，Renews threshold= 2(N + 1) * renewalPercentThreshold = 2 * 3 * 0.85 = 5，2 个客户端以每 30 秒发送 1 个心跳，1 分钟后总共向服务器发送 4 个心跳，Renews (last min)&lt;Renews threshold； 当 M = 2，N = 2 时，Renews threshold= 2(N + 1) * renewalPercentThreshold = 2 * 3 * 0.85 = 5，2 个客户端以每 30 秒发送 1 个心跳，1 分钟后总共向服务器发送 4 个心跳，另外还有 1 个 M 发来的 2 个心跳，总共是 6 个心跳，Renews (last min)&gt;Renews threshold； Eureka 的自我保护模式是有意义的，该模式被激活后，它不会从注册列表中剔除因长时间没收到心跳导致租期过期的服务，而是等待修复，直到心跳恢复正常之后，它自动退出自我保护模式。这种模式旨在避免因网络分区故障导致服务不可用的问题。例如，两个客户端实例 C1 和 C2 的连通性是良好的，但是由于网络故障，C2 未能及时向 Eureka 发送心跳续约，这时候 Eureka 不能简单的将 C2 从注册表中剔除。因为如果剔除了，C1 就无法从 Eureka 服务器中获取 C2 注册的服务，但是这时候 C2 服务是可用的。所以，Eureka 的自我保护模式最好还是开启它。 1.7 Eureka 与 Zookeeper 的区别Eureka 最大程度上保证 AP（Availability，可用性；Partition-tolerance，分区容错性），而 Zookeeper 保证的是 CP（Consistency，一致性；Partition-tolerance，分区容错性）。如果因为网络分区故障导致服务器（master 节点）无法与其它节点联系，对于 Zookeeper 来说，这是不能容忍的。它会对剩下的节点重新进行 leader 选举，在这期间，整个 Zookeeper 集群是不可用的，这就直接导致了所有注册服务瘫痪的现象。而对于 Eureka 来说，每个节点都是对等的，失去了一个节点，就自动切换到其它节点，只要还有一个 Eureka 节点存在，就能正常对外提供注册服务。Eureka 可以很好的应对因网络分区故障而导致的部分节点失去联系的状况。 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Cloud-Dalston.SR1完整示例项目链接：spring-cloud-netflix-eureka-sample参考文档文献链接：http://cloud.spring.io/spring-cloud-static/Dalston.SR1/#_spring_cloud_netflix","tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://yoursite.com/tags/Spring-Cloud/"}]},{"title":"Spring Boot Test","date":"2017-06-20T06:51:38.000Z","path":"post/spring-boot-testing.html","text":"Spring 框架提供了一个专门的测试模块（spring-test），用于应用程序的集成测试。 在 Spring Boot 中，你可以通过spring-boot-starter-test启动器快速开启和使用它。 # pom.xml12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 1. Junit 测试当你的单元测试代码不需要用到 Spring Boot 功能，而只是一个简单的测试时，你可以直接编写你的 Junit 测试代码： 12345678public class SimpleJunitTest &#123; @Test public void testSayHi() &#123; System.out.println(\"Hi Junit.\"); &#125; &#125; 2. Spring Boot 测试当你的集成测试代码需要用到 Spring Boot 功能时，你可以使用@SpringBootTest注解。该注解是普通的 Spring 项目（非 Spring Boot 项目）中编写集成测试代码所使用的@ContextConfiguration注解的替代品。其作用是用于确定如何装载 Spring 应用程序的上下文资源。 12345678910111213@RunWith(SpringRunner.class)@SpringBootTestpublic class BeanInjectTest &#123; @Autowired private HelloService helloService; @Test public void testSayHi() &#123; System.out.println(helloService.sayHi()); &#125; &#125; 123456789101112@Servicepublic class HelloService &#123; public String sayHi() &#123; return \"--- Hi ---\"; &#125; public String sayHello() &#123; return \"--- Hello ---\"; &#125; &#125; 当运行 Spring Boot 应用程序测试时，它会自动的从当前测试类所在的包起一层一层向上搜索，直到找到一个@SpringBootApplication或@SpringBootConfiguration注释类为止。以此来确定如何装载 Spring 应用程序的上下文资源。只要你以合理的方式组织你的代码，你项目的主配置通常是可以被发现的。本示例项目的部分文件结构图为： 123456789101112131415spring-boot-testing-sample\\__ src \\__ main : \\__ java : \\__ org : \\__ fanlychie : |__ Application.java : \\__ service : |__ HelloService.java \\__ test \\__ java \\__ org \\__ fanlychie \\__ test |__ BeanInjectTest.java 其中，主配置启动类的代码为： 12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 如果搜索算法搜索不到你项目的主配置文件，将报出异常： java.lang.IllegalStateException: Unable to find a @SpringBootConfiguration, you need to use @ContextConfiguration or @SpringBootTest(classes=…) with your test 解决办法是，按 Spring Boot 的约定重新组织你的代码结构，或者手工指定你要装载的主配置文件： 1234567@RunWith(SpringRunner.class)@SpringBootTest(classes = &#123;YourApplication.class&#125;)public class BeanInjectTest &#123; // ... &#125; 基于 Spring 环境的 Junit 集成测试还需要使用@RunWith(SpringJUnit4ClassRunner.class)注解，该注解能够改变 Junit 并让其运行在 Spring 的测试环境，以得到 Spring 测试环境的上下文支持。否则，在 Junit 测试中，Bean 的自动装配等注解将不起作用。但由于 SpringJUnit4ClassRunner 不方便记忆，Spring 4.3 起提供了一个等同于 SpringJUnit4ClassRunner 的类 SpringRunner，因此可以简写成：@RunWith(SpringRunner.class)。 3. Spring MVC 测试当你想对 Spring MVC 控制器编写单元测试代码时，可以使用@WebMvcTest注解。它提供了自配置的 MockMvc，可以不需要完整启动 HTTP 服务器就可以快速测试 MVC 控制器。 12345678910111213141516171819import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.*;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*; @RunWith(SpringRunner.class)@WebMvcTest(HelloController.class)public class HelloControllerTest &#123; @Autowired private MockMvc mvc; @Test public void testHello() throws Exception &#123; mvc.perform(get(\"/hello\")) .andExpect(status().isOk()) .andDo(print()); &#125; &#125; 12345678910@Controllerpublic class HelloController &#123; @GetMapping(\"/hello\") public String hello(ModelMap model) &#123; model.put(\"message\", \"Hello Page\"); return \"hello\"; &#125; &#125; 使用@WebMvcTest注解时，只有一部分的 Bean 能够被扫描得到，它们分别是： @Controller @ControllerAdvice @JsonComponent Filter WebMvcConfigurer HandlerMethodArgumentResolver 其他常规的@Component（包括@Service、@Repository等）Bean 则不会被加载到 Spring 测试环境上下文中。 如果测试的 MVC 控制器中需要@ComponentBean 的参与，你可以使用@MockBean注解来协助完成： 12345678910111213141516171819202122232425import static org.mockito.BDDMockito.*;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.*;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*; @RunWith(SpringRunner.class)@WebMvcTest(HelloController.class)public class HelloControllerTest &#123; @Autowired private MockMvc mvc; @MockBean private HelloService helloService; @Test public void testSayHi() throws Exception &#123; // 模拟 HelloService.sayHi() 调用, 返回 \"=== Hi ===\" when(helloService.sayHi()).thenReturn(\"=== Hi ===\"); mvc.perform(get(\"/hello/sayHi\")) .andExpect(status().isOk()) .andDo(print()); &#125; &#125; 12345678910111213@Controllerpublic class HelloController &#123; @Autowired private HelloService helloService; @GetMapping(\"/hello/sayHi\") public String sayHi(ModelMap model) &#123; model.put(\"message\", helloService.sayHi()); return \"hello\"; &#125; &#125; 4. Spring Boot Web 测试当你想启动一个完整的 HTTP 服务器对 Spring Boot 的 Web 应用编写测试代码时，可以使用@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)注解开启一个随机的可用端口。Spring Boot 针对 REST 调用的测试提供了一个 TestRestTemplate 模板，它可以解析链接服务器的相对地址。 1234567891011121314@RunWith(SpringRunner.class)@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)public class ApplicationTest &#123; @Autowired private TestRestTemplate restTemplate; @Test public void testSayHello() &#123; Map&lt;String, Object&gt; result = restTemplate.getForObject(\"/hello/sayHello\", Map.class); System.out.println(result.get(\"message\")); &#125; &#125; 1234567891011121314@Controllerpublic class HelloController &#123; @Autowired private HelloService helloService; @GetMapping(\"/hello/sayHello\") public @ResponseBody Object helloInfo() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"message\", helloService.sayHello()); return map; &#125; &#125; 5. Spring Data JPA 测试当你想对 Spring Data JPA 应用进行单元测试时，你可以使用@DataJpaTest注解。并且在进行 JPA 测试时，你可以选择使用内存数据库还是真实的数据库测试。 5.1 内存数据库测试默认情况下，@DataJpaTest使用的是内存数据库进行测试，你无需配置和启用真实的数据库。只需要在 pom.xml 配置文件中声明如下依赖即可： # pom.xml1234&lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt;&lt;/dependency&gt; @DataJpaTest注解它只扫描@EntityBean 和装配 Spring Data JPA 存储库，其他常规的@Component（包括@Service、@Repository等）Bean 则不会被加载到 Spring 测试环境上下文。 123456789101112131415161718@RunWith(SpringRunner.class)@DataJpaTestpublic class UserRepositoryInMemoryTest &#123; @Autowired private UserRepository userRepository; @Test public void testSave() &#123; User user = new User(); user.setName(\"fanlychie\"); userRepository.save(user); System.out.println(\"====================================\"); System.out.println(userRepository.findAll()); System.out.println(\"====================================\"); &#125; &#125; 12345678910111213@Entity(name = \"User\")public class User &#123; @Id @GeneratedValue(generator = \"uuidGenerator\") @GenericGenerator(name = \"uuidGenerator\", strategy = \"uuid\") private String id; private String name; // getters and setters &#125; 123public interface UserRepository extends JpaRepository&lt;User, String&gt; &#123; &#125; 5.2 真实数据库测试如果你希望使用真实的数据库做测试，你可以使用@AutoConfigureTestDatabase(replace = Replace.NONE)注解： 12345678910111213141516171819@RunWith(SpringRunner.class)@DataJpaTest@AutoConfigureTestDatabase(replace = Replace.NONE)public class UserRepositoryMySQLTest &#123; @Autowired private UserRepository userRepository; @Test public void testSave() &#123; User user = new User(); user.setName(\"fanlychie\"); userRepository.save(user); System.out.println(\"====================================\"); System.out.println(userRepository.findAll()); System.out.println(\"====================================\"); &#125; &#125; replace = Replace.NONE的作用是告知 Spring Boot 不要替换应用程序默认的数据源。 # src/main.resources/application.yml1234567891011spring: datasource: url: jdbc:mysql://127.0.0.1/test username: root password: root driver-class-name: com.mysql.jdbc.Driver tomcat: default-auto-commit: true jpa: hibernate: ddl-auto: update 5.3 事务控制默认情况下，在每个 JPA 测试结束时，事务会发生回滚。这在一定程度上可以防止测试数据污染数据库。如果你不希望事务发生回滚，你可以使用@Rollback(false)注解，该注解可以标注在类级别做全局的控制，也可以标注在某个特定不需要执行事务回滚的方法级别上。 1234567891011121314151617181920@RunWith(SpringRunner.class)@DataJpaTest@AutoConfigureTestDatabase(replace = Replace.NONE)public class UserRepositoryMySQLTest &#123; @Autowired private UserRepository userRepository; @Test @Rollback(false) public void testSave() &#123; User user = new User(); user.setName(\"fanlychie\"); userRepository.save(user); System.out.println(\"====================================\"); System.out.println(userRepository.findAll()); System.out.println(\"====================================\"); &#125; &#125; 另外，你也可以使用@Transactional注解对事务进行控制。该注解可以标注在类级别做全局的控制，也可以标注在某个特定的方法级别上。如： 1234567891011121314151617@RunWith(SpringRunner.class)@DataJpaTest@AutoConfigureTestDatabase(replace = Replace.NONE)public class UserRepositoryMySQLTest &#123; @Autowired private UserRepository userRepository; @Test @Transactional(readOnly = true) public void testSelect() &#123; System.out.println(\"====================================\"); System.out.println(userRepository.findAll()); System.out.println(\"====================================\"); &#125; &#125; 6. 关闭 DEBUG 日志和输出 SQL 信息在 Spring Boot 环境中执行 Junit 单元测试的时候，会有很多DEBUG和INFO级别的日志信息输出。我们对这些信息其实并不是很感兴趣，而是更关心自己编写的测试代码部分输出的信息以及 SQL 语句信息。正确关闭这些日志信息的姿势是，在测试目录的资源文件夹中创建一个logback-test.xml文件： # src/test/resources/logback-test.xml12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;include resource=\"org/springframework/boot/logging/logback/base.xml\" /&gt; &lt;!-- 日志级别设置为 ERROR --&gt; &lt;root level=\"ERROR\" /&gt; &lt;!-- 输出 SQL 语句信息 --&gt; &lt;logger name=\"org.hibernate.SQL\" level=\"DEBUG\"/&gt; &lt;!-- 输出 SQL 语句参数信息 --&gt; &lt;logger name=\"org.hibernate.type.descriptor.sql.BasicBinder\" level=\"TRACE\"/&gt;&lt;/configuration&gt; 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-testing-sample参考文档文献链接：http://docs.spring.io/spring-boot/docs/1.5.2.RELEASE/reference/htmlsingle/#boot-features-testing","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot 使用 Servlet、Filter、Listener","date":"2017-06-19T14:30:08.000Z","path":"post/spring-boot-servlet-filter-listener-usage.html","text":"在普通的 WEB 应用中，Servlet、Filter、Listener 都是在 web.xml 配置文件中配置的。而在 Spring Boot 中，由于它省去 web.xml 配置文件，Servlet、Filter、Listener 的配置需要通过 Java 代码的方式来进行配置。 1. 通过 Bean 的方式配置Spring Boot 提供了 ServletRegistrationBean、FilterRegistrationBean、ServletListenerRegistrationBean 三种类型来分别配置应用的 Servlet、Filter、Listener。 # 在 Spring Boot 应用中配置使用 Servlet、Filter、Listener123456789101112131415161718192021222324@Configurationpublic class ApplicationConfigurer &#123; @Bean public FilterRegistrationBean registerCustomFilter() &#123; FilterRegistrationBean filterRegBean = new FilterRegistrationBean(new CustomFilter()); filterRegBean.setUrlPatterns(Arrays.asList(\"/*\")); return filterRegBean; &#125; @Bean public ServletRegistrationBean registerCustomServlet() &#123; ServletRegistrationBean servletRegBean = new ServletRegistrationBean(new CustomServlet()); servletRegBean.setUrlMappings(Arrays.asList(\"/customServlet\")); servletRegBean.setLoadOnStartup(1); return servletRegBean; &#125; @Bean public ServletListenerRegistrationBean&lt;?&gt; registerCustomListener() &#123; return new ServletListenerRegistrationBean&lt;&gt;(new CustomListener()); &#125; &#125; # 自定义的 Filter12345678910111213141516171819public class CustomFilter implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"------ CustomFilter ------\"); chain.doFilter(request, response); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void destroy() &#123; &#125; &#125; # 自定义的 Listener12345678910111213public class CustomListener implements ServletRequestListener &#123; @Override public void requestInitialized(ServletRequestEvent event) &#123; System.out.println(\"------ CustomListener ------\"); &#125; @Override public void requestDestroyed(ServletRequestEvent event) &#123; &#125; &#125; # 自定义的 Servlet12345678public class CustomServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"------ CustomServlet ------\"); &#125; &#125; 2. 通过注解的方式配置Spring Boot 提供了 @WebServlet、@WebFilter、@WebListener 三种类型的注解来分别配置应用的 Servlet、Filter、Listener。 # Filter 注解1234567891011121314151617181920@WebFilter(urlPatterns = \"/*\")public class CustomFilter implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"------ CustomFilter Annotation ------\"); chain.doFilter(request, response); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void destroy() &#123; &#125; &#125; # Listener 注解1234567891011121314@WebListenerpublic class CustomListener implements ServletRequestListener &#123; @Override public void requestInitialized(ServletRequestEvent event) &#123; System.out.println(\"------ CustomListener Annotation ------\"); &#125; @Override public void requestDestroyed(ServletRequestEvent event) &#123; &#125; &#125; # Servlet 注解123456789@WebServlet(urlPatterns = \"/customServlet\", loadOnStartup = 1)public class CustomServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"------ CustomServlet Annotation ------\"); &#125; &#125; 最后，需要在应用中使用@ServletComponentScan注解配置才有效。 123456789@SpringBootApplication@ServletComponentScanpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：conf-sample scan-sample参考文档文献链接：http://docs.spring.io/spring-boot/docs/1.5.2.RELEASE/reference/htmlsingle/#boot-features-embedded-container","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot 异常处理","date":"2017-06-18T08:18:54.000Z","path":"post/spring-boot-exception-handler.html","text":"Spring Boot 默认提供了程序出错的结果映射路径/error（见：Spring Boot 错误页面）。其内部是通过判断请求头中的Accept的内容是否为text/html来区分请求是来自客户端浏览器（浏览器通常默认自动发送请求头内容Accept:text/html）还是客户端接口的调用，以此来决定返回页面视图还是 JSON 消息内容。 1. 自定义异常处理使用@ControllerAdvice注解可以对已知的Controller中抛出的异常进行捕获并处理。 12345678910111213141516171819202122232425@ControllerAdvicepublic class GlobalExceptionHandler &#123; private Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(BusinessHtmlException.class) public ModelAndView handleHtmlException(Exception e) &#123; logger.error(\"「捕捉到异常」：\", e); ModelAndView modelAndView = new ModelAndView(\"error/general\"); modelAndView.addObject(\"message\", e.getMessage()); return modelAndView; &#125; @ExceptionHandler(&#123; BusinessJsonException.class, IllegalArgumentJsonException.class &#125;) public ResponseEntity&lt;?&gt; handleJsonException(Exception e) &#123; logger.error(\"「捕捉到异常」：\", e); HttpStatus status = HttpStatus.INTERNAL_SERVER_ERROR; return new ResponseEntity&lt;&gt;(new HttpResponseBody(status.value(), e.getMessage(), null), status); &#125; &#125; 1.1 @ExceptionHandler该注解用于标注处理方法处理哪些特定的异常。被该注解标注的方法可以有以下任意顺序的参数类型： Throwable、Exception 等异常对象； ServletRequest、HttpServletRequest、ServletResponse、HttpServletResponse； HttpSession 等会话对象； org.springframework.web.context.request.WebRequest； java.util.Locale； java.io.InputStream、java.io.Reader； java.io.OutputStream、java.io.Writer； org.springframework.ui.Model； 并且被该注解标注的方法可以有以下的返回值类型可选： ModelAndView； org.springframework.ui.Model； java.util.Map； org.springframework.web.servlet.View； @ResponseBody 注解标注的任意对象； HttpEntity&lt;?&gt; or ResponseEntity&lt;?&gt;； void； 以上罗列的不完全，更加详细的信息可参考：Spring ExceptionHandler。 1.2 @ResponseStatus@ExceptionHandler 注释可以与 @ResponseStatus 结合起来，以定义 HTTP 响应的状态码值。 以下为涉及本示例的其余代码： 1234567891011121314151617public class HttpResponseBody &#123; private int code; private String errmsg; private Object data; public HttpResponseBody(int code, String errmsg, Object data) &#123; this.code = code; this.data = data; this.errmsg = errmsg; &#125; // getters and setters &#125; 1234567public class BusinessHtmlException extends RuntimeException &#123; public BusinessHtmlException(String message) &#123; super(message); &#125; &#125; 1234567public class BusinessJsonException extends RuntimeException &#123; public BusinessJsonException(String message) &#123; super(message); &#125; &#125; 1234567public class IllegalArgumentJsonException extends RuntimeException &#123; public IllegalArgumentJsonException(String message) &#123; super(message); &#125; &#125; 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-exception-handler-sample参考文档文献链接：http://docs.spring.io/spring-boot/docs/1.5.2.RELEASE/reference/htmlsingle/#boot-features-error-handling","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot 错误页面","date":"2017-06-17T03:26:48.000Z","path":"post/spring-boot-error-page.html","text":"1. 默认的错误页面Spring Boot 默认提供了程序出错的结果映射路径/error：spring-boot-autoconfigure.jar/org.springframework.boot.autoconfigure.web.BasicErrorController.java 其中，errorHtml方法是用于处理浏览器端的请求，它返回一个简单的错误页面。而error方法是用于处理客户端的调用，它返回一个简单的 JSON 字串信息。 当请求发生错误，它会响应浏览器一个简单的页面来描述这些错误信息，如 404 错误页面： 2. 自定义错误页面Spring Boot 默认是到模板文件所在目录的error文件夹中查找错误码对应的视图模板文件：spring-boot-autoconfigure-1.5.2.RELEASE.jar/org.springframework.boot.autoconfigure.web.DefaultErrorViewResolver.java 因此，自定义的错误模板文件放在 error 目录下即可。如： # src/main/resources/templates/error/404.html（Thymeleaf）123456789101112131415&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;404错误页面&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;404&lt;/h1&gt;&lt;p th:text=\"|timestamp：$&#123;#dates.format(timestamp, 'yyyy-MM-dd HH:mm:ss:SSS')&#125;|\"&gt;&lt;/p&gt;&lt;p th:text=\"|status：$&#123;status&#125;|\"&gt;&lt;/p&gt;&lt;p th:text=\"|error：$&#123;error&#125;|\"&gt;&lt;/p&gt;&lt;p th:text=\"|message：$&#123;message&#125;|\"&gt;&lt;/p&gt;&lt;p th:text=\"|path：$&#123;path&#125;|\"&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 最终的效果： 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-error-page-sample参考文档文献链接：http://docs.spring.io/spring-boot/docs/1.5.2.RELEASE/reference/htmlsingle/#boot-features-error-handling-custom-error-pages","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot Tomcat 上下文路径","date":"2017-05-12T16:17:40.000Z","path":"post/spring-boot-tomcat-context-path.html","text":"Spring Boot 内置 Tomcat 上下文路径默认是/。修改上下文路径的方式有： 1. application.ymlsrc/main/resources/application.yml12server: contextPath: /my-app 2. application.propertiessrc/main/resources/application.properties1server.contextPath=/my-app 3. 命令行terminal1$ java -Dserver.contextPath=/my-app -jar xxxx.jar","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot Tomcat 端口","date":"2017-05-12T16:16:30.000Z","path":"post/spring-boot-tomcat-port.html","text":"Spring Boot 内置 Tomcat 端口默认是8080。修改端口的方式有： 1．application.ymlsrc/main/resources/application.yml12server: port: 8888 2．application.propertiessrc/main/resources/application.properties1server.port=8888 3．命令行terminal1$ java -Dserver.port=8888 -jar xxxx.jar","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot Banner","date":"2017-05-12T16:16:13.000Z","path":"post/spring-boot-logo-banner.html","text":"Spring Boot 启动时的 Logo Banner： 1234567 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _`| \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.2.RELEASE) 1. 更换 Banner在src/main/resources目录下创建banner.txt文件： src/main/resources/banner.txt123456789101112131415161718192021 _ooOoo_ o8888888o 88\" . \"88 (| -_- |) O\\ = /O ____/`---'\\____ . ' \\\\| |//`. / \\\\||| : |||// \\ / _||||| -:- |||||- \\ | | \\\\\\ - /// | | | \\_| ''\\---/'' | | \\ .-\\__`-`___/-. / ___`. .' /--.--\\`. . __ .\"\" '&lt;`.___\\_&lt;|&gt;_/___.' &gt;'\"\". | | :`- \\`.;`\\ _ /`;.`/ -`: | | \\ \\`-. \\_ __\\ /__ _/ .-`/ /======`-.____`-.___\\_____/___.-`____.-'====== `=---='............................................. 佛祖镇楼 BUG辟易 2. 禁用 Bannersrc/main/resources/application.yml123spring: main: banner-mode: 'off' 或 src/main/resources/application.properties1spring.main.banner-mode='off' 或 terminal1$ java -Dspring.main.banner-mode=off -jar xxxx.jar","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"JPQL 语言语法","date":"2017-05-06T06:42:27.000Z","path":"post/jpql-usage.html","text":"JPQL（Java Persistence Query Language，Java 持久化查询语言）和 SQL 之间有很多相似之处，它们之间主要的区别在于前者处理 JPA 实体类，而后者则直接涉及关系数据。在 JPQL 中，可以使用SELECT、UPDATE和DELETE语法来定义查询。 1. 查询语法：SELECT ... FROM ... [WHERE ...] [GROUP BY ... [HAVING ...]] [ORDER BY ...] FROM 子句 通过声明一个或多个标识符变量来定义查询的范围。在SELECT和WHERE子句中可以引用这些变量。 WHERE 子句 用于限制查询到的对象或值的条件表达式。 GROUP BY 子句 根据一组属性对查询结果进行分组。 HAVING 子句 配合GROUP BY子句使用，以根据条件表达式进一步限制查询结果。 ORDER BY 子句 对查询结果进行排序。 # 部门实体12345678910111213141516@Entity(name = \"Department\")public class Department &#123; @Id @GeneratedValue private Long id; private String name; @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true) @JoinColumn(name = \"department_id\") private Set&lt;Employee&gt; employees; // getters and setters &#125; # 雇员实体1234567891011121314151617181920212223242526@Entity(name = \"Employee\")public class Employee &#123; @Id @GeneratedValue private Long id; private String name; @Enumerated(EnumType.STRING) private Sex sex; private Integer age; private Boolean married; private Double salary; private Date hireDate; @ManyToOne(fetch = FetchType.LAZY) private Department department; // getters and setters &#125; # 性别枚举12345678910111213141516171819202122package org.fanlychie.enums; public enum Sex &#123; MALE(\"男\"), FEMALE(\"女\"), ; private final String displayText; private Sex(String displayText) &#123; this.displayText = displayText; &#125; @Override public String toString() &#123; return displayText; &#125; &#125; 1.1 基础查询语法：SELECT 标识符变量 FROM 实体名称 [AS] 标识符变量 示例：查询所有的雇员信息 12@Query(\"SELECT E FROM Employee E\")List&lt;Employee&gt; selectAll(); 1.2 查询参数JPQL 支持两种查询参数，它们分别是命名参数和位置参数。 1.2.1 命名参数语法：:自定义的参数名称 示例：按性别和薪资范围查找雇员信息 12@Query(\"SELECT E FROM Employee E WHERE E.sex = :sex AND E.salary &gt; :salary\")List&lt;Employee&gt; selectByNamedParams(@Param(\"sex\") Sex sex, @Param(\"salary\") Double salary); 在方法的参数列表中，需要使用@Param注解标注每个参数的名称，使之与查询语句参数名称匹配。 1.2.2 位置参数语法：?位置编号的数值 示例：按姓名和性别查找雇员信息 12@Query(\"SELECT E FROM Employee E WHERE E.sex = ?1 AND E.salary &gt; ?2\")List&lt;Employee&gt; selectByPositionalParams(Sex sex, Double salary); 在方法的参数列表中，参数的顺序需要与查询语句中参数标注的编号依次对应起来。 1.3 关联查询通过使用关键字[LEFT|INNER] JOIN联接关系属性查询。 1.3.1 单值关联查询语法：SELECT 标识符变量 FROM 实体名称 [AS] 标识符变量 JOIN 实体名称.单值关联字段 [AS] 标识符变量2 ... 示例：按部门名称查找该部门所有的雇员信息 12@Query(\"SELECT E FROM Employee E JOIN E.department D WHERE D.name = ?1\")List&lt;Employee&gt; selectByDeptName(String deptName); 1.3.2 多值关联查询语法1：SELECT 标识符变量 FROM 实体名称 [AS] 标识符变量 JOIN 实体名称.多值关联字段 [AS] 标识符变量2 ... 示例：查询薪资大于10000的所有雇员所属的部门信息 12@Query(\"SELECT D FROM Department D JOIN D.employees E WHERE E.salary &gt; 10000\")List&lt;Department&gt; selectByMultRelatedField(); 语法2：SELECT 标识符变量 FROM 实体名称 [AS] 标识符变量, IN(实体名称.多值关联字段) [AS] 标识符变量2 ... 12@Query(\"SELECT D FROM Department D, IN(D.employees) E WHERE E.salary &gt; 10000\")List&lt;Department&gt; selectByMultRelatedCollection(); 1.4 去重查询语法：SELECT DISTINCT 标识符变量 FROM 实体名称 [AS] 标识符变量 ... 示例：查询薪资大于10000的所有雇员所属的部门信息，并消除查询结果中的重复的部门 12@Query(\"SELECT DISTINCT D FROM Department D JOIN D.employees E WHERE E.salary &gt; 10000\")List&lt;Department&gt; selectByMultRelatedFieldDistinct(); 1.5 字面值JPQL 支持的字面值有以下的4种，它们分别是：字符串、数字、布尔、枚举。 1.5.1 字符串语法：&#39;字符串&#39; 示例：查询给定名字的雇员信息 12@Query(\"SELECT E FROM Employee E WHERE E.name = '张三'\")Employee selectByLiteralString(); 如果字符串中含有单引号，则用两个单引号来表示。如：Li&#39;Si -&gt; Li&#39;&#39;Si 12@Query(\"SELECT E FROM Employee E WHERE E.name = 'Li''Si'\")Employee selectByLiteralStringWithQuote(); 1.5.2 数字整数类型：如24、+24、-24、24L，支持 Java Long 范围的数值。 浮点类型：如24.、24.6、+24.6、-24.6、24.6F、24.6D，支持 Java Double 范围的数值。 示例：查询薪资大于10000的所有雇员 12@Query(\"SELECT E FROM Employee E WHERE E.salary &gt; 10000.0\")List&lt;Employee&gt; selectByLiteralNumber(); 1.5.3 布尔布尔类型的可选值为：TRUE或FALSE，它们不区分大小写。 示例：查找已婚的所有雇员 12@Query(\"SELECT E FROM Employee E WHERE E.married = TRUE\")List&lt;Employee&gt; selectByLiteralBool(); 1.5.4 枚举枚举类名必须指定为完全限定类名。 示例：查询所有女性的雇员 12@Query(\"SELECT E FROM Employee E WHERE E.sex = org.fanlychie.enums.Sex.FEMALE\")List&lt;Employee&gt; selectByLiteralEnum(); 1.6 模糊查询 表达式 匹配 不匹配 E.name LIKE ‘张%’ 张三 小张伟 E.name LIKE ‘张_’ 张三 张三丰 E.name LIKE ‘张\\_%’ 张_三 张三 示例：查询张性的所有雇员 12@Query(\"SELECT E FROM Employee E WHERE E.name LIKE '张%'\")List&lt;Employee&gt; selectByLikeLiteralString(); 1.7 空集合查询通过使用关键字IS [NOT] EMPTY来查找关联的属性集合的值为空的记录。 示例：查找尚无雇员的所有部门 12@Query(\"SELECT D FROM Department D WHERE D.employees IS EMPTY\")List&lt;Department&gt; selectByEmpty(); 1.8 构造器查询结果的类型如果不是持久化的实体类，必须使用该类的完全限定名。 语法：SELECT NEW 类的完全限定名(参数1, 参数2, ...) ... 示例：查询所有的雇员信息 12@Query(\"SELECT NEW org.fanlychie.model.SimpleEmployee(E.name, E.sex) FROM Employee E\")List&lt;SimpleEmployee&gt; selectSimpleEmployees(); 12345678910111213141516package org.fanlychie.model; public class SimpleEmployee &#123; private String name; private Sex sex; public SimpleEmployee(String name, Sex sex) &#123; this.name = name; this.sex = sex; &#125; // getters and setters &#125; 2. 更新示例：更新某个雇员的婚姻状态和薪资信息 1234@Modifying@Transactional@Query(\"UPDATE Employee SET married = ?2, salary = ?3 WHERE id = ?1\")int update(Long id, Boolean married, Double salary); @Query无法进行 DML（Data Manipulation Language 数据操控语言，主要语句有 INSERT、DELETE、UPDATE）操作，如需更新数据库表的数据需要标注@Modifying注解，并且需要使用支持事务的@Transactional注解。 3. 删除示例：删除没有雇员的部门信息 1234@Modifying@Transactional@Query(\"DELETE FROM Department D WHERE D.employees IS EMPTY\")int delete(); 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-jpql-sample参考文档文献链接：http://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm、http://docs.oracle.com/html/E13946_04/ejb3_langref.html","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"Spring Boot Jpa","date":"2017-04-30T13:04:47.000Z","path":"post/spring-boot-jpa.html","text":"JPA（Java Persistence API）是一套 Java 持久化规范，用于将应用程序中的对象映射到关系型数据库。应用程序的数据访问层通常为域对象提供创建、读取、更新和删除（CRUD）操作，Spring Data JPA 提供了这方面的通用接口以及持久化存储特定的实现，它选择目前最流行之一的 Hibernate 作为 JPA 实现的提供者，旨在简化数据访问层。作为应用程序的开发人员，你只需要编写数据库的存取接口，由 Spring 运行时自动生成这些接口的适当实现，开发人员不需要编写任何具体的实现代码。在 Spring Boot 中，通过使用spring-boot-starter-data-jpa启动器，就能快速开启和使用 Spring Data JPA。 # pom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 1. 编程接口 1.1 Repository这是 Spring Data Jpa 抽象的中心接口，它是一个标记接口。扩展此接口需要传递实体类型和实体的ID字段类型参数，你必须在接口里面声明你自己需要的方法，这些方法由 Spring 在运行时提供具体的实现。 12345public interface EmployeeRepository extends Repository&lt;Employee, Long&gt; &#123; Employee findOne(Long id); &#125; 1.2 CrudRepository继承自 Repository 接口，它提供了一套 CRUD 操作的方法。扩展此接口需要传递实体类型和实体的ID字段类型参数，你可以不需要再定义基础的 CRUD 操作方法而直接可以使用它们。但在某些场景中你可能不希望接口对外暴露一套完整的增删查改的方法，比如你只希望提供查改的方法而不希望暴露增删的功能。基于这种情况，你可以使用 Repository 接口，并将需要的方法从 CrudRepository 拷贝到其中以选择性的公开 CRUD 方法。 123public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; &#125; 1.2.1 save当你需要修改数据库的数据时，你可以调用此方法。当此方法被调用时，它首先判断参数的实体对象是否是新的。如果是新的，则调用 persist 将对象数据 insert 到数据库。如果不是新的，则调用 merge 将对象数据 update/insert 到数据库。源码：spring-data-jpa.jar!\\org\\springframework\\data\\jpa\\repository\\support\\SimpleJpaRepository.java # SimpleJpaRepository 源码片段123456789@Transactionalpublic &lt;S extends T&gt; S save(S entity) &#123; if (entityInformation.isNew(entity)) &#123; em.persist(entity); return entity; &#125; else &#123; return em.merge(entity); &#125;&#125; 判断实体对象是否是新的，其依据是主键字段是否设置了有效的值。源码：spring-data-commons.jar!\\org\\springframework\\data\\repository\\core\\support\\AbstractEntityInformation.java # AbstractEntityInformation 源码片段1234567891011public boolean isNew(T entity) &#123; ID id = getId(entity); Class&lt;ID&gt; idType = getIdType(); if (!idType.isPrimitive()) &#123; return id == null; &#125; if (id instanceof Number) &#123; return ((Number) id).longValue() == 0L; &#125; throw new IllegalArgumentException(String.format(\"Unsupported primitive id type %s!\", idType));&#125; 因此，CrudRepository.save()既有保存又有更新数据的能力。保存一条数据： 1234567@Testpublic void testSave() &#123; Employee employee = new Employee(); employee.setName(\"张三丰\"); employee.setAge(24); employeeRepository.save(employee);&#125; 更新数据时，应该先从数据库将记录查询出来，对数据修改完成之后再调用save更新回数据库： 123456@Testpublic void testUpdate() &#123; Employee employee = employeeRepository.findByName(\"张三丰\"); employee.setAge(25); employeeRepository.save(employee);&#125; 切勿脑洞大开异想通过设置主键字段的值来直接更新数据库的记录，以下做法是不可取的： 1234567@Testpublic void testUpdateById() &#123; Employee employee = new Employee(); employee.setId(1L); // 已知ID=1的记录是存在的 employee.setAge(26); // 期望根据ID更新年龄的值 employeeRepository.save(employee);&#125; 方法执行完之后悲剧就发生了，除了主键和年龄之外，其余字段的值全部被清空了。观众朋友切勿模仿。 1.2.2 delete根据主键删除时，主键字段不能为空，并且在数据库中必须得有与主键对应的行记录（通过SELECT查询判断），然后将查询出的行记录删除。 1234@Testpublic void testDeleteById() &#123; employeeRepository.delete(1L); // 产生 SELECT 和 DELETE 语句&#125; 根据实体删除时，实体对象不能为空，依据实体的主键标识判断数据库中是否有与之对应的行记录，如果有，则将此行删除；如果没有，则调用merge产生 INSERT 语句，然后再删除。 12345678910111213@Testpublic void testDeleteByEntity() &#123; Employee employee = new Employee(); employee.setId(2L); // 此 ID 在数据库中存在 employeeRepository.delete(employee); // 产生 SELECT 和 DELETE&#125; @Testpublic void testDeleteByNonExistentEntity() &#123; Employee employee = new Employee(); employee.setId(20L); // 此 ID 在数据库中不存在 employeeRepository.delete(employee); // 产生 SELECT 和 INSERT 及 DELETE&#125; 1.3 PagingAndSortingRepository继承自 CrudRepository 接口，它提供了一个分页和排序的操作方法。扩展此接口需要传递实体类型和实体的ID字段类型参数，但是通常我们会比较少选择扩展该接口，而更多的是在接口里声明含有 Pageable 或 Sort 类型参数的方法来完成分页或排序的功能。 123public interface EmployeeRepository extends PagingAndSortingRepository&lt;Employee, Long&gt; &#123; &#125; 1.3.1 排序查询123456789@Testpublic void testSelectAndOrder() &#123; List&lt;Order&gt; orders = new ArrayList&lt;&gt;(); orders.add(new Order(Direction.DESC, \"salary\")); // 薪资降序 orders.add(new Order(\"age\")); // 薪资相同则按年龄升序 orders.add(new Order(\"hireDate\").with(Direction.ASC)); // 薪资和年龄都相同则按入职时间升序 employeeRepository.findAll(new Sort(orders)) .forEach(System.out::println);&#125; 或 12345678@Testpublic void testSelectAndSort() &#123; Sort sort = new Sort(Direction.DESC, \"salary\") // 薪资降序 .and(new Sort(\"age\")) // 薪资相同则按年龄升序 .and(new Sort(Direction.DESC, \"hireDate\")); // 薪资和年龄都相同则按入职时间升序 employeeRepository.findAll(sort) .forEach(System.out::println);&#125; 1.3.2 分页查询1234567891011121314151617181920@Testpublic void testSelectByPagination() &#123; // 分页索引从0开始, 表示第一页 Page&lt;Employee&gt; page = employeeRepository.findAll(new PageRequest(0, 2)); long totalElements = page.getTotalElements(); // 查询结果总的记录条数 int totalPages = page.getTotalPages(); // 分页的总页数 List&lt;Employee&gt; content = page.getContent(); // 当前页的数据内容 int number = page.getNumber(); // 当前页的页码, 从0开始, 表示第一页 int numberOfElements = page.getNumberOfElements(); // 每页的记录条数 int size = page.getSize(); // 每页的记录条数 Sort sort = page.getSort(); // 分页查询的排序对象 boolean isFirst = page.isFirst(); // 是否是第一页 boolean isLast = page.isLast(); // 是否是最后一页 boolean hasContent = page.hasContent(); // 当前页是否有数据 boolean hasNext = page.hasNext(); // 是否有下一页 boolean hasPrevious = page.hasPrevious(); // 是否有上一页 Pageable nextPageable = page.nextPageable(); // 下一页的分页对象 Pageable previousPageable = page.previousPageable(); // 上一页的分页对象 page.forEach(System.out::println);&#125; 1.3.3 分页并排序1234567@Testpublic void testSelectByPaginationAndSort() &#123; Sort sort = new Sort(Direction.DESC, \"salary\") // 薪资降序 .and(new Sort(\"age\")); // 薪资相同则按年龄升序 Page&lt;Employee&gt; page = employeeRepository.findAll(new PageRequest(0, 2, sort)); page.forEach(System.out::println);&#125; 1.4 JpaRepository继承自 PagingAndSortingRepository 接口，它提供了一组实用的操作方法，如批量操作等。扩展此接口需要传递实体类型和实体的ID字段类型参数，该接口的一部分方法返回 List 类型的实体，与之不同的是，CrudRepository 返回的是 Iterable 类型的实体。 123public interface EmployeeRepository extends JpaRepository&lt;Employee, Long&gt; &#123; &#125; 2. 定义查询方法Spring Data JPA 在运行时会为接口创建代理对象并为接口声明的方法提供具体的实现。代理提供了两种方式来从方法名中提取查询，一种是从方法名中直接提取查询，另外一种是从方法中提取手工定义的查询语句。代理如何创建查询是由具体的策略来决定的。 策略 简述 CREATE 根据方法名构造出一个特定的查询。具体的做法是从方法名中移除一组已知的前缀，然后解析剩余的部分。 USE_DECLARED_QUERY 使用查询注解定义的查询语句。如：@Query、@NamedQuery、@NamedNativeQuery CREATE_IF_NOT_FOUND 默认使用的策略。它组合了 CREATE 和 USE_DECLARED_QUERY 两个策略。它首先使用 USE_DECLARED_QUERY 策略查找，如果找不到再使用 CREATE 策略。 2.1 创建查询JPA 提供了一种可以根据方法名称直接构造出查询语句的方式，这种方式称为创建查询。在存储库接口中定义的方法，其名称只需按照约定命名，需满足以下的规则： 方法名必须以：findBy find...By readBy read...By queryBy query...BycountBy count...By getBy get...By前缀之一开始命名； 在第一个By之后可以添加查询方法的检索条件，可以使用实体的属性名和支持的关键字来组合； 在第一个By之前可以添加First或Top关键字，表示返回查询结果的第一条数据。除此之外，关键字First或Top的后面也可以携带数字表示返回前多少条的数据，如Top10； 在第一个By之前可以添加Distinct关键字，去掉查询结果中重复的数据； 查询方法如果设定了X个检索条件，那么，查询方法的参数个数也必须是X个，并且参数必须按与检索条件相同的顺序给出； 查询方法同时还可以使用特殊的Pageable或Sort参数，用于分页或排序，该参数不算在X之内； 2.1.1 查询方法支持的关键字表 关键字 示例 JPQL 片段 And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 IsEquals findByFirstnamefindByFirstnameIsfindByFirstnameEquals … where x.firstname = ?1 Between findByStartDateBetween … where x.startDate between ?1 and ?2 LessThan findByAgeLessThan … where x.age &lt; ?1 LessThanEqual findByAgeLessThanEqual … where x.age &lt;= ?1 GreaterThan findByAgeGreaterThan … where x.age &gt; ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age &gt;= ?1 After findByStartDateAfter … where x.startDate &gt; ?1 Before findByStartDateBefore … where x.startDate &lt; ?1 IsNull findByAgeIsNull … where x.age is null IsNotNullNotNull findByAgeNotNullfindByAgeIsNotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1 (parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1 (parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1 (parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ?1 order by x.lastname desc Not findByLastnameNot … where x.lastname &lt;&gt; ?1 In findByAgeIn(Collection&lt;Age&gt; ages) … where x.age in ?1 NotIn findByAgeNotIn(Collection&lt;Age&gt; age) … where x.age not in ?1 True findByActiveTrue() … where x.active = true False findByActiveFalse() … where x.active = false IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstame) = UPPER(?1) 2.1.2 查询方法支持的返回值表 类型 简述 void 不需要返回值 Primitives Java 基本数据类型 Wrapper Java 基本数据类型对应的包装类型 T 期望返回的实体类型，查询方法至多只能返回一条数据结果，多于一条数据的结果将抛出异常，没有查询到数据结果，则返回 null Iterator&lt;T&gt; 迭代器类型 Collection&lt;T&gt; 集合类型 List&lt;T&gt; List 集合类型 Optional&lt;T&gt; Java8 Optional 类型 Stream&lt;T&gt; Java8 Stream 类型 Future&lt;T&gt; Java8 Future 类型，使用@Async注解标注查询方法，并且需要启用 Spring 异步方法执行的功能 CompletableFuture&lt;T&gt; Java8 CompletableFuture 类型，使用@Async注解标注查询方法，并且需要启用 Spring 异步方法执行的功能 ListenableFuture Spring ListenableFuture 类型，使用@Async注解标注查询方法，并且需要启用 Spring 异步方法执行的功能 Slice 分页相关 Page&lt;T&gt; 分页相关 在存储库接口中定义的方法，只需要按照约定命名，就能快速实现查询的功能： 123456789101112131415161718192021public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; // 根据姓名查询 Employee findByName(String name); // 根据姓名查询, 返回第一条记录 Employee findFirstByName(String name); // 根据姓名和性别查询 Employee findByNameAndSex(String name, Sex sex); // 根据性别查询, 返回前3条记录 List&lt;Employee&gt; findTop3BySex(Sex sex); // 根据性别分页查询 Page&lt;Employee&gt; findBySex(Sex sex, Pageable pageable); // 根据给定的年龄查找小于且未婚的记录并按年龄升序排序 List&lt;Employee&gt; findByAgeLessThanAndMarriedIsFalseOrderByAge(int age); &#125; 创建查询的优点是，不用编写查询语句，处理检索条件简单的查询非常方便，而且方法的可读性很高。但是对于检索条件过多的查询方法，很容易导致方法名称过长，可读性降低。 2.2 命名查询JPA 提供了一种可以将查询语句从存储库接口中独立出来的方式，这种方式称为命名查询。它允许我们通过使用@NamedQuery或@NamedNativeQuery注解将预定义好的静态查询语句直接绑定到目标方法。命名查询的优点是，查询语句集中，便于维护，查询方法的名称不受约束，编写复杂的查询只要合理命名也不会导致产生过长的方法名称。但是由于命名查询的注解都是标注在实体类中，因此它不适合用于大量定义查询语句，这样会使得实体类变得过于臃肿。 2.2.1 @NamedQuery 参数 简述 name 用于定义查询的方法名称，该方法名称是全局范围的，为避免不同的实体定义了相同的方法名称而导致的查询冲突，JPA 明确规定自定义的方法名称的命名需要满足约定：实体类的简单类名 + “.” + 自定义的查询方法名称 query 用于定义 JPQL 查询语句（附：查询参数语法） 使用@NamedQuery注解需要在实体类中标注使用： 12345678910111213141516@Entity(name = \"Employee\")@NamedQueries(&#123; @NamedQuery( name = \"Employee.selectBySex\", query = \"SELECT E FROM Employee E WHERE E.sex = ?1\" ), @NamedQuery( name = \"Employee.selectByName\", query = \"SELECT E FROM Employee E WHERE E.name = ?1\" )&#125;)public class Employee &#123; ... &#125; 然后在存储库接口中声明与这些名称相同的方法即可： 1234567public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; Employee selectByName(String name); List&lt;Employee&gt; selectBySex(Sex sex); &#125; 2.2.2 @NamedNativeQuery注解@NamedNativeQuery与@NamedQuery的用法和作用相类似。不同的是，@NamedQuery使用的是 JPQL 查询语言，可以做到跨数据库平台。而@NamedNativeQuery使用的是 SQL 查询语言，与特定的数据库平台紧密相关。@NamedNativeQuery注解也是需要在实体类中标注使用： 123456789101112131415161718@Entity(name = \"Employee\")@NamedNativeQueries(&#123; @NamedNativeQuery( name = \"Employee.searchBySex\", query = \"SELECT * FROM EMPLOYEE WHERE SEX = ?1\", resultClass = Employee.class ), @NamedNativeQuery( name = \"Employee.searchByName\", query = \"SELECT * FROM EMPLOYEE WHERE NAME = ?1\", resultClass = Employee.class )&#125;)public class Employee &#123; ... &#125; 相比较@NamedQuery注解而言，多了一个resultClass参数，它用于定义查询结果的返回值类型。 1234567public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; Employee searchByName(String name); List&lt;Employee&gt; searchBySex(String sex); &#125; 2.3 @Query 查询使用@Query注解可以直接将查询语句绑定到存储库接口的方法上，它同时支持 JPQL 和 SQL 查询语言。另外，它对方法名称的命名没有约束，并且查询语句就编写在方法的上方，方便追踪查询方法的具体作用。 2.3.1 JPQL 查询注解@Query默认使用的就是 JPQL 查询语言： 123456public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; @Query(\"SELECT E FROM Employee E WHERE E.name = ?1\") Employee queryOneByName(String name); &#125; 2.3.2 SQL 查询在@Query注解中，如果要使用 SQL 查询语言，nativeQuery参数需要标记为 true： 123456public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; @Query(value = \"SELECT * FROM EMPLOYEE WHERE NAME = ?1\", nativeQuery = true) Employee queryOneByName(String name); &#125; 2.3.3 LIKE 查询在@Query注解中，可以使用高级的LIKE表达式查询（命名查询不支持）： 123456public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; @Query(\"SELECT E FROM Employee E WHERE E.name LIKE %?1\") List&lt;Employee&gt; queryNameLike(String suffixName); &#125; 2.3.4 分页查询如果你使用的是@Query的 JPQL 查询语言，只需在查询方法中添加Pageable参数就能实现分页查询： 123456public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; @Query(\"SELECT E FROM Employee E WHERE E.sex = ?1\") Page&lt;Employee&gt; queryBySexPagination(Sex sex, Pageable pageable); &#125; 如果你使用的不是 JPQL 而是 SQL 查询语言，则还需提供countQuery参数用于查询结果的总条数： 12345678public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; @Query(value = \"SELECT * FROM EMPLOYEE WHERE SEX = ?1\", countQuery = \"SELECT COUNT(*) FROM EMPLOYEE WHERE SEX = ?1 \", nativeQuery = true) Page&lt;Employee&gt; queryBySexPagination(String sex, Pageable pageable); &#125; Spring Data JPA 官方文档给出了@Query注解使用本地查询分页的基础示例（Example 51），但是按照该示例编写出的代码运行时报错。 2.3.5 排序查询如果你使用的是@Query的 JPQL 查询语言，只需在查询方法中添加Sort参数就能实现排序功能： 123456public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; @Query(\"SELECT E FROM Employee E WHERE E.sex = ?1\") List&lt;Employee&gt; queryBySexAndSort(Sex sex, Sort sort); &#125; 注：@Query的本地查询（SQL 查询）不支持这种动态排序的功能。 如果是分页查询需要排序支持，可以通过向PageRequest构造器传入Sort对象来完成： 123456@Testpublic void testQueryBySexPagination() &#123; Page&lt;Employee&gt; page = employeeRepository.queryBySexPagination(Sex.FEMALE, new PageRequest(0, 2, new Sort(\"age\"))); page.forEach(System.out::println);&#125; 2.3.6 SpEL 表达式Spring Data JPA 1.4 版本开始引入 SpEL 表达式，目前支持的 SpEL 表达式非常有限（目前仅有一个）： 变量 描述 entityName 存储库接口关联的实体类的实体名称。如果实体类@Entity注解设置了name属性，那么将使用它。否则将使用实体类的简单类名。 123456public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; @Query(\"SELECT E FROM #&#123;#entityName&#125; E WHERE E.name = ?1\") Employee queryByNameSpEL(String name); &#125; 2.3.7 更新查询@Query注解除了可以用来定义查询语句还可以用来定义更新语句（UPDATE/DELETE），在@Query标注的方法上只需要使用@Modifying注解就能实现更新的行为： 1234567891011public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; &#123; @Modifying @Query(\"UPDATE Employee E SET E.salary = ?2 WHERE E.name = ?1\") int updateSalaryForName(String name, Double salary); @Modifying @Query(\"DELETE FROM Employee E WHERE E.name = ?1\") int deleteByName(String name); &#125; 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-jpa-sample参考文档文献链接：http://docs.spring.io/spring-data/jpa/docs/1.11.1.RELEASE/reference/html","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot Tomcat & HikariCP & DBCP 连接池","date":"2017-04-29T15:12:15.000Z","path":"post/spring-boot-tomcat-pool-hikaricp-dbcp-dbcp2.html","text":"Tomcat JDBC 连接池Spring Boot 默认选择 Tomcat JDBC Pool 作为数据库连接池。Tomcat（8） 连接池常用的属性： 属性 描述 默认值 defaultAutoCommit 连接池中创建的连接默认是否自动提交事务 驱动的缺省值 defaultReadOnly 连接池中创建的连接默认是否为只读状态 - defaultCatalog 连接池中创建的连接默认的 catalog - driverClassName 驱动类的名称 - username 数据库账户 - password 数据库密码 - maxActive 连接池同一时间可分配的最大活跃连接数 100 maxIdle 始终保留在池中的最大连接数，如果启用，将定期检查限制连接，超出此属性设定的值且空闲时间超过minEvictableIdleTimeMillis的连接则释放 与maxActive设定的值相同 minIdle 始终保留在池中的最小连接数，池中的连接数量若低于此值则创建新的连接，如果连接验证失败将缩小至此值 与initialSize设定的值相同 initialSize 连接池启动时创建的初始连接数量 10 maxWait 最大等待时间（毫秒），如果在没有连接可用的情况下等待超过此时间，则抛出异常 30000（30秒） testOnBorrow 当从连接池中取出一个连接时是否进行验证，若验证失败则从池中删除该连接并尝试取出另一个连接 false testOnConnect 当一个连接首次被创建时是否进行验证，若验证失败则抛出 SQLException 异常 false testOnReturn 当一个连接使用完归还到连接池时是否进行验证 false testWhileIdle 对池中空闲的连接是否进行验证，验证失败则回收此连接 false validationQuery 在连接池返回连接给调用者前用来对连接进行验证的查询 SQL null validationQueryTimeout SQL 查询验证超时时间（秒），小于或等于 0 的数值表示禁用 -1 timeBetweenEvictionRunsMillis 在空闲连接回收器线程运行期间休眠时间（毫秒）， 该值不应该小于 1 秒，它决定线程多久验证空闲连接或丢弃连接的频率 5000（5秒） minEvictableIdleTimeMillis 连接在池中保持空闲而不被回收的最小时间（毫秒） 60000（60秒） removeAbandoned 标记是否删除泄露的连接，如果连接超出removeAbandonedTimeout的限制，且该属性设置为 true，则连接被认为是被泄露并且可以被删除 false removeAbandonedTimeout 泄露的连接可以被删除的超时时间（秒），该值应设置为应用程序查询可能执行的最长时间 60 # src/main/resources/application.properties12345678910111213141516spring.datasource.url=jdbc:mysql://127.0.0.1/spring_boot_testing_storagespring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.tomcat.default-auto-commit=truespring.datasource.tomcat.initial-size=3spring.datasource.tomcat.max-active=120spring.datasource.tomcat.max-wait=10000spring.datasource.tomcat.test-on-borrow=truespring.datasource.tomcat.test-while-idle=truespring.datasource.tomcat.validation-query=SELECT 1spring.datasource.tomcat.validation-query-timeout=3spring.datasource.tomcat.time-between-eviction-runs-millis=10000spring.datasource.tomcat.min-evictable-idle-time-millis=120000spring.datasource.tomcat.remove-abandoned=truespring.datasource.tomcat.remove-abandoned-timeout=120 # src/main/resources/application.yml12345678910111213141516171819spring: datasource: url: jdbc:mysql://127.0.0.1/spring_boot_testing_storage username: root password: root driver-class-name: com.mysql.jdbc.Driver tomcat: default-auto-commit: true initial-size: 30 max-active: 120 max-wait: 10000 test-on-borrow: true test-while-idle: true validation-query: 'SELECT 1' validation-query-timeout: 3 time-between-eviction-runs-millis: 10000 min-evictable-idle-time-millis: 120000 remove-abandoned: true remove-abandoned-timeout: 120 Spring Boot Data Jpa 依赖声明： # pom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; HikariCP 连接池Spring Boot 如果发现 Tomcat 连接池不可用，则尝试选择 HikariCP 作为默认连接池。HikariCP 连接池常用的属性： 属性 描述 默认值 dataSourceClassName JDBC 驱动程序提供的 DataSource 类的名称，如果使用了jdbcUrl则不需要此属性 - jdbcUrl 数据库连接地址 - username 数据库账户，如果使用了jdbcUrl则需要此属性 - password 数据库密码，如果使用了jdbcUrl则需要此属性 - autoCommit 是否自动提交事务 true connectionTimeout 连接超时时间（毫秒），如果在没有连接可用的情况下等待超过此时间，则抛出 SQLException 30000（30秒） idleTimeout 空闲超时时间（毫秒），只有在minimumIdle&lt;maximumPoolSize时生效，超时的连接可能被回收，数值 0 表示空闲连接永不从池中删除 600000（10分钟） maxLifetime 连接池中的连接的最长生命周期（毫秒）。数值 0 表示不限制 1800000（30分钟） connectionTestQuery 连接池每分配一条连接前执行的查询语句（如：SELECT 1），以验证该连接是否是有效的。如果你的驱动程序支持 JDBC4，HikariCP 强烈建议我们不要设置此属性 - minimumIdle 最小空闲连接数，HikariCP 建议我们不要设置此值，而是充当固定大小的连接池 与maximumPoolSize数值相同 maximumPoolSize 连接池中可同时连接的最大连接数，当池中没有空闲连接可用时，就会阻塞直到超出connectionTimeout设定的数值 10 poolName 连接池名称，主要用于显示在日志记录和 JMX 管理控制台中 auto-generated # src/main/resources/application.properties1234567spring.datasource.url=jdbc:mysql://127.0.0.1/spring_boot_testing_storagespring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.hikari.auto-commit=truespring.datasource.hikari.connection-test-query=SELECT 1spring.datasource.hikari.maximum-pool-size=150 # src/main/resources/application.yml12345678910spring: datasource: url: jdbc:mysql://127.0.0.1/spring_boot_testing_storage username: root password: root driver-class-name: com.mysql.jdbc.Driver hikari: auto-commit: true connection-test-query: 'SELECT 1' maximum-pool-size: 150 Spring Boot Data Jpa 依赖声明： # pom.xml123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt; DBCP 连接池Spring Boot 如果发现 HikariCP 连接池不可用，则尝试选择 DBCP 作为默认连接池。DBCP（2） 连接池常用的属性： 属性 描述 默认值 url 数据库连接地址 - username 数据库账户 - password 数据库密码 - driverClassName 驱动类的名称 - defaultAutoCommit 连接池中创建的连接默认是否自动提交事务 驱动的缺省值 defaultReadOnly 连接池中创建的连接默认是否为只读状态 驱动的缺省值 defaultCatalog 连接池中创建的连接默认的 catalog - initialSize 连接池启动时创建的初始连接数量 0 maxTotal 连接池同一时间可分配的最大活跃连接数；负数表示不限制 8 maxIdle 可以在池中保持空闲的最大连接数，超出此值的空闲连接被释放，负数表示不限制 8 minIdle 可以在池中保持空闲的最小连接数，低于此值将创建空闲连接，若设置为 0，则不创建 0 maxWaitMillis 最大等待时间（毫秒），如果在没有连接可用的情况下等待超过此时间，则抛出异常；-1 表示无限期等待，直到获取到连接为止 - validationQuery 在连接池返回连接给调用者前用来对连接进行验证的查询 SQL - validationQueryTimeout SQL 查询验证超时时间（秒） - testOnCreate 连接在创建之后是否进行验证 false testOnBorrow 当从连接池中取出一个连接时是否进行验证，若验证失败则从池中删除该连接并尝试取出另一个连接 true testOnReturn 当一个连接使用完归还到连接池时是否进行验证 false testWhileIdle 对池中空闲的连接是否进行验证，验证失败则释放此连接 false timeBetweenEvictionRunsMillis 在空闲连接回收器线程运行期间休眠时间（毫秒），如果设置为非正数，则不运行此线程 -1 numTestsPerEvictionRun 空闲连接回收器线程运行期间检查连接的个数 3 minEvictableIdleTimeMillis 连接在池中保持空闲而不被回收的最小时间（毫秒） 1800000（30分钟） removeAbandonedOnBorrow 标记是否删除泄露的连接，如果连接超出removeAbandonedTimeout的限制，且该属性设置为 true，则连接被认为是被泄露并且可以被删除 false removeAbandonedTimeout 泄露的连接可以被删除的超时时间（秒），该值应设置为应用程序查询可能执行的最长时间 300（5分钟） poolPreparedStatements 设置该连接池的预处理语句池是否生效 false # src/main/resources/application.properties123456789101112131415161718192021spring.jmx.enabled=falsespring.datasource.url=jdbc:mysql://127.0.0.1/spring_boot_testing_storagespring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.dbcp2.default-auto-commit=truespring.datasource.dbcp2.initial-size=30spring.datasource.dbcp2.max-total=120spring.datasource.dbcp2.max-idle=120spring.datasource.dbcp2.min-idle=30spring.datasource.dbcp2.max-wait-millis=10000spring.datasource.dbcp2.validation-query=SELECT 1spring.datasource.dbcp2.validation-query-timeout=3spring.datasource.dbcp2.test-on-borrow=truespring.datasource.dbcp2.test-while-idle=truespring.datasource.dbcp2.time-between-eviction-runs-millis=10000spring.datasource.dbcp2.num-tests-per-eviction-run=10spring.datasource.dbcp2.min-evictable-idle-time-millis=120000spring.datasource.dbcp2.remove-abandoned-on-borrow=truespring.datasource.dbcp2.remove-abandoned-timeout=120spring.datasource.dbcp2.pool-prepared-statements=true # src/main/resources/application.yml12345678910111213141516171819202122232425spring: jmx: enabled: false datasource: url: jdbc:mysql://127.0.0.1/spring_boot_testing_storage username: root password: root driver-class-name: com.mysql.jdbc.Driver dbcp2: default-auto-commit: true initial-size: 30 max-total: 120 max-idle: 120 min-idle: 30 max-wait-millis: 10000 validation-query: 'SELECT 1' validation-query-timeout: 3 test-on-borrow: true test-while-idle: true time-between-eviction-runs-millis: 10000 num-tests-per-eviction-run: 10 min-evictable-idle-time-millis: 120000 remove-abandoned-on-borrow: true remove-abandoned-timeout: 120 pool-prepared-statements: true Spring Boot Data Jpa 依赖声明： # pom.xml123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt; 参考文档文献链接：tomcat-8-jdbc-pool-doc、HikariCP-doc、commons-dbcp-doc","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot JDBC","date":"2017-04-28T12:18:25.000Z","path":"post/spring-boot-jdbc-example.html","text":"Spring 对 JDBC API 操作数据库进行了良好的封装，通过使用 JdbcTemplate，你不必关心数据库连接创建和打开、处理异常、连接关闭等问题。这些细节都由 JdbcTemplate 底层来完成，你只需要专注于业务 SQL 语句的编写以及执行结果的处理。在 Spring Boot 中，你可以通过spring-boot-starter-jdbc启动器快速开启和使用它。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 1. 环境配置在 MySQL 测试数据库创建表： 123456CREATE TABLE `employee` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键', `name` varchar(128) DEFAULT NULL COMMENT '姓名', `age` int(11) DEFAULT NULL COMMENT '年龄', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=gbk COMMENT='员工表'; 编写对应的实体类： 1234567891011public class Employee &#123; private Long id; private String name; private Integer age; // getters and setters &#125; 项目配置文件信息： # src/main/resources/application.yml1234567891011121314spring: main: banner-mode: 'off' datasource: url: jdbc:mysql://127.0.0.1/test username: root password: root driver-class-name: com.mysql.jdbc.Driver tomcat: default-auto-commit: truelogging: level: root: warn org.springframework.jdbc.core.JdbcTemplate: debug 2. 保存操作向数据库插入一条记录： 1234public int save(Employee employee) &#123; return jdbcTemplate.update(\"INSERT INTO EMPLOYEE(NAME, AGE) VALUE (?, ?)\", employee.getName(), employee.getAge());&#125; 如果表的主键字段是自动递增的，可以使用GeneratedKeyHolder来接收 SQL 执行完成之后插入数据库的记录的主键的值： 123456789101112public Employee save(Employee employee) &#123; KeyHolder keyHolder = new GeneratedKeyHolder(); jdbcTemplate.update(con -&gt; &#123; PreparedStatement ps = con.prepareStatement(\"INSERT INTO EMPLOYEE(NAME, AGE) VALUE (?, ?)\", Statement.RETURN_GENERATED_KEYS); ps.setString(1, employee.getName()); ps.setInt(2, employee.getAge()); return ps; &#125;, keyHolder); employee.setId(keyHolder.getKey().longValue()); return employee;&#125; 3. 查询操作查询某个字段信息： 1234public String findNameById(Long id) &#123; return jdbcTemplate.queryForObject(\"SELECT NAME FROM EMPLOYEE WHERE ID = ?\", new Object[]&#123;id&#125;, String.class);&#125; 查询一条完整的记录： 12345678910public Employee findById(Long id) &#123; return jdbcTemplate.queryForObject(\"SELECT * FROM EMPLOYEE WHERE ID = ?\", new Object[]&#123;id&#125;, (rs, rowNum) -&gt; &#123; Employee employee = new Employee(); employee.setId(rs.getLong(\"id\")); employee.setAge(rs.getInt(\"age\")); employee.setName(rs.getString(\"name\")); return employee; &#125;);&#125; 查询所有的记录： 12345678910public List&lt;Employee&gt; findAll() &#123; return jdbcTemplate.query(\"SELECT * FROM EMPLOYEE\", (rs, rowNum) -&gt; &#123; Employee employee = new Employee(); employee.setId(rs.getLong(\"id\")); employee.setAge(rs.getInt(\"age\")); employee.setName(rs.getString(\"name\")); return employee; &#125;);&#125; 4. 更新操作更新数据库中的一条记录： 1234public int update(Employee employee) &#123; return jdbcTemplate.update(\"UPDATE EMPLOYEE SET NAME = ?, AGE = ? WHERE ID = ?\", employee.getName(), employee.getAge(), employee.getId());&#125; 批量更新记录： 12345678910111213141516public int[] batchUpdate(List&lt;Employee&gt; employees) &#123; return jdbcTemplate.batchUpdate(\"UPDATE EMPLOYEE SET NAME = ?, AGE = ? WHERE ID = ?\", new BatchPreparedStatementSetter() &#123; @Override public void setValues(PreparedStatement ps, int i) throws SQLException &#123; Employee employee = employees.get(i); ps.setString(1, employee.getName()); ps.setInt(2, employee.getAge()); ps.setLong(3, employee.getId()); &#125; @Override public int getBatchSize() &#123; return employees.size(); &#125; &#125;);&#125; 5. 删除操作删除一条记录： 123public int delete(Long id) &#123; return jdbcTemplate.update(\"DELETE FROM EMPLOYEE WHERE ID = ?\", id);&#125; 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-jdbc-sample参考文档文献链接：relational-data-access","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot 启动器介绍","date":"2017-04-26T12:18:25.000Z","path":"post/spring-boot-starters-list.html","text":"Spring Boot 提供的启动器（Starters）是一组非常方便的依赖关系描述符，你可以通过启动器获得所有和 Spring 技术相关的一站式服务。所有官方的启动器都是以spring-boot-starter-*模式命名，其中*是表示某种特定类型的应用。这种命名结构能够帮助我们快速的找到所需的启动器。例如，如果想使用 Spring 和 JDBC 技术，你只需要在项目中使用spring-boot-starter-jdbc依赖即可。 名称 描述 pom spring-boot-starter-thymeleaf Thymeleaf 作为视图的 Spring MVC Web 应用 pom spring-boot-starter-data-couchbase Couchbase 数据库 pom spring-boot-starter-artemis Apache Artemis 提供的 JMS 消息服务 pom spring-boot-starter-web-services Spring Web Services pom spring-boot-starter-mail Java Mail 和 Spring 支持的电子邮件发送 pom spring-boot-starter-data-redis Jedis 作为客户端的 Redis 缓存 pom spring-boot-starter-web Spring MVC 的 RESTful 应用，Tomcat 作为内嵌容器 pom spring-boot-starter-data-gemfire GemFire 分布式数据存储 pom spring-boot-starter-activemq Apache ActiveMQ 提供的 JMS 消息服务 pom spring-boot-starter-data-elasticsearch Elasticsearch 搜索引擎 pom spring-boot-starter-test 单元测试 pom spring-boot-starter-jdbc 内置 Tomcat JDBC 连接池的 Spring JDBC 应用 pom spring-boot-starter-mobile Spring Mobile 构建的 Web 应用 pom spring-boot-starter-validation Hibernate Validator 验证器 pom spring-boot-starter-websocket Websocket 应用 pom spring-boot-starter-aop Spring AOP 和 AspectJ 面向方面的编程 pom spring-boot-starter-amqp Rabbit MQ 提供的 JMS 消息服务 pom spring-boot-starter-data-cassandra Cassandra 分布式数据库 pom spring-boot-starter-social-facebook Spring Social Facebook pom spring-boot-starter-jta-atomikos Atomikos JTA 事务 pom spring-boot-starter-security Spring Security 安全框架 pom spring-boot-starter-data-jpa Spring Data JPA pom spring-boot-starter 核心启动器，包括自动配置支持，日志记录和YAML pom spring-boot-starter-groovy-templates Groovy 作为视图的 Spring MVC Web 应用 pom spring-boot-starter-freemarker Freemarker 作为视图的 Spring MVC Web 应用 pom spring-boot-starter-batch Spring Batch pom spring-boot-starter-cache Spring 框架缓存 pom spring-boot-starter-data-solr Solr 搜索引擎 pom spring-boot-starter-data-mongodb Mongo 数据库 pom spring-boot-starter-jooq jOOQ 访问数据库 pom","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot 日志","date":"2017-04-25T15:21:15.000Z","path":"post/spring-boot-logging.html","text":"Spring Boot 内部所有的日志记录都是通过使用 Commons Logging 实现，同时默认配置也提供了 Java Util Logging、Log4J、Log4J2、Logback 的支持。每种日志都预配置可以使用控制台输出和文件输出。Spring Boot 日志由启动器spring-boot-starter-logging来解决： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt; 你不必显式的声明此依赖。默认情况下，Spring Boot 使用 Logback 进行日志记录。 1. 日志级别在 Spring Boot 中，通过logging.level.*=TRACE/DEBUG/INFO/WARN/ERROR/FATAL/OFF来设置日志的级别。*可以是根级别（root）也可以是包级别。 application.properties 配置示例： 123logging.level.root = WARNlogging.level.org.springframework = INFOlogging.level.org.hibernate.SQL = DEBUG application.yml 配置示例： 12345logging: level: root: WARN org.springframework: INFO org.hibernate.SQL: DEBUG 2. 文件输出默认情况下，Spring Boot 只将日志信息显示到控制台。如果你想要将日志信息输出到外部文件，你可以使用logging.file或logging.path属性来配置。日志文件大小达到 10M 时，将产生一个新的文件。 使用logging.file可以设置日志输出的文件 文件相对路径（相对项目的根目录）：logfile.log或logs/logfile.log 文件绝对路径：/pathname/logfile.log application.properties 配置示例： 1logging.file = logs/logfile.log application.yml 配置示例： 12logging: file: logs/logfile.log 使用logging.path可以设置日志输出的目录，spring.log日志文件将输出到该目录 目录相对路径（相对项目的根目录）：logs或pathname/logs 目录绝对路径：/pathname/logs application.properties 配置示例： 1logging.path = logs application.yml 配置示例： 12logging: path: logs 3. 日志格式Spring Boot 默认输出的日志信息格式： 122017-07-09 11:47:06.599 INFO 10252 --- [main] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup2017-07-09 11:47:06.632 INFO 10252 --- [main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http) 它由以下几个部分组成： 精确到毫秒的日期和时间 日志级别（TRACE&lt;br&gt;DEBUG&lt;br&gt;INFO&lt;br&gt;WARN&lt;br&gt;ERROR） 进程 ID 分隔符--- 线程名称，包裹在[]中 日志名称，通常是类的完全限定路径的简写 分隔符: 日志消息 使用logging.pattern.console（只支持logback）可以自定义控制台日志输出格式。 application.properties 配置示例： 1logging.pattern.console=\"%date&#123;yyyy-MM-dd HH:mm:ss&#125; -%5level [%15.15thread] %-40.40logger&#123;39&#125; : %msg%n\" application.yml 配置示例： 123logging: pattern: console: \"%date&#123;yyyy-MM-dd HH:mm:ss&#125; -%5level [%15.15thread] %-40.40logger&#123;39&#125; : %msg%n\" 使用logging.pattern.file（只支持logback）可以自定义文件的日志输出格式。 application.properties 配置示例： 1logging.pattern.file=\"%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; -%5level [%15.15thread] %-40.40logger&#123;39&#125; : %msg%n\" application.yml 配置示例： 123logging: pattern: file: \"%date&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; -%5level [%15.15thread] %-40.40logger&#123;39&#125; : %msg%n\" 常用的日志信息格式化参数： 参数 描述 %c{length}%logger{length} 输出所属的类目，通常就是所在类的全名 %d{pattern}%date{pattern} 输出日志的日期或时间 %F%file 输出发出日志记录请求的Java源文件的文件名 %L%line 输出日志事件的发生行号信息 %m%msg%message 输出程序代码中指定的消息 %p%le%level 输出日志级别信息 %t%thread 输出产生该日志事件的线程名 %n 输出一个平台的回车换行符 其中 %logger{length}，如果信息长度大于给定的 length 的值，保留最右边的单词，左边的每个单词只保留第一个字符。 示例 信息 结果 %logger org.fanlychie.DemoService org.fanlychie.DemoService %logger{0} org.fanlychie.DemoService DemoService %logger{10} org.fanlychie.DemoService o.f.DemoService %logger{24} org.fanlychie.DemoService o.fanlychie.DemoService %logger{100} org.fanlychie.DemoService org.fanlychie.DemoService 日志信息宽度和对齐方式控制，以%logger为例： 示例 描述 %50logger 右对齐，最小的宽度是50，长度不足50则左补空格，长度超出50则原样输出 %-50logger ‘-‘表示向左对齐，最小的宽度是50，长度不足50则右补空格，长度超出50则原样输出 %.20logger 左对齐，最大的宽度是20，如果长度超出20，将左边多出的字符直接丢掉 %30.50logger 最小宽度是30，如果长度不足30则左补空格右对齐；如果长度超出30且不足50则左对齐；如果长度超出50则将左边多出的字符直接丢掉 4. 扩展 logbackSpring Boot 允许我们通过扩展 Logback 进行更高级的配置。在类路径下创建logback-sprng.xml： 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;!-- 引用 Spring Boot 的 base.xml 的配置 --&gt; &lt;!-- spring-boot.jar!\\org\\springframework\\boot\\logging\\logback\\base.xml --&gt; &lt;include resource=\"org/springframework/boot/logging/logback/base.xml\"/&gt; &lt;!-- 自定义日志级别 --&gt; &lt;root level=\"ERROR\" /&gt; &lt;logger name=\"org.springframework.web\" level=\"INFO\"/&gt; &lt;logger name=\"org.hibernate.SQL\" level=\"DEBUG\"/&gt;&lt;/configuration&gt; 4.1 配置文件的加载Spring Boot 默认从系统类路径加载的日志配置文件： logback-spring.xml logback-spring.groovy logback.xml logback.groovy 单元测试的 DEBUG 日志可以在src/test/resources/logback-test.xml中配置控制。 5. 多环境日志配置使用&lt;springProfile&gt;标签可以定义不同 profile 环境的配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;!-- 引用 Spring Boot 的 defaults.xml 的配置 --&gt; &lt;include resource=\"org/springframework/boot/logging/logback/defaults.xml\"/&gt; &lt;!-- 定义 LOG_FILE 变量 --&gt; &lt;!-- 日志文件优先使用 logging.file 的值，如果没有则使用 logging.path 的值，如果还没有则放入临时目录 --&gt; &lt;property name=\"LOG_FILE\" value=\"$&#123;LOG_FILE:-$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;/&#125;spring.log&#125;\"/&gt; &lt;!-- 自定义日志级别 --&gt; &lt;logger name=\"org.springframework.web\" level=\"INFO\"/&gt; &lt;logger name=\"org.fanlychie\" level=\"DEBUG\"/&gt; &lt;!-- 开发环境日志 --&gt; &lt;springProfile name=\"dev\"&gt; &lt;!-- 引用 Spring Boot 的 console-appender.xml 的配置 --&gt; &lt;include resource=\"org/springframework/boot/logging/logback/console-appender.xml\"/&gt; &lt;!-- root 日志级别 --&gt; &lt;root level=\"WARN\"&gt; &lt;appender-ref ref=\"CONSOLE\"/&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;!-- 生产环境日志 --&gt; &lt;springProfile name=\"prod\"&gt; &lt;!-- 引用 Spring Boot 的 console-appender.xml 的配置 --&gt; &lt;include resource=\"org/springframework/boot/logging/logback/console-appender.xml\"/&gt; &lt;!-- 自定义文件日志 --&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;encoder&gt; &lt;!-- 使用默认的日志格式 --&gt; &lt;pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;!-- 日志文件 --&gt; &lt;file&gt;$&#123;LOG_FILE&#125;&lt;/file&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.FixedWindowRollingPolicy\"&gt; &lt;!-- 如果日志文件超出大小限制, 则以 $&#123;LOG_FILE&#125;.1, $&#123;LOG_FILE&#125;.2... 备份 --&gt; &lt;fileNamePattern&gt;$&#123;LOG_FILE&#125;.%i&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;!-- 超出大小限制开启一个新的文件 --&gt; &lt;MaxFileSize&gt;10MB&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;/appender&gt; &lt;!-- root 日志级别 --&gt; &lt;root level=\"WARN\"&gt; &lt;appender-ref ref=\"FILE\"/&gt; &lt;appender-ref ref=\"CONSOLE\"/&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt; application.properties 配置示例： 12spring.profiles.active = devlogging.file = logs/logfile.log application.yml 配置示例： 12345spring: profiles: active: devlogging: file: logs/logfile.log 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-logging-sample参考文档文献链接：logback-doc、spring-boot-logging","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot Profiles 配置","date":"2017-04-23T15:21:15.000Z","path":"post/spring-boot-profiles.html","text":"Spring Profiles 提供了一套隔离应用配置的方式，它允许我们通过定义不同的 profiles 来提供不同组合的配置。在不同的环境中，启动应用时可以通过选择激活某组特定的 profiles 来适应运行时环境，以达到在不同的环境可以使用相同的一套程序代码。 1. 使用 @Profiles 创建 profilesSpring 提供了@Profiles注解，用于创建 profiles 配置。你可以在@Component(@Service、@Repository) 或@Configuration注解标注的类中使用它。 12345public interface AuthorityService &#123; boolean hasRole(String role); &#125; 12345678910@Service@Profile(\"dev\")public class DevAuthorityServiceImpl implements AuthorityService &#123; @Override public boolean hasRole(String role) &#123; return true; &#125; &#125; 12345678910@Service@Profile(\"prod\")public class ProdAuthorityServiceImpl implements AuthorityService &#123; @Override public boolean hasRole(String role) &#123; return role == \"admin\"; &#125; &#125; 1.1 设置默认的 profiles在@Profile注解中，可以通过使用关键字default将当前的配置设置为默认的 profiles。Spring Boot 在启动时默认就会来加载此 profiles 配置。 12345678910@Service@Profile(&#123;\"dev\", \"default\"&#125;)public class DevAuthorityServiceImpl implements AuthorityService &#123; @Override public boolean hasRole(String role) &#123; return true; &#125; &#125; 2. 使用属性配置文件创建 profiles我们可以按照约定，将项目的配置文件以application-{profile}.{properties|yml}的方式命名来创建 profiles 配置。 application-test.properties 配置： 1custom.env = test-env application-prod.properties 配置： 1custom.env = prod-env 而在*.yml配置文件中，我们可以通过使用---分隔符在同一个文件创建多个 profile 配置： 123456789spring: profiles: testcustom: env: test-env---spring: profiles: prodcustom: env: prod-env 3. 激活 profiles当我们配置了多组不同的 profiles 后，我们可以非常灵活的有选择性的激活它们，而那些未被激活的 profiles 配置，则不会被加载。 3.1 通过配置文件激活application.properties 配置示例： 1spring.profiles.active = dev, test application.yml 配置示例： 12345spring: profiles: active: - dev - test 3.2 通过命令行激活终端在启动 Spring Boot 应用的时候可以使用-Dspring.profiles.active参数激活 profiles 配置。 1$ java -jar -Dspring.profiles.active=\"dev, test\" xxxx.jar 3.3 通过 @ActiveProfiles 注解激活这种方式仅适用于单元测试，@ActiveProfiles是由spring-test提供的。 1234567891011@RunWith(SpringRunner.class)@SpringBootTest@ActiveProfiles(&#123;\"dev\", \"test\"&#125;)public class ApplicationTest &#123; @Test public void testProfiles() &#123; &#125; &#125; 3.4 通过 setAdditionalProfiles 激活在 Spring Boot 启动类中，可以通过调用SpringApplication.setAdditionalProfiles(...)来激活一组 profiles 配置。 12345678910@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication application = new SpringApplication(Application.class); application.setAdditionalProfiles(\"dev\", \"test\"); application.run(args); &#125; &#125; 3.5 通过 setActiveProfiles 激活在 Spring Boot 启动类中，可以通过调用ConfigurableEnvironment.setActiveProfiles(...)来激活一组 profiles 配置。 123456789101112@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication application = new SpringApplication(Application.class); ConfigurableEnvironment environment = new StandardEnvironment(); environment.setActiveProfiles(\"dev\", \"test\"); application.setEnvironment(environment); application.run(args); &#125; &#125; 4. 组合 profiles 配置使用spring.profiles.include属性可以将多个不同的 profiles 有效的组合到一起： 1234567891011121314151617181920spring: profiles: active: dev-test---spring: profiles: testcustom: env: test-env---spring: profiles: prodcustom: env: prod-env---spring.profiles: dev-testspring: profiles: include: - dev - test 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-profiles-sample参考文档文献链接：spring-boot-features-profiles","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot 属性文件配置","date":"2017-04-16T05:24:40.000Z","path":"post/spring-boot-properties.html","text":"Spring Boot 允许我们通过*.properties文件、*.yml文件、环境变量、命令行参数等来外部化应用程序的配置，以便我们在不同的环境可以使用同一套程序代码。 1. 配置加载优先级Spring Boot 加载配置文件的优先级从高到低的搜索顺序为： 注解@TestPropertySource设置的属性文件 注解@SpringBootTest#properties设置的属性文件 命令行参数 ServletConfig 初始化参数 ServletContext 初始化参数 来自java:comp/env的 JNDI 属性 Java 系统属性（通过System.getProperties()能获取到的） 操作系统环境变量 含有random.*值的属性 Jar 包外部的application-{profile}.{properties|yml} Jar 包内部的application-{profile}.{properties|yml} Jar 包外部的application.{properties|yml} Jar 包内部的application.{properties|yml} 注解@PropertySource设置的属性文件 启动类SpringApplication.setDefaultProperties设置的默认属性 Spring Boot 搜索 Jar 包外部的application.{properties|yml}文件时，它优先搜索类路径下的/config目录，如果没有，再到类路径的根目录下搜索。 你可以参考源码： spring-configuration-metadata.json#spring.config.location spring-configuration-metadata.json#spring.config.name org.springframework.boot.context.config.ConfigFileApplicationListener 2. 配置文件配置Spring Boot 允许我们通过*.properties文件、*.yml文件来外部化应用程序的配置，我们只需要在类路径下创建application.{properties|yml}文件。 2.1 properties 配置文件相信大家对*.properties文件都并不陌生，这里就不多说了，看下面的示例： 12email-name = fanlychieemail-from = fanlychie@yeah.net 2.2 yaml 配置文件YAML 是一种专门用来编写配置文件（*.yml）的语言，它的语法简洁，也方便人们阅读。在部分 IDE 开发工具（如 IntelliJ IDEA）中还有代码提示，让人爱不释手。 123456789101112131415# 自定义属性data-structure: # 简单键值对 key-value: YAML Sample # 数组 array: value1, value2, value3 # List 集合 list: - value1 - value2 - value3 # Map 散列表 map: name: fanlychie email: fanlychie@yeah.net 3. 属性占位符在配置文件中，我们可以使用${var}语法引用已经定义的属性的值。 application.properties 配置示例： 12app.name = Spring Boot Properties Sampleapp.description = $&#123;app.name&#125; For My Github's Blog application.yml 配置示例： 123app: name: Spring Boot Properties Sample description: $&#123;app.name&#125; For My Github's Blog 我们还可以使用${var :defalutValue}语法来设置默认的值，如果var不存在, 则使用默认的值。 12app.name = Spring Boot Properties Sampleapp.description = $&#123;app.name :YourName&#125; For My Github's Blog application.yml 配置示例： 123app: name: Spring Boot Properties Sample description: $&#123;app.name :YourName&#125; For My Github's Blog 4. 绑定属性Spring Boot 对*.properties和*.yml配置文件中配置的属性名称提供了松绑定，它不要求配置的属性名称完全与 Bean 中的属性名称一致。它支持以下几种规格的命名方式： 属性 描述 firstName 标准的驼峰式命名 first-name 单词之间通过‘-‘分隔，Spring Boot 推荐这种 first_name 单词之间通过‘_’分隔 FIRST_NAME 单词全部大写并通过‘_’分隔，在使用系统环境变量时，推荐这种 4.1 通过 @Value 注解绑定application.yml 配置示例： 12email-name: fanlychieemail-from: fanlychie@yeah.net 通过使用@Value(&quot;${属性名称}&quot;)注解可以将属性的值注入到 Bean 对象的属性中： 123456789101112@Componentpublic class EmailValueConfig &#123; @Value(\"$&#123;email-name&#125;\") private String emailName; @Value(\"$&#123;email-from&#125;\") private String emailFrom; // getters &#125; 4.2 通过 @ConfigurationProperties 注解绑定通过使用@ConfigurationProperties注解可以将属性值绑定到结构化的对象中： 1234567891011@Component@ConfigurationPropertiespublic class EmailConfig &#123; private String emailName; private String emailFrom; // getters and setters &#125; 使用@ConfigurationProperties(&quot;前缀限定名&quot;)可以将*.*的属性绑定到 Bean 中。 application.yml 配置示例： 123app: name: Spring Boot Properties Sample description: $&#123;app.name&#125; For My Github's Blog 通过@ConfigurationProperties(&quot;app&quot;)绑定app.*属性： 1234567891011@Component@ConfigurationProperties(\"app\")public class AppConfig &#123; private String name; private String description; // getters and setters &#125; 4.3 复杂的属性绑定application.properties 配置示例： 1234567891011121314151617181920layout.desc = 布局配置layout.moudles[0].desc = 顶部模块layout.moudles[0].width = 100%layout.moudles[0].height = 200pxlayout.moudles[1].desc = 主区域模块layout.moudles[1].width = 80%layout.moudles[1].height = autolayout.moudles[2].desc = 脚部模块layout.moudles[2].width = 100%layout.moudles[2].height = 300pxlayout.background-rgb = 97, 96, 96, 1layout.tag-cloud-random-colors[0] = redlayout.tag-cloud-random-colors[1] = bluelayout.tag-cloud-random-colors[2] = greenlayout.tag-cloud-random-colors[3] = yellowlayout.moudle-color-mapping.top = whitelayout.moudle-color-mapping.main = graylayout.moudle-color-mapping.bottom = pinklayout.author.name = fanlychielayout.author.mail = fanlychie@yeah.net application.yml 配置示例： 12345678910111213141516171819202122232425layout: desc: 布局配置 moudles: - desc: 顶部模块 width: 100% height: 200px - desc: 主区域模块 width: 80% height: auto - desc: 脚部模块 width: 100% height: 300px background-rgb: 97, 96, 96, 1 tag-cloud-random-colors: - red - blue - green - yellow moudle-color-mapping: top: white main: gray bottom: pink author: name: fanlychie mail: fanlychie@yeah.net 1234567891011121314151617181920212223242526272829303132333435363738394041@Component@ConfigurationProperties(\"layout\")public class LayoutConfig &#123; private String desc; private List&lt;Moudle&gt; moudles; private int[] backgroundRgb; private List&lt;String&gt; tagCloudRandomColors; private Map&lt;String, String&gt; moudleColorMapping; private Author author; public static class Moudle &#123; private String width; private String height; private String desc; // getters and setters &#125; public static class Author &#123; private String name; private String mail; // getters and setters &#125; // getters and setters &#125; 4.4 对绑定的属性进行验证在@ConfigurationProperties注解标注的类中，你可以直接使用JSR-303相关的约束注解对绑定的属性值进行验证： 1234567891011121314151617181920import org.hibernate.validator.constraints.Length;import org.hibernate.validator.constraints.NotBlank;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import javax.validation.constraints.NotNull; @Component@ConfigurationProperties(\"app\")public class AppWithJSR303Config &#123; @NotNull private String name; @NotBlank @Length(min = 1, max = 100) private String description; // getters and setters &#125; 5. 配置随机值Spring Boot 内部提供了一个random.*属性，专门用于生成随机种子。 属性 描述 random.int 随机产生正负的整数 random.int(max) 随机产生 [0, max) 区间的整数 random.int(min,max) 随机产生 [min, max) 区间的整数 random.long 随机产生正负的长整数 random.long(max) 随机产生 [0, max) 区间的长整数 random.long(min,max) 随机产生 [min, max) 区间的长整数 random.uuid 产生 UUID 字符串（含‘-‘字符） random.* ‘*’表示除上面列举之外的其他字符，用于随机产生 32 位字符串 你可以翻阅源代码：org.springframework.boot.context.config.RandomValuePropertySource application.properties 配置示例： 123456random-seed.random-int-value=$&#123;random.int&#125;random-seed.random-int-range-value=$&#123;random.int(2)&#125;random-seed.random-long-value=$&#123;random.long&#125;random-seed.random-long-range-value=$&#123;random.long(1,3)&#125;random-seed.random-uuid-value=$&#123;random.uuid&#125;random-seed.random-str-value=$&#123;random.whatever&#125; application.yml 配置示例： 1234567random-seed: random-int-value: $&#123;random.int&#125; random-int-range-value: $&#123;random.int(2)&#125; random-long-value: $&#123;random.long&#125; random-long-range-value: $&#123;random.long(1,3)&#125; random-uuid-value: $&#123;random.uuid&#125; random-str-value: $&#123;random.whatever&#125; 12345678910111213141516171819@Component@ConfigurationProperties(\"random-seed\")public class RandomSeedConfig &#123; private int randomIntValue; private int randomIntRangeValue; private long randomLongValue; private long randomLongRangeValue; private String randomUuidValue; private String randomStrValue; // getters and setters &#125; 6. @PropertySource使用@PropertySource注解可以声明当前所使用的具体属性文件： 123456789101112@Component@PropertySource(\"jdbc.properties\")@ConfigurationProperties(\"jdbc\")public class JdbcConfig &#123; private String username; private String password; // getters and setters &#125; src/main/resources/jdbc.properties配置示例： 12jdbc.username = rootjdbc.password = root@123321 7. 命令行参数123456789@Componentpublic class CommandLineConfig &#123; @Value(\"$&#123;command-line-arg&#125;\") private String commandLineArg; // getters and setters &#125; 在命令行中，通过-D参数名称=参数的值进行配置： 1$ java -jar -Dcommand-line-arg=\"今天天气不错\" spring-boot-properties-sample-0.0.1-SNAPSHOT.jar 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-properties-sample参考文档文献链接：spring-boot-features-profiles","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Thymeleaf 教程","date":"2017-04-03T18:32:29.000Z","path":"post/thymeleaf.html","text":"Thymeleaf 是一个服务器端 Java 模板引擎，能够处理 HTML、XML、CSS、JAVASCRIPT 等模板文件。Thymeleaf 模板可以直接当作静态原型来使用，它主要目标是为开发者的开发工作流程带来优雅的自然模板，也是 Java 服务器端 HTML5 开发的理想选择。 1. 创建模板文件创建一个 HTML 模板文件： 12345678910&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;Index Page&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;p th:text=\"$&#123;message&#125;\"&gt;Welcome to BeiJing!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 通过&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;引入 Thymeleaf 命名空间。th:text用于处理p标签体的文本内容。该模板文件直接在任何浏览器中正确显示，浏览器会自动忽略它们不能理解的属性th:text。但这不是一个真正有效的 HTML5 文档，因为 HTML5 规范是不允许使用th:*这些非标准属性的。我们可以切换到 Thymeleaf 的data-th-*语法，以此来替换th:*语法： 12345678910&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;Index Page&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;p data-th-text=\"$&#123;message&#125;\"&gt;Welcome to BeiJing!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTML5 规范是允许data-*这样自定义的属性的。th:*和data-th-*这两个符号是完全等效且可以互换的。但为了简单直观和代码的紧凑性，本文采用th:*的表示形式。 2. 标准表达式语法Thymeleaf 提供了非常丰富的标准表达式语法，总共有 8 大类： 简单表达式 字面值 文本操作 算术运算 布尔运算 比较和相等 条件运算 无操作符 2.1 简单表达式 语法 名称 描述 作用 ${…} Variable Expressions 变量表达式 取出上下文变量的值 *{…} Selection Variable Expressions 选择变量表达式 取出选择的对象的属性值 #{…} Message Expressions 消息表达式 使文字消息国际化，I18N @{…} Link URL Expressions 链接表达式 用于表示各种超链接地址 ~{…} Fragment Expressions 片段表达式 引用一段公共的代码片段 2.1.1 ${…}1234567@GetMapping(\"/standard-expression-syntax/variables\")public String variables(ModelMap model, HttpSession session) &#123; model.put(\"now\", new Date()); model.put(\"message\", \"Welcome to BeiJing!\"); session.setAttribute(\"user\", new User(\"fanlychie\", \"男\", 24)); ... ...&#125; 通过变量表达式${}取出上下文环境中的message变量： 12&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=\"$&#123;message&#125;\"&gt;&lt;/p&gt; 它相当于： 1ctx.getVariable(\"message\"); 2.1.2 *{…}变量表达式${}是面向整个上下文的，而选择变量表达式*{}的上下文是父标签（th:object）所选择的对象： 12345&lt;div th:object=\"$&#123;session.user&#125;\"&gt; &lt;p th:text=\"*&#123;name&#125;\"&gt;&lt;/p&gt; &lt;p th:text=\"*&#123;sex&#125;\"&gt;&lt;/p&gt; &lt;p th:text=\"*&#123;age&#125;\"&gt;&lt;/p&gt;&lt;/div&gt; 它相当于： 12345&lt;div&gt; &lt;p th:text=\"$&#123;session.user.name&#125;\"&gt;&lt;/p&gt; &lt;p th:text=\"$&#123;session.user.sex&#125;\"&gt;&lt;/p&gt; &lt;p th:text=\"$&#123;session.user.age&#125;\"&gt;&lt;/p&gt;&lt;/div&gt; 如果对象没有被选择，那么，*{}和${}表达式所达到的效果是完全相同的： 12&lt;p th:text=\"*&#123;session.user.name&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;session.user.name&#125;\"&gt;&lt;/p&gt; 2.1.3 #{…}消息表达式可用于国际化文字信息。首先我们来了解一下 i18n 资源文件的命名规则： basename.properties basename_language.properties basename_language_country.properties basename是自定义的资源文件名称，language和country必须是 Java 支持的语言和国家。basename.properties是缺省加载的资源文件，当客户端根据本地语言查找不到相关的资源文件时，则使用该配置文件。 创建文件src/main/resources/messages.properties 1welcome.message = 北京欢迎你！ 创建文件src/main/resources/messages_en_US.properties 1welcome.message = Welcome to BeiJing! 在 IntelliJ IDEA 编辑视图： messages是 Spring Boot 加载资源文件默认采用的名称（basename），如果你所使用的资源文件名称不是以messages命名或所使用的资源文件不是在src/main/resources根目录，你可以通过spring.messages.basename属性来做具体的配置。如，资源文件messages.properties和messages_en_US.properties假设它们所在的目录位置是src/main/resources/i18n。 application.properties 配置示例： 1spring.messages.basename:i18n/messages application.yml 配置示例： 123spring messages basename: i18n/messages 静态文本消息示例： 12&lt;!-- 北京欢迎你！ --&gt;&lt;p th:text=\"#&#123;welcom.message&#125;\"&gt;&lt;/p&gt; 消息表达式#{}是不允许直接处理非静态的文本消息的，但是你可以在资源文件中通过使用占位符{}来处理非静态的文本消息： messages.properties 配置示例： 1welcome.user.message = &#123;0&#125;, 北京欢迎你！ messages_en_US.properties 配置示例： 1welcome.user.message = &#123;0&#125;, Welcome to BeiJing! 非静态文本消息，以参数的形式传递变量的值： 12&lt;!-- fanlychie, 北京欢迎你！ --&gt;&lt;p th:text=\"#&#123;welcome.user.message($&#123;session.user.name&#125;)&#125;\"&gt;&lt;/p&gt; 2.1.4 @{…}链接表达式@{}是专门用来处理 URL 链接地址的。 绝对地址示例： 12&lt;!-- http://fanlychie.github.io --&gt;&lt;p th:text=\"@&#123;http://fanlychie.github.io&#125;\"&gt;&lt;/p&gt; 页面相对地址示例： 12&lt;!-- commons/base.html --&gt;&lt;p th:text=\"@&#123;commons/base.html&#125;\"&gt;&lt;/p&gt; 上下文相对地址（相对于当前的服务）示例： 12&lt;!-- /css/mian.css --&gt;&lt;p th:text=\"@&#123;/css/mian.css&#125;\"&gt;&lt;/p&gt; 服务器相对地址（相对于部署在同一个服务器中的不同服务）示例： 12&lt;!-- /image/upload --&gt;&lt;p th:text=\"@&#123;~/image/upload&#125;\"&gt;&lt;/p&gt; 参数使用示例： 12345678&lt;!-- /css/mian.css?v=1.0 --&gt;&lt;p th:text=\"@&#123;/css/mian.css(v=1.0)&#125;\"&gt;&lt;/p&gt;&lt;!-- /user/order?username=fanlychie --&gt;&lt;p th:text=\"@&#123;/user/order(username=$&#123;session.user.name&#125;)&#125;\"&gt;&lt;/p&gt;&lt;!-- /user/order?username=fanlychie&amp;status=PAIED --&gt;&lt;p th:text=\"@&#123;/user/order(username=$&#123;session.user.name&#125;,status='PAIED')&#125;\"&gt;&lt;/p&gt;&lt;!-- /user/fanlychie/info --&gt;&lt;p th:text=\"@&#123;/user/&#123;username&#125;/info(username=$&#123;session.user.name&#125;)&#125;\"&gt;&lt;/p&gt; 2.1.5 ~{…}片段表达式~{}可以用来引用一段公共的 HTML 代码片段。 语法 描述 ~{templatename} 引用整个模板文件的代码片段 ~{templatename :: selector} selector 可以是 th:fragment 指定的名称或其他选择器。如类选择器、ID选择器等 ~{::selector} 相当于 ~{this :: selector}，表示引用当前模板定义的代码片段 在 Thymeleaf 模板文件中，你可以使用th:fragment属性来定义一段公共的代码片段，然后你可以通过使用th:insert、th:replace、th:include（Thymeleaf 3.0 开始不再推荐使用，本文也将不再介绍它）属性来将这些公共的代码片段引入到模板文件中来。 src/main/resources/templates/base.html，通过th:fragment属性定义一段公共的代码片段： 1&lt;div id=\"footer\" th:fragment=\"footerFragment\"&gt;&amp;copy; 2017 fanlychie&lt;/div&gt; src/main/resources/templates/index.html，通过th:insert属性引用一段公共的代码片段： 1&lt;div th:insert=\"~&#123;base :: footerFragment&#125;\"&gt;&lt;/div&gt; 其中，~{}是可选的，我们可以去掉这层的包裹： 1&lt;div th:insert=\"base :: footerFragment\"&gt;&lt;/div&gt; 若 index.html 与 base.html 不在同级目录，如 templates/commons/base.html： 1&lt;div th:insert=\"~&#123;commons/base :: footerFragment&#125;\"&gt;&lt;/div&gt; 使用th:fragment属性定义代码片段时，你还可以声明一组参数： 123456789&lt;div th:fragment=\"crumbs(parent, child)\"&gt; &lt;i th:text=\"$&#123;parent&#125;\"&gt;&lt;/i&gt; &lt;i th:text=\"$&#123;child&#125;\"&gt;&lt;/i&gt;&lt;/div&gt; &lt;!--&lt;i&gt;用户中心&lt;/i&gt;&lt;i&gt;我的订单&lt;/i&gt;--&gt;&lt;div th:insert=\"::crumbs('用户中心', '我的订单')\"&gt;&lt;/div&gt; 此外，我们还可以通过类选择器、ID选择器等来引用公共的代码片段： 1&lt;div th:insert=\"~&#123;base :: #footer&#125;\"&gt;&lt;/div&gt; 除了th:insert属性th:replace也可以用来引用公共的代码片段。不同的是，th:insert是直接将代码片段插入到标签体内，而th:replace则是用代码片段直接替换标签体内容。 1234567891011&lt;!--&lt;div&gt; &lt;div id=\"footer\"&gt;© 2017 fanlychie&lt;/div&gt;&lt;/div&gt;--&gt;&lt;div th:insert=\"~&#123;base :: footerFragment&#125;\"&gt;&lt;/div&gt; &lt;!--&lt;div id=\"footer\"&gt;© 2017 fanlychie&lt;/div&gt;--&gt;&lt;div th:replace=\"~&#123;base :: footerFragment&#125;\"&gt;&lt;/div&gt; 2.1.6 内置对象 对象 描述 #ctx 上下文对象 #vars 同 #ctx，表示上下文变量 #locale 上下文本地化（特定的地理区域）变量，可参考 java.util.Locale #request HttpServletRequest 对象，可参考 javax.servlet.http.HttpServletRequest #response HttpServletResponse 对象，可参考 javax.servlet.http.HttpServletResponse #session HttpSession 对象，可参考 javax.servlet.http.HttpSession #servletContext ServletContext 对象，可参考 javax.servlet.ServletContext #ctx示例： 123456&lt;!-- zh_CN --&gt;&lt;p th:text=\"$&#123;#ctx.getLocale()&#125;\"&gt;&lt;/p&gt;&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=\"$&#123;#ctx.getVariable('message')&#125;\"&gt;&lt;/p&gt;&lt;!-- true --&gt;&lt;p th:text=\"$&#123;#ctx.containsVariable('message')&#125;\"&gt;&lt;/p&gt; #vars示例： 123456&lt;!-- zh_CN --&gt;&lt;p th:text=\"$&#123;#vars.getLocale()&#125;\"&gt;&lt;/p&gt;&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=\"$&#123;#vars.getVariable('message')&#125;\"&gt;&lt;/p&gt;&lt;!-- true --&gt;&lt;p th:text=\"$&#123;#vars.containsVariable('message')&#125;\"&gt;&lt;/p&gt; #locale示例： 123456789101112&lt;!-- zh_CN --&gt;&lt;p th:text=\"$&#123;#locale&#125;\"&gt;&lt;/p&gt;&lt;!-- CN --&gt;&lt;p th:text=\"$&#123;#locale.country&#125;\"&gt;&lt;/p&gt;&lt;!-- 中国 --&gt;&lt;p th:text=\"$&#123;#locale.displayCountry&#125;\"&gt;&lt;/p&gt;&lt;!-- zh --&gt;&lt;p th:text=\"$&#123;#locale.language&#125;\"&gt;&lt;/p&gt;&lt;!-- 中文 --&gt;&lt;p th:text=\"$&#123;#locale.displayLanguage&#125;\"&gt;&lt;/p&gt;&lt;!-- 中文 (中国) --&gt;&lt;p th:text=\"$&#123;#locale.displayName&#125;\"&gt;&lt;/p&gt; #request示例： 12345678910111213141516171819202122&lt;!-- HTTP/1.1 --&gt;&lt;p th:text=\"$&#123;#request.protocol&#125;\"&gt;&lt;/p&gt;&lt;!-- http --&gt;&lt;p th:text=\"$&#123;#request.scheme&#125;\"&gt;&lt;/p&gt;&lt;!-- localhost --&gt;&lt;p th:text=\"$&#123;#request.serverName&#125;\"&gt;&lt;/p&gt;&lt;!-- 8080 --&gt;&lt;p th:text=\"$&#123;#request.serverPort&#125;\"&gt;&lt;/p&gt;&lt;!-- GET --&gt;&lt;p th:text=\"$&#123;#request.method&#125;\"&gt;&lt;/p&gt;&lt;!-- /standard-expression-syntax/variables --&gt;&lt;p th:text=\"$&#123;#request.requestURI&#125;\"&gt;&lt;/p&gt;&lt;!-- http://localhost:8080/standard-expression-syntax/variables --&gt;&lt;p th:text=\"$&#123;#request.requestURL&#125;\"&gt;&lt;/p&gt;&lt;!-- /standard-expression-syntax/variables --&gt;&lt;p th:text=\"$&#123;#request.servletPath&#125;\"&gt;&lt;/p&gt;&lt;!-- java.util.Collections$3@203646fe --&gt;&lt;p th:text=\"$&#123;#request.parameterNames&#125;\"&gt;&lt;/p&gt;&lt;!-- &#123;q=[Ljava.lang.String;@3308c69f&#125; --&gt;&lt;p th:text=\"$&#123;#request.parameterMap&#125;\"&gt;&lt;/p&gt;&lt;!-- q=expression --&gt;&lt;p th:text=\"$&#123;#request.queryString&#125;\"&gt;&lt;/p&gt; 注意，请求地址的 URL 参数直接通过#request.x是取不出来的，需要使用param.x语法来取出。如，URL：/standard-expression-syntax/variables?q=expression，取出 q 参数的正确姿势： 1&lt;p th:text=\"$&#123;param.q&#125;\"&gt;&lt;/p&gt; #response示例： 12345678&lt;!-- 200 --&gt;&lt;p th:text=\"$&#123;#response.status&#125;\"&gt;&lt;/p&gt;&lt;!-- 8192 --&gt;&lt;p th:text=\"$&#123;#response.bufferSize&#125;\"&gt;&lt;/p&gt;&lt;!-- UTF-8 --&gt;&lt;p th:text=\"$&#123;#response.characterEncoding&#125;\"&gt;&lt;/p&gt;&lt;!-- text/html;charset=UTF-8 --&gt;&lt;p th:text=\"$&#123;#response.contentType&#125;\"&gt;&lt;/p&gt; #session示例： 123456&lt;!-- 2BCB2A0EACFF2D9D249D9799431B5127 --&gt;&lt;p th:text=\"$&#123;#session.id&#125;\"&gt;&lt;/p&gt;&lt;!-- 1499786693244 --&gt;&lt;p th:text=\"$&#123;#session.lastAccessedTime&#125;\"&gt;&lt;/p&gt;&lt;!-- fanlychie --&gt;&lt;p th:text=\"$&#123;#session.getAttribute('user').name&#125;\"&gt;&lt;/p&gt; 注意，放到会话里面的对象直接通过#session.x是取不出来的，需要使用session.x语法来取出。如，取出会话里面的 user 对象的正确姿势： 1&lt;p th:text=\"$&#123;session.user.name&#125;\"&gt;&lt;/p&gt; 2.1.7 工具类 对象 描述 #messages 消息工具类，与 ＃{…} 作用相同 #uris 地址相关的工具类 #conversions 对象转换工具类 #dates 日期时间工具类 #calendars 日历工具类 #numbers 数字工具类 #strings 字符串工具类 #objects 对象工具类 #bools 布尔工具类 #arrays 数组工具类 #lists List 工具类 #sets Set 工具类 #maps Map 工具类 1234&lt;!-- false --&gt;&lt;p th:text=\"$&#123;#strings.isEmpty(message)&#125;\"&gt;&lt;/p&gt;&lt;!-- 2017-07-12 00:37:25 --&gt;&lt;p th:text=\"$&#123;#dates.format(now, 'yyyy-MM-dd HH:mm:ss')&#125;\"&gt;&lt;/p&gt; 2.2 字面值所谓字面值，首先它不是一个变量，它是一个具体的确切的值，通常这些值是比较简单的，例如：18、&#39;welcome&#39;等，它们没有名称，以至于我们只能用值来称呼它们，因此我们称其为字面值。 2.2.1 文字字面值文字字面值是用单引号引起来的任何字符内容，如果字符内容里面含有单引号，则需要进行转义： 1234&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=\"'Welcome to BeiJing!'\"&gt;&lt;/p&gt;&lt;!-- 'Welcome to BeiJing!' --&gt;&lt;p th:text=\"'\\'Welcome to BeiJing!\\''\"&gt;&lt;/p&gt; 2.2.2 数字字面值1234&lt;!-- 2017 --&gt;&lt;p th:text=\"2017\"&gt;&lt;/p&gt;&lt;!-- 2018 --&gt;&lt;p th:text=\"2017 + 1\"&gt;&lt;/p&gt; 2.2.3 布尔字面值1234&lt;!-- false --&gt;&lt;p th:text=\"1 &gt; 2\"&gt;&lt;/p&gt;&lt;!-- 否 --&gt;&lt;p th:text=\"1 &gt; 2 ? '是' : '否'\"&gt;&lt;/p&gt; 2.2.4 空字面值12&lt;!-- false --&gt;&lt;p th:text=\"$&#123;user == null&#125;\"&gt;&lt;/p&gt; 2.2.5 字面令牌字面令牌（Literal Tokens）的内容只能含有（不能含有空格、特殊符号等）： 大写或小写的字母、中文等不含空格和特殊符号的文本 0 到 9 的数字 中括号 下划线 连字符（-） 点符号（.） 实际上，数字、布尔和空字面值都是字面令牌的特殊情况。字面令牌能够用来对标准表达式语法进行简化，我们可以将包裹它的内容的单引号去掉： 1&lt;p th:text=\"Welcome to BeiJing!\"&gt;&lt;/p&gt; 它等效于： 1&lt;p th:text=\"'Welcome to BeiJing!'\"&gt;&lt;/p&gt; 2.3 文本操作我们可以对文本内容进行两种常用的操作，它们分别为字符串连接和字符串替换。 2.3.1 字符串连接不管是字面值还是表达式的结果，我们都可以使用+符号将它们连接起来： 12&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=\"'Welcome to ' + $&#123;location&#125; + '!'\"&gt;&lt;/p&gt; 2.3.2 字面值替换符号||可以用来将字面值和表达式包裹起来，这样就能方便的替换变量的值，而不需要使用+连接符： 12&lt;!-- Welcome to BeiJing! --&gt;&lt;p th:text=\"|Welcome to $&#123;location&#125;!|\"&gt;&lt;/p&gt; 2.4 算术运算支持+（加）、-（减）、*（乘）、/（除）、%（模）运算： 1234567891011121314&lt;!-- 6 --&gt;&lt;p th:text=\"4 + 2\"&gt;&lt;/p&gt;&lt;!-- 2 --&gt;&lt;p th:text=\"4 - 2\"&gt;&lt;/p&gt;&lt;!-- 8 --&gt;&lt;p th:text=\"4 * 2\"&gt;&lt;/p&gt;&lt;!-- 2 --&gt;&lt;p th:text=\"4 / 2\"&gt;&lt;/p&gt;&lt;!-- 0 --&gt;&lt;p th:text=\"4 % 2\"&gt;&lt;/p&gt;&lt;!-- 2 --&gt;&lt;p th:text=\"$&#123;pagination.page + 1&#125;\"&gt;&lt;/p&gt;&lt;!-- 2 --&gt;&lt;p th:text=\"$&#123;pagination.page&#125; + 1\"&gt;&lt;/p&gt; 2.5 布尔运算支持and（且）、or（或）、!（非）、not（非）运算： 1234&lt;p th:text=\"$&#123;user.online and user.vip&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.online or user.vip&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;!user.online&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;not user.online&#125;\"&gt;&lt;/p&gt; 2.6 比较和相等支持&lt;（lt）、&gt;（gt）、&lt;=（le）、&gt;=（ge）、==（eq）、！=（ne）： 123456&lt;p th:text=\"$&#123;user.age &lt; 60&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.age &lt;= 60&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.age &gt; 18&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.age &gt;= 18&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.age == 18&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.age != 18&#125;\"&gt;&lt;/p&gt; 2.7 条件运算三元运算符：(if) ? (then) : (else) 12&lt;p th:text=\"$&#123;user.online ? '在线' : '离线'&#125;\"&gt;&lt;/p&gt;&lt;p th:text=\"$&#123;user.online ? (user.vip ? 'VIP用户在线' : '普通用户在线') : '离线'&#125;\"&gt;&lt;/p&gt; 二元运算符：(value) ?: (defaultValue)。 其中，value非空（null）即真，条件为真时输出value，否则输出defaultValue。假设token = null，user.email = fanlychie@gmail.com 1234&lt;!-- 你还没有登录，请先登录 --&gt;&lt;p th:text=\"$&#123;token&#125; ?: '你还没有登录，请先登录'\"&gt;&lt;/p&gt;&lt;!-- fanlychie@gmail.com --&gt;&lt;p th:text=\"$&#123;user.email&#125; ?: '你还没有绑定邮箱'\"&gt;&lt;/p&gt; 2.8 无操作符当模板运行在服务器端时，Thymeleaf 会解析th:*属性的具体值替换标签体的内容。无操作符（_）则允许你使用原型标签体的内容作为默认值： 12&lt;!-- 你还没有登录，请先登录 --&gt;&lt;p th:text=\"$&#123;token&#125; ?: _\"&gt;你还没有登录，请先登录&lt;/p&gt; 3. 使用文本首先介绍两个最基础的th:*属th:text和th:utext，它们都是用于处理文本消息内容。 3.1 th:text在标签体中展示表达式评估结果的文本内容： 1&lt;p th:text=\"$&#123;message&#125;\"&gt;&lt;/p&gt; 使用外部化的文本内容： 1&lt;p th:text=\"$&#123;message&#125;\"&gt;Welcome to BeiJing!&lt;/p&gt; 当它作为静态文件直接运行时，浏览器会自动忽略它不能识别的th:text属性，而显示&lt;p&gt;标签体的文本内容Welcome to BeiJing! 当它作为模板文件运行在服务器端时，th:text属性的具体值将会替换&lt;p&gt;标签体的文本内容。 3.2 th:utext属性th:utext与th:text的区别在于： th:text默认会对含有 HTML 标签的内容进行字符转义； th:utext（Unescaped Text）则不会对含有 HTML 标签的内容进行字符转义； 假设：message = &quot;&lt;b&gt;Welcome to BeiJing!&lt;/b&gt;&quot;。 使用th:text属性： 1&lt;p th:text=\"$&#123;message&#125;\"&gt;&lt;/p&gt; th:text效果：&lt;b&gt;Welcome to BeiJing!&lt;/b&gt; 使用th:utext属性： 1&lt;p th:utext=\"$&#123;message&#125;\"&gt;&lt;/p&gt; th:utext效果：Welcome to BeiJing! 4. 设置属性值在 Thymeleaf 模板文件中，你可以使用th:*（或者使用th:attr属性）来设置任意的 HTML5 标签属性的值。不仅如此，你还可以th:*-*来同时为多个不同的标签属性设置相同的一个值，甚至你可以使用th:attrappend和th:attrprepend来追加新的值到现有的标签属性值中。 4.1 th:attr这种方式是不被推荐的，了解一下就行。下面是用th:attr=&quot;href=...&quot;来设置标签href属性的值： 1&lt;a th:attr=\"href=@&#123;https://www.google.com.hk&#125;\"&gt;谷歌一下你就知道&lt;/a&gt; 4.2 th:*显然th:attr=&quot;href=@{http://www.baidu.com}&quot;不够简洁，我们更推荐下面的这种语法： 1&lt;a th:href=\"@&#123;https://www.google.com.hk&#125;\"&gt;谷歌一下你就知道&lt;/a&gt; 其中th:*中的*可以是 HTML5 支持的任意属性名称，甚至这些属性名称可以是自定义的： 12&lt;!-- &lt;div item-id=\"1001\"&gt;Welcome to BeiJing!&lt;/div&gt; --&gt;&lt;div th:item-id=\"$&#123;user.id&#125;\"&gt;Welcome to BeiJing!&lt;/div&gt; 4.3 th:*-*如果想要同时为标签的多个不同属性设置相同的一个值，可以使用th:*-*的语法： 1&lt;img src=\"logo.png\" th:alt-title=\"LOGO图片\"&gt; 它相当于： 1&lt;img src=\"logo.png\" th:alt=\"LOGO图片\" th:title=\"LOGO图片\"&gt; 4.4 th:attrappend &amp; th:attrprependth:attrappend和th:attrprepend可以将表达式的结果分别追加到指定的属性值之后和之前。 1234&lt;!-- &lt;button class=\"btn enable\"&gt;购买&lt;/button&gt; --&gt;&lt;button class=\"btn\" th:attrappend=\"class=$&#123;outOfStock&#125; ? ' enable' : ' disable'\"&gt;购买&lt;/button&gt;&lt;!-- &lt;button class=\"enable btn\"&gt;购买&lt;/button&gt; --&gt;&lt;button class=\"btn\" th:attrprepend=\"class=$&#123;outOfStock&#125; ? 'enable ' : 'disable '\"&gt;购买&lt;/button&gt; 另外，还有两个常用的具体附加属性th:classappend=&quot;...&quot;和th:styleappend=&quot;&quot;。 它们分别用来代替th:attrappend=&quot;class=...&quot;和th:attrappend=&quot;style=...&quot;。 12&lt;!-- &lt;button class=\"btn enable\"&gt;购买&lt;/button&gt; --&gt;&lt;button class=\"btn\" th:classappend=\"$&#123;outOfStock&#125; ? ' enable' : ' disable'\"&gt;购买&lt;/button&gt; 4.5 布尔属性在 HTML 中有些属性是布尔属性，布尔属性是指没有值的属性，如readonly、checked、selected等。它们若存在那就意味着值为 true。 12345678910&lt;input type=\"checkbox\" name=\"rememberme\" checked /&gt; 记住我&lt;input type=\"radio\" name=\"sex\" value=\"male\" checked&gt; 男&lt;input type=\"radio\" name=\"sex\" value=\"female\"&gt; 女&lt;input type=\"text\" name=\"appId\" value=\"J123654\" readonly&gt;&lt;select&gt; &lt;option selected&gt;北京&lt;/option&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt; &lt;option&gt;深圳&lt;/option&gt;&lt;/select&gt; Thymeleaf 也允许我们通过th:*（这里的*表示任意的布尔属性） 来选择是否使用这些布尔属性。 1&lt;input type=\"checkbox\" name=\"rememberme\" ch:checked=\"$&#123;rememberme&#125;\" /&gt; 记住我 正如你所见，如果表达式的结果为true，则自动勾选复选框，若为false，则不会自动勾选。 5. 遍历遍历（迭代）的语法th:each=&quot;自定义的元素变量名称 : ${集合变量名称}&quot;： 123456&lt;div&gt; &lt;spn&gt;你所在城市：&lt;/spn&gt; &lt;select name=\"mycity\"&gt; &lt;option th:each=\"city : $&#123;cities&#125;\" th:text=\"$&#123;city.name&#125;\"&gt;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 属性th:each提供了一个用于跟踪迭代的状态变量，它包含以下几个属性： 属性 类型 描述 index int 当前迭代的索引，从 0 开始 count int 当前迭代的计数，从 1 开始 size int 集合中元素的总个数 current int 当前的元素对象 even boolean 当前迭代的计数是否是偶数 odd boolean 当前迭代的计数是否是奇数 first boolean 当前元素是否是集合的第一个元素 last boolean 当前元素是否是集合的最后一个元素 状态变量的使用语法：th:each=&quot;自定义的元素变量名称, 自定义的状态变量名称 : ${集合变量名称}&quot;： 123456&lt;div&gt; &lt;spn&gt;所在城市：&lt;/spn&gt; &lt;select name=\"mycity\"&gt; &lt;option th:each=\"city, status : $&#123;cities&#125;\" th:text=\"$&#123;city.name&#125;\" th:item-index=\"$&#123;status.count&#125;\"&gt;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 不管什么时候，Thymeleaf 始终会为每个th:each创建一个状态变量，默认的状态变量名称就是自定义的元素变量名称后面加Stat字符串组成： 123456&lt;div&gt; &lt;spn&gt;所在城市：&lt;/spn&gt; &lt;select name=\"mycity\"&gt; &lt;option th:each=\"city : $&#123;cities&#125;\" th:text=\"$&#123;city.name&#125;\" th:item-index=\"$&#123;cityStat.count&#125;\"&gt;&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 6. 条件判断条件判断语句有三种，分别是：th:if、th:unless、th:swith。 6.1 th:if当表达式的评估结果为真时则显示内容，否则不显示： 1&lt;a th:href=\"@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;\" th:if=\"$&#123;user != null&#125;\"&gt;我的订单&lt;/a&gt; 真假评估的依据： 当表达式的值不为空（null）时 如果表达式的值是一个布尔类型，且值为true评估为真，否则为假 如果表达式的值是一个数字类型，且值为非0评估为真，否则为假 如果表达式的值是一个字符类型，且值为非0评估为真，否则为假 如果表达式的值是一个字符串类型，且值为非&quot;false&quot;、&quot;off&quot;、&quot;no&quot;评估为真，否则为假 如果表达式的值不是一个布尔、数字、字符或字符串评估为真 当表达式的值为空（null）时，评估结果为假 因此，上面代码我们也可以简写成： 1&lt;a th:href=\"@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;\" th:if=\"$&#123;user&#125;\"&gt;我的订单&lt;/a&gt; 但是，为了代码的可读性，我们并不建议这样使用。 6.2 th:unlessth:unless与th:if判断恰好相反，当表达式的评估结果为假时则显示内容，否则不显示： 1&lt;a th:href=\"@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;\" th:unless=\"$&#123;user == null&#125;\"&gt;我的订单&lt;/a&gt; 6.3 th:swith多路选择语句，它需要搭配th:case来使用： 1234&lt;div th:switch=\"$&#123;user.role&#125;\"&gt; &lt;p th:case=\"admin\"&gt;管理员&lt;/p&gt; &lt;p th:case=\"user\"&gt;普通用户&lt;/p&gt;&lt;/div&gt; 7. 定义局部变量使用th:with属性可以定义局部变量： 123&lt;p th:with=\"name='fanlychie'\"&gt; &lt;span th:text=\"$&#123;name&#125;\"&gt;&lt;/span&gt;&lt;/p&gt; 同时定义多个局部变量时，用英文,号分隔开： 123&lt;p th:with=\"name=$&#123;user.name&#125;,age=&#123;user.age&#125;\"&gt; ......&lt;/p&gt; 8. 注释下面介绍常见的两种注释： 8.1 标准注释语法：&lt;!-- ... ---&gt;，注释的代码块会在文件源代码中显示出来。 8.1.1 单行注释1&lt;!-- &lt;span&gt;$&#123;message&#125;&lt;/span&gt; ---&gt; 8.1.2 多行注释123456&lt;!--&lt;div th:switch=\"$&#123;user.role&#125;\"&gt; &lt;p th:case=\"admin\"&gt;管理员&lt;/p&gt; &lt;p th:case=\"user\"&gt;普通用户&lt;/p&gt;&lt;/div&gt;---&gt; 8.2 解析器级注释语法：&lt;!--/* ... */--&gt;，注释的代码块会在引擎解析的时候抹去。 8.2.1 单行注释：1&lt;!--/* &lt;span&gt;$&#123;message&#125;&lt;/span&gt; */--&gt; 8.2.2 多行注释123456&lt;!--/*--&gt;&lt;div th:switch=\"$&#123;user.role&#125;\"&gt; &lt;p th:case=\"admin\"&gt;管理员&lt;/p&gt; &lt;p th:case=\"user\"&gt;普通用户&lt;/p&gt;&lt;/div&gt;&lt;!--*/--&gt; 9. 内联表达式内联表达式允许我们直接在 HTML 文本中使用标准表达式，而不需要使用th:*标签属性。 9.1 [[…]][[]]相当于th:text，对含有 HTML 标签的内容自动进行字符转义。 1&lt;p&gt;The message is : [[$&#123;htmlContent&#125;]]&lt;/p&gt; 9.2 [(…)][()]相当于th:utext，对含有 HTML 标签的内容不进行字符转义。 1&lt;p&gt;The message is : [($&#123;htmlContent&#125;)]&lt;/p&gt; 9.3 th:inline我们已经了解到，使用[[]]和[()]语法可以直接在 HTML 文本中使用标准表达式，如果想要使用更多高级的功能，需要使用th:inline属性来激活，它的取值如下： 值 描述 none 禁止内联表达式，可以原样输出 [[]] 和 [()] 字符串 text 文本内联，可以使用 th:each 等高级语法 css 样式内联，如：&lt;style th:inline=&quot;css&quot;&gt; javascript 脚本内联，如：&lt;style th:inline=&quot;javascript&quot;&gt; 9.3.1 none12&lt;!-- [[1, 2], [3, 4]] --&gt;&lt;p th:inline=\"none\"&gt;[[1, 2], [3, 4]]&lt;/p&gt; 9.3.2 text123456&lt;!-- 北京 上海 广州 深圳 --&gt;&lt;p th:inline=\"text\"&gt; [# th:each=\"city : $&#123;cities&#125;\"] [($&#123;city.name&#125;)] [/]&lt;/p&gt; 9.3.3 css12345&lt;style th:inline=\"css\"&gt; body &#123; background-color:[[$&#123;bgColor&#125;]]; &#125;&lt;/style&gt; 9.3.4 javascript1234&lt;script th:inline=\"javascript\"&gt; var user = [[$&#123;user&#125;]]; alert(\"用户名：\" + user.name);&lt;/script&gt; 参考文档文献链接：http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html","tags":[{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"http://yoursite.com/tags/Thymeleaf/"}]},{"title":"Spring Boot 添加 Thymeleaf 支持","date":"2017-04-03T06:44:53.000Z","path":"post/spring-boot-with-thymeleaf.html","text":"Spring Boot 对 Thymeleaf 模板引擎提供了自配置的良好支持。Spring Boot 1.5.2.RELEASE 版本默认使用的是 Thymeleaf 2.0+，本文使用 Thymeleaf 3.0+ 版本，在 pom.xml 中添加以下声明： 1234&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.5.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.1&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt; 然后添加 Thymeleaf 依赖声明： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 1. 控制器12345678910@Controllerpublic class WelcomeController &#123; @GetMapping(\"/\") public String welcome(ModelMap model) &#123; model.put(\"message\", \"Hello Thymeleaf!\"); return \"index\"; &#125; &#125; 2. 模板文件Spring Boot 对 Thymeleaf 模板引擎提供了自动配置的支持，详见 ThymeleafProperties。我们只需遵循约定，在/src/main/resources/templates/目录创建相应的页面模板文件（*.html）即可。 # src/main/resources/templates/index.html1234567891011&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" th:href=\"@&#123;/css/main.css&#125;\"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 th:text=\"$&#123;message&#125;\"&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 3. 静态文件Spring Boot 默认将静态资源文件映射到类路径下的目录包括（详见 ResourcesProperties）： /META-INF/resources/ /resources/ /static/ /public/ 因此我们可以将 css、js、images 等静态资源文件放在/src/main/resources/static/目录下。 # src/main/resources/static/css/main.css123456789body &#123; padding: 0; color: #444; width: 280px; margin: 100px auto; font-family: SimSun; background-color: #FBFBFB; text-shadow: rgba(50,50,50,0.3) 2px 2px 3px;&#125; 4. 主应用程序类12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 5. 模板文件和静态资源文件的缓存问题当修改 css、js 等静态资源文件的内容或模板文件的内容时，刷新客户端浏览器，发现内容还是老的，说明 Spring Boot 内置的 Servelt 容器并没有实时重新加载修改过的文件内容。你只能在每次修改静态资源文件时，虽然不需要重启服务，但是你要重新编译一次，IntelliJ IDEA 中按一次 Ctrl + F9 即可。实现热加载（live reload）可参考：解决 IntelliJ IDEA 无法热加载 Spring Boot 模板文件和静态资源文件 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-thymeleaf-sample参考文档文献链接：howto-use-thymeleaf-3、usingthymeleaf","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"解决 IntelliJ IDEA 无法热加载 Spring Boot 模板文件和静态资源文件","date":"2017-04-02T20:24:50.000Z","path":"post/resolve-intellij-idea-spring-boot-template-reload-is-not-working.html","text":"1. IntelliJ IDEA 配置快捷键Ctrl + Alt + S打开设置面板，勾选Build project automatically选项： 快捷键Ctrl + Shift + A查找registry命令： 在查找到的registry命令通过鼠标双击或敲回车键，在弹出的面板中搜索关键字automake，找到并勾选compiler.automake.allow.when.app.running选项： 配置完成后，IntelliJ IDEA 可以热加载静态资源文件了。但是模板文件仍然还不能热加载。 2. 添加 Spring Boot Dev Tools 支持在 pom.xml 中添加如下依赖声明： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; Spring Boot Dev Tools 的作用： 视图或资源的任何更改都可以直接在浏览器中看到，无需重新启动，只需刷新浏览器即可。 对代码的任何更改将自动重新启动 Spring 容器。 至此，就可以完美的解决 IntelliJ IDEA 无法热加载模板文件和静态资源文件的问题了。并且，当你修改或编写 Java 代码时，也是能够热加载的。","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot 添加 JSP 支持","date":"2017-04-02T14:13:29.000Z","path":"post/spring-boot-with-jsp.html","text":"Spring MVC 支持多种模板技术，如 JSP、FreeMarker、Thymeleaf 等。Spring Boot 官方并不推荐使用 JSP 模板引擎，如果有可能，应尽量避免使用 JSP，因为当使用嵌入式 Servlet 容器时，对使用 JSP 模板引擎有几个已知的限制，以下是 Spring Boot 支持自动配置的模板引擎（其中并不包含 JSP）： FreeMarker Groovy Thymeleaf Mustache 在 pom.xml 配置文件中添加内嵌 Tomcat 容器依赖，scope 声明为 provided： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 在 pom.xml 配置文件中添加 JSP 编译依赖，否则启动报错： 1234&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt; packaging 一定要声明为 war 类型，否则打包运行出错，完整配置： 1234567891011121314151617181920212223242526272829303132333435363738&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-jsp-sample&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-jsp-sample&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 1. 控制器12345678910@Controllerpublic class WelcomeController &#123; @GetMapping(\"/\") public String welcome(ModelMap model) &#123; model.put(\"message\", \"Hello JSP!\"); return \"index\"; &#125; &#125; 2. 主应用程序类12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 3. 配置文件在 Spring Boot 中使用 JSP 模板引擎有几个已知的限制，Spring Boot 对 JSP 模板引擎没有提供自动配置的支持，你需要手工配置视图模板文件信息。application.yml 配置示例： 1234567spring: main: banner-mode: 'off' mvc: view: prefix: /WEB-INF/pages/ suffix: .jsp 4. 模板文件src/main/webapp/WEB-INF/pages/index.jsp 12345678910&lt;%@ page pageEncoding=\"UTF-8\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;欢迎页&lt;/title&gt; &lt;link href=\"/css/main.css\" rel=\"stylesheet\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;$&#123;message&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 5. 静态文件Spring Boot 默认将静态资源文件映射到类路径下的目录包括（详见 ResourcesProperties）： /META-INF/resources/ /resources/ /static/ /public/ 因此我们可以将 css、js、images 等静态资源文件放在/src/main/resources/static/目录下。 # src/main/resources/static/css/main.css123456789body &#123; padding: 0; color: #444; width: 280px; margin: 100px auto; font-family: SimSun; background-color: #FBFBFB; text-shadow: rgba(50,50,50,0.3) 2px 2px 3px;&#125; 6. 模板文件和静态资源文件的缓存问题当修改 css、js 等静态资源文件的内容或模板文件的内容时，刷新客户端浏览器，发现内容还是老的，说明 Spring Boot 内置的 Servelt 容器并没有实时重新加载修改过的文件内容。你只能在每次修改静态资源文件时，虽然不需要重启服务，但是你要重新编译一次，IntelliJ IDEA 中按一次 Ctrl + F9 即可。实现热加载（live reload）可参考：解决 IntelliJ IDEA 无法热加载 Spring Boot 模板文件和静态资源文件 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-jsp-sample","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Spring Boot 快速入门 - 1 分钟搭建 Web 应用","date":"2017-04-02T05:02:06.000Z","path":"post/spring-boot-quick-start.html","text":"Spring Boot 不是一个新的框架，它是提供一种使我们更易于创建基于 Spring 的最小或零配置的独立应用和服务的方式。 Spring 对于 Java 开发者来说一定都并不陌生，它作为目前非常流行的一个 Java 应用开发的基础框架，应用非常广泛。然而，由于其配置繁杂，各样格式的XML配置文件，着实让人头疼。 Spring Boot 的出现，可以让我们只需要非常简单的几步就可以搭建起一个基于 Sprign 框架的 Web 应用程序。Spring Boot的主要目标： 为所有的Spring开发提供一个更快，更广泛的入门体验。 开箱即用，以最小或零配置的方式，使我们更专注于解决应用程序的功能需求。 提供一些非功能性的常见的大型项目类特性（如内嵌服务器、安全、度量、健康检查、外部化配置）。 绝对没有代码生成，也不需要XML配置，可以完全避免XML配置 为了避免定义更多的注释配置（它将一些现有的 Spring 框架注释组合成一个简单的单个注释） 提供一些默认值，以便在任何时间内快速启动新项目。 1. 项目依赖1234567891011121314151617181920212223242526272829&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-quick-start&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-boot-quick-start&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2. 控制器123456789@RestControllerpublic class HelloWorldController &#123; @GetMapping(\"/\") public String sayHello() &#123; return \"Hello, Spring Boot!\"; &#125; &#125; 3. 主应用程序类Spring Boot 建议我们将主应用程序类置于其他类之上的根包名之下。这样就相当于隐式的的定义了注解扫描的基础搜索包名，而不需要指定 scanBasePackages 属性。 12345678@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 运行直接运行 Application 中的 main 方法： 12345678910111213141516171819202122232425262728293031 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.2.RELEASE)2017-04-02 13:02:06.791 INFO 7188 --- [ main] org.fanlychie.Application : Starting Application on FANLYCHIE-PC with PID 7188 (F:\\dev\\workspace\\idea\\spring-boot-hello-world\\target\\classes started by fanlychie in F:\\dev\\workspace\\idea\\spring-boot-hello-world)2017-04-02 13:02:06.793 INFO 7188 --- [ main] org.fanlychie.Application : No active profile set, falling back to default profiles: default2017-04-02 13:02:06.844 INFO 7188 --- [ main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@50de0926: startup date [Sun Apr 02 13:02:06 CST 2017]; root of context hierarchy2017-04-02 13:02:08.030 INFO 7188 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)2017-04-02 13:02:08.041 INFO 7188 --- [ main] o.apache.catalina.core.StandardService : Starting service Tomcat2017-04-02 13:02:08.042 INFO 7188 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/8.5.112017-04-02 13:02:08.121 INFO 7188 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2017-04-02 13:02:08.122 INFO 7188 --- [ost-startStop-1] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1284 ms2017-04-02 13:02:08.254 INFO 7188 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean : Mapping servlet: 'dispatcherServlet' to [/]2017-04-02 13:02:08.259 INFO 7188 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'characterEncodingFilter' to: [/*]2017-04-02 13:02:08.259 INFO 7188 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]2017-04-02 13:02:08.259 INFO 7188 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'httpPutFormContentFilter' to: [/*]2017-04-02 13:02:08.259 INFO 7188 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'requestContextFilter' to: [/*]2017-04-02 13:02:08.502 INFO 7188 --- [ main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@50de0926: startup date [Sun Apr 02 13:02:06 CST 2017]; root of context hierarchy2017-04-02 13:02:08.597 INFO 7188 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"&#123;[/],methods=[GET]&#125;\" onto public java.lang.String org.fanlychie.controller.HelloWorldController.sayHello()2017-04-02 13:02:08.599 INFO 7188 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"&#123;[/error]&#125;\" onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2017-04-02 13:02:08.599 INFO 7188 --- [ main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"&#123;[/error],produces=[text/html]&#125;\" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2017-04-02 13:02:08.624 INFO 7188 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-04-02 13:02:08.624 INFO 7188 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-04-02 13:02:08.661 INFO 7188 --- [ main] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-04-02 13:02:08.826 INFO 7188 --- [ main] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup2017-04-02 13:02:08.866 INFO 7188 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)2017-04-02 13:02:08.869 INFO 7188 --- [ main] org.fanlychie.Application : Started Application in 2.338 seconds (JVM running for 2.673) 打开 Terminal 视图，键入：curl -i -X GET http://localhost:8080/ 还没安装 CURL？赶快来试试吧：https://curl.haxx.se/download.html 示例项目开发环境：Java-8、Maven-3、IntelliJ IDEA-2017、Spring Boot-1.5.2.RELEASE完整示例项目链接：spring-boot-quick-start-sample","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"JPA 多对多注解","date":"2017-02-18T13:03:10.000Z","path":"post/jpa-many-to-many-annotation.html","text":"@ManyToMany 是属性或方法级别的注解，用于定义源实体与目标实体是多对多的关系。 参数 类型 描述 targetEntity Class 源实体关联的目标实体类型，默认是该成员属性对应的集合类型的泛型的参数化类型。 mappedBy String 用在双向关联中。如果关系是双向的，则需定义此参数（与 @JoinColumn 互斥，如果标注了 @JoinColumn 注解，不需要再定义此参数）。 cascade CascadeType[] 定义源实体和关联的目标实体间的级联关系。当对源实体进行操作时，是否对关联的目标实体也做相同的操作。默认没有级联操作。该参数的可选值有：CascadeType.PERSIST（级联新建）CascadeType.REMOVE（级联删除）CascadeType.REFRESH（级联刷新）CascadeType.MERGE（级联更新）CascadeType.ALL（包含以上四项） fetch FetchType 定义关联的目标实体的数据的加载方式。可选值：FetchType.LAZY（延迟加载，默认）FetchType.EAGER（立即加载）延迟加载：只有在第一次访问源实体关联的目标实体的时候才去加载。立即加载：在加载源实体数据的时候同时去加载好关联的目标实体的数据。 1. 多对多单向外键关联123456789101112@Entity(name = \"course\")public class Course &#123; @Id @GeneratedValue private Long id; private String name; // getters and setters &#125; 1234567891011121314@Entity(name = \"student\")public class Student &#123; @Id private String no; private String name; @ManyToMany(cascade = CascadeType.ALL) private Set&lt;Course&gt; courses; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567891011121314151617181920CREATE TABLE `course` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `student` ( `no` varchar(255) NOT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `student_courses` ( `student_no` varchar(255) NOT NULL, `courses_id` bigint(20) NOT NULL, PRIMARY KEY (`student_no`,`courses_id`), KEY `FKlwviiijdg10oc2ui4yl7adh1o` (`courses_id`), CONSTRAINT `FKa6x7sxxnd9c1pat349a01bsow` FOREIGN KEY (`student_no`) REFERENCES `student` (`no`), CONSTRAINT `FKlwviiijdg10oc2ui4yl7adh1o` FOREIGN KEY (`courses_id`) REFERENCES `course` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2. @JoinTable与 @Table 注解相类似，不同的是，@JoinTable 注解是用于定义关联表，它只能标注在实体类型的成员属性或方法上，常用于多对多或多对一的关联映射。如果没有声明，则使用该注解的默认值。 参数 类型 描述 name String 连接表的名称。 catalog String 默认为数据库系统缺省的 catalog。 schema String 默认为用户缺省的 schema。 joinColumns JoinColumn[] 连接表中的外键列，通过使用 @JoinColumn 注解来声明，该外键参照源实体的主键。 inverseJoinColumns JoinColumn[] 与 joinColumns 参数作用类似，只不过该外键参照的是目标实体的主键。 uniqueConstraints UniqueConstraint[] 表的唯一约束（除了由 @Column 和 @JoinColumn 注解指定的约束以及主键的约束之外的约束），通过使用 @UniqueConstraint 注解来声明，仅在允许自动更新数据库表结构的场景中起到作用，默认没有其他额外的约束条件。 indexes Index[] 表的索引，通过使用 @Index 注解来声明，仅在允许自动更新数据库表结构的场景中起到作用，默认没有其他额外的索引。 foreignKey ForeignKey 用于生成表时定义 joinColumns 参数的外键约束。 inverseForeignKey ForeignKey 用于生成表时定义 inverseJoinColumns 参数的外键约束。 Course 定义不变，Student 定义改为： 1234567891011121314151617@Entity(name = \"student\")public class Student &#123; @Id private String no; private String name; @ManyToMany(cascade = CascadeType.ALL) @JoinTable(name = \"student_course\", joinColumns = @JoinColumn(name = \"sno\"), inverseJoinColumns = @JoinColumn(name = \"cid\")) private Set&lt;Course&gt; courses; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567891011121314151617181920CREATE TABLE `course` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `student` ( `no` varchar(255) NOT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `student_course` ( `sno` varchar(255) NOT NULL, `cid` bigint(20) NOT NULL, PRIMARY KEY (`sno`,`cid`), KEY `FKkx4bkddvbfs0ese9v7hc5rycg` (`cid`), CONSTRAINT `FKrfibef5g98fllv2tlxuiii0lu` FOREIGN KEY (`sno`) REFERENCES `student` (`no`), CONSTRAINT `FKkx4bkddvbfs0ese9v7hc5rycg` FOREIGN KEY (`cid`) REFERENCES `course` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 3. 多对多双向外键关联类 Student 定义不变，Course 类的定义改为： 123456789101112131415@Entity(name = \"course\")public class Course &#123; @Id @GeneratedValue private Long id; private String name; @ManyToMany(mappedBy = \"courses\") private Set&lt;Student&gt; students; // getters and setters &#125; 产生的 DDL 语句与多对多单向外键关联产生的一致。","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA 一对多、多对一注解","date":"2017-02-14T13:03:00.000Z","path":"post/jpa-one-to-many-many-to-one-annotation.html","text":"1. @OneToMany@OneToMany 是属性或方法级别的注解，用于定义源实体与目标实体是一对多的关系。 参数 类型 描述 targetEntity Class 源实体关联的目标实体类型，默认是该成员属性对应的集合类型的泛型的参数化类型。 mappedBy String 用在双向关联中。如果关系是双向的，则需定义此参数（与 @JoinColumn 互斥，如果标注了 @JoinColumn 注解，不需要再定义此参数）。 cascade CascadeType[] 定义源实体和关联的目标实体间的级联关系。当对源实体进行操作时，是否对关联的目标实体也做相同的操作。默认没有级联操作。该参数的可选值有：CascadeType.PERSIST（级联新建）CascadeType.REMOVE（级联删除）CascadeType.REFRESH（级联刷新）CascadeType.MERGE（级联更新）CascadeType.ALL（包含以上四项） fetch FetchType 定义关联的目标实体的数据的加载方式。可选值：FetchType.LAZY（延迟加载，默认）FetchType.EAGER（立即加载）延迟加载：只有在第一次访问源实体关联的目标实体的时候才去加载。立即加载：在加载源实体数据的时候同时去加载好关联的目标实体的数据。 orphanRemoval boolean 当源实体关联的目标实体被断开（如给该属性赋予另外一个实例，或该属性的值被设为 null。被断开的实例称为孤值，因为已经找不到任何一个实例与之发生关联）时，是否自动删除断开的实例（在数据库中表现为删除表示该实例的行记录），默认为 false。可参考：orphanRemoval 与 CascadeType.REMOVE 的区别 1.1 一对多外键关联1234567891011121314151617@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue private Long id; private String username; private String password; @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true) private Set&lt;Address&gt; addresses; // getters and setters &#125; 1234567891011121314151617181920@Entity(name = \"address\")public class Address implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; private String province; private String city; private String area; private String detail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 12345678910111213141516171819202122232425CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `password` varchar(255) DEFAULT NULL, `username` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `address` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `area` varchar(255) DEFAULT NULL, `city` varchar(255) DEFAULT NULL, `detail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, `province` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `user_addresses` ( `user_id` bigint(20) NOT NULL, `addresses_id` bigint(20) NOT NULL, PRIMARY KEY (`user_id`,`addresses_id`), UNIQUE KEY `UK_i5lp1fvgfvsplfqwu4ovwpnxs` (`addresses_id`), CONSTRAINT `FKfm6x520mag23hvgr1oshaut8b` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`), CONSTRAINT `FKth1icmttmhhorb9wiarm73i06` FOREIGN KEY (`addresses_id`) REFERENCES `address` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; Hibernate @OneToMany 默认会产生一张中间表，如上例的 user_addresses 表。为了避免这种情况，你可以在一的一方使用 @JoinColumn 注解： 123@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)@JoinColumn(name = \"user_id\")private Set&lt;Address&gt; addresses; 产生的 DDL 语句（MySQL）： 12345678910111213141516171819CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `password` varchar(255) DEFAULT NULL, `username` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `address` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `area` varchar(255) DEFAULT NULL, `city` varchar(255) DEFAULT NULL, `detail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, `province` varchar(255) DEFAULT NULL, `user_id` bigint(20) DEFAULT NULL, PRIMARY KEY (`id`), KEY `FKda8tuywtf0gb6sedwk7la1pgi` (`user_id`), CONSTRAINT `FKda8tuywtf0gb6sedwk7la1pgi` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 这样一来，多的一方通过外键直接与一的一方发生关联，不需要中间表。 2. @ManyToOne@ManyToOne 是属性或方法级别的注解，用于定义源实体与目标实体是多对一的关系。 参数 类型 描述 targetEntity Class 源实体关联的目标实体类型，默认是该成员属性对应的类型，因此该参数通常可以缺省。 cascade CascadeType[] 定义源实体和关联的目标实体间的级联关系。当对源实体进行操作时，是否对关联的目标实体也做相同的操作。默认没有级联操作。该参数的可选值有：CascadeType.PERSIST（级联新建）CascadeType.REMOVE（级联删除）CascadeType.REFRESH（级联刷新）CascadeType.MERGE（级联更新）CascadeType.ALL（包含以上四项） fetch FetchType 定义关联的目标实体的数据的加载方式。可选值：FetchType.LAZY（延迟加载）FetchType.EAGER（立即加载，默认）延迟加载：只有在第一次访问源实体关联的目标实体的时候才去加载。立即加载：在加载源实体数据的时候同时去加载好关联的目标实体的数据。 optional boolean 源实体关联的目标实体是否允许为 null，默认为 true。 2.1 多对一外键关联1234567891011121314@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue private Long id; private String username; private String password; // getters and setters &#125; 1234567891011121314151617181920212223@Entity(name = \"address\")public class Address implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; private String province; private String city; private String area; private String detail; @ManyToOne(optional = false) private User user; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 12345678910111213141516171819CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `password` varchar(255) DEFAULT NULL, `username` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `address` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `area` varchar(255) DEFAULT NULL, `city` varchar(255) DEFAULT NULL, `detail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, `province` varchar(255) DEFAULT NULL, `user_id` bigint(20) NOT NULL, PRIMARY KEY (`id`), KEY `FKda8tuywtf0gb6sedwk7la1pgi` (`user_id`), CONSTRAINT `FKda8tuywtf0gb6sedwk7la1pgi` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 3. @OneToMany &amp; @ManyToOne一对多 &amp; 多对一双向外键关联示例： 123456789101112131415161718@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue private Long id; private String username; private String password; @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true) @JoinColumn(name = \"user_id\") private Set&lt;Address&gt; addresses; // getters and setters &#125; 1234567891011121314151617181920212223@Entity(name = \"address\")public class Address implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; private String province; private String city; private String area; private String detail; @ManyToOne(optional = false) private User user; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 12345678910111213141516171819CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `password` varchar(255) DEFAULT NULL, `username` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `address` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `area` varchar(255) DEFAULT NULL, `city` varchar(255) DEFAULT NULL, `detail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, `province` varchar(255) DEFAULT NULL, `user_id` bigint(20) NOT NULL, PRIMARY KEY (`id`), KEY `FKda8tuywtf0gb6sedwk7la1pgi` (`user_id`), CONSTRAINT `FKda8tuywtf0gb6sedwk7la1pgi` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA 一对一注解","date":"2017-02-14T13:02:57.000Z","path":"post/jpa-one-to-one-annotation.html","text":"@OneToOne 是属性或方法级别的注解，用于定义源实体与目标实体是一对一的关系。 参数 类型 描述 targetEntity Class 源实体关联的目标实体类型，默认是该成员属性对应的类型，因此该参数通常可以缺省。 mappedBy String 用在双向关联中。如果关系是双向的，只能有一方作为主体端，另一方则需声明此参数以表明将表间的这种关联关系转交给对方来维护。 cascade CascadeType[] 定义源实体和关联的目标实体间的级联关系。当对源实体进行操作时，是否对关联的目标实体也做相同的操作。默认没有级联操作。该参数的可选值有：CascadeType.PERSIST（级联新建）CascadeType.REMOVE（级联删除）CascadeType.REFRESH（级联刷新）CascadeType.MERGE（级联更新）CascadeType.ALL（包含以上四项） fetch FetchType 定义关联的目标实体的数据的加载方式。可选值：FetchType.LAZY（延迟加载）FetchType.EAGER（立即加载，默认）延迟加载：只有在第一次访问源实体关联的目标实体的时候才去加载。立即加载：在加载源实体数据的时候同时去加载好关联的目标实体的数据。 optional boolean 源实体关联的目标实体是否允许为 null，默认为 true。 orphanRemoval boolean 当源实体关联的目标实体被断开（如给该属性赋予另外一个实例，或该属性的值被设为 null。被断开的实例称为孤值，因为已经找不到任何一个实例与之发生关联）时，是否自动删除断开的实例（在数据库中表现为删除表示该实例的行记录），默认为 false。 注：目标实体是指被关系注解（如：@OneToOne）标注的属性或方法所对应的类，源实体是指该属性或方法所属的类。 1. 一对一单向外键关联123456789101112131415@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY) private IdCard idCard; // getters and setters &#125; 123456789101112@Entity(name = \"idcard\")public class IdCard &#123; @Id private String no; @Temporal(TemporalType.DATE) private Date expiryDate; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567891011121314CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `id_card_no` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), KEY `FKar03p8ob32rgj1axxy2q507v5` (`id_card_no`), CONSTRAINT `FKar03p8ob32rgj1axxy2q507v5` FOREIGN KEY (`id_card_no`) REFERENCES `idcard` (`no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `idcard` ( `no` varchar(255) NOT NULL, `expiry_date` date DEFAULT NULL, PRIMARY KEY (`no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2. orphanRemoval 与 CascadeType.REMOVE 的区别CascadeType.REMOVE（或包含 CascadeType.REMOVE 的 CascadeType.ALL）表示级联删除，只有对源实例做删除操作时，才会级联删除关联的目标实例。如上例，删除 id=1 的 Person 实例，那么，该实例所关联的 IdCard 实例也将被删除。示例代码片段： 1personRepository.delete(1L); 假设 person.idCard = idCard1，如果 person.idCard 属性被赋予了另外一个 IdCard 实例：person.idCard = idCard2 或被设为 null：person.idCard = null。此时，身份证 idCard1 已经找不到任何一个人和它发生关联，这样的值我们成为孤值，它已经失去了存在的意义。如果程序中设置了 orphanRemoval = true，那么，当更新 person 实例时，idCard1 实例将会被自动删除。示例代码片段： 123Person person = personRepository.findOne(1L);person.setIdCard(null);personRepository.save(person); 3. 一对一双向外键关联类 Person 定义不变，IdCard 类的定义改为： 123456789101112131415@Entity(name = \"idcard\")public class IdCard &#123; @Id private String no; @Temporal(TemporalType.DATE) private Date expiryDate; @OneToOne(mappedBy = \"idCard\") private Person person; // getters and setters &#125; 产生的 DDL 语句与一对一单向外键关联产生的一致。 4. @JoinColumn与 @Column 注解相类似，不同的是，@JoinColumn 注解是用于定义外键列，它只能标注在实体类型的成员属性或方法上，如果没有声明，则使用该注解的默认值。 参数 类型 描述 name String 外键列的名称，默认为：属性的名称 + _ + 属性对应的实体的主键列的名称（Hibernate 映射列时，若遇到驼峰拼写，会自动添加 _ 连接并将大写字母改成小写）。 unique boolean 外键列的值是否是唯一的。这是 @UniqueConstraint 注解的一个快捷方式，实质上是在声明唯一约束。默认值为 false。 nullable boolean 外键列的值是否允许为 null。默认为 true。 insertable boolean 外键列是否包含在 INSERT 语句中，默认为 true。 updatable boolean 外键列是否包含在 UPDATE 语句中，默认为 true。 columnDefinition String 生成外键列的 DDL 时使用的 SQL 片段。默认使用推断的类型来生成 SQL 片段以创建此列。 table String 外键列所属的表的名称。默认值：如果是外键 @OneToOne 或 @ManyToOne 关联，则为源实体的表的名称；如果是单向外键 @OneToMany 关系，则为目标实体的表的名称；如果是 @ManyToMany、@OneToOne、双向 @ManyToOne、双向 @OneToMany 关联，则为连接表的名称； 若修改 Person 类的定义为： 12345678910111213141516@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY) @JoinColumn(name = \"idcard_no\") private IdCard idCard; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 12345678CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `idcard_no` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), KEY `FK56rk440ff4uyhc5vdis0jeiut` (`idcard_no`), CONSTRAINT `FK56rk440ff4uyhc5vdis0jeiut` FOREIGN KEY (`idcard_no`) REFERENCES `idcard` (`no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA @Column 注解","date":"2017-02-13T12:45:05.000Z","path":"post/jpa-column-annotation.html","text":"@Column 是属性或方法级别的注解，用于指定持久化属性映射到数据库表的列。如果没有指定列注释，则使用其默认值。 参数 类型 描述 name String 列的名称，默认为属性的名称（Hibernate 映射列时，若遇到驼峰拼写，会自动添加 _ 连接并将大写字母改成小写）。 unique boolean 列的值是否是唯一的。这是 @UniqueConstraint 注解的一个快捷方式， 实质上是在声明唯一约束。默认值为 false。 nullable boolean 列的值是否允许为 null。默认为 true。 insertable boolean 列是否包含在 INSERT 语句中，默认为 true。 updatable boolean 列是否包含在 UPDATE 语句中，默认为 true。 columnDefinition String 生成列的 DDL 时使用的 SQL 片段。默认使用推断的类型来生成 SQL 片段以创建此列。 table String 当前列所属的表的名称。 length int 列的长度，仅对字符串类型的列生效。默认为255。 precision int 列的精度，仅对十进制数值有效，表示有效数值的总位数。默认为0。 scale int 列的精度，仅对十进制数值有效，表示小数位的总位数。默认为0。 1. 示例12345678910111213141516171819202122232425@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue private Long id; @Column(nullable = false, length = 32) private String name; @Column(length = 128) private String mail; @Column(columnDefinition = \"char(11) NOT NULL\") private String phone; @Column(precision = 5, scale = 2) private BigDecimal salary; @Column(precision = 5, scale = 2) private double assets; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 123456789CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `assets` double NOT NULL, `mail` varchar(128) DEFAULT NULL, `name` varchar(32) NOT NULL, `phone` char(11) NOT NULL, `salary` decimal(5,2) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 可以看出，salary 字段的精度控制生效了，但对于 double 类型的 assets 字段的精度控制没有生效，为了使其生效，将代码修改为： 12@Column(columnDefinition = \"double(5, 2)\")private double assets; 产生的 DDL 语句（MySQL）： 123456789CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `assets` double(5,2) DEFAULT NULL, `mail` varchar(128) DEFAULT NULL, `name` varchar(32) NOT NULL, `phone` char(11) NOT NULL, `salary` decimal(5,2) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA @Temporal 注解","date":"2017-02-13T12:45:00.000Z","path":"post/jpa-temporal-annotation.html","text":"@Temporal 是属性或方法级别的注解，用于声明属性持久化到数据库时所使用的时间精度。该注解可以应用于任何以下类型的实体类属性： java.util.Date java.util.Calendar 参数 类型 描述 value TemporalType 存储的类型，可选值：TemporalType.DATE（日期）TemporalType.TIME（时间）TemporalType.TIMESTAMP（日期和时间） 1. 示例12345678910111213141516171819@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue private Long id; @Temporal(TemporalType.DATE) private Date birthday; @Temporal(TemporalType.TIMESTAMP) private Date lastLoginTime; @Temporal(TemporalType.TIME) private Date tokenExpiredTime; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `birthday` date DEFAULT NULL, `last_login_time` datetime DEFAULT NULL, `token_expired_time` time DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 数据值样例： 12345+----+------------+---------------------+--------------------+| id | birthday | last_login_time | token_expired_time |+----+------------+---------------------+--------------------+| 1 | 2017-05-14 | 2017-05-14 15:12:49 | 15:12:49 |+----+------------+---------------------+--------------------+","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA @Transient 注解","date":"2017-02-13T12:44:56.000Z","path":"post/jpa-transient-annotation.html","text":"@Transient 是属性或方法级别的注解，该注解没有参数，用于标注属性是瞬态而非持久的。 1. 示例123456789101112131415@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; @Transient private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 12345CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA @GeneratedValue 注解","date":"2017-02-13T12:44:51.000Z","path":"post/jpa-generatedvalue-annotation.html","text":"@GeneratedValue 是属性或方法级别的注解，它结合 @Id 注解为主键的值提供生成策略的规范。 参数 类型 描述 strategy GenerationType 主键生成策略。可选值：GenerationType.TABLEGenerationType.SEQUENCEGenerationType.IDENTITYGenerationType.AUTO默认是 GenerationType.AUTO。 generator String 主键生成器的名称。该名称为 @TableGenerator 或 @SequenceGenerator 注解中 name 参数的值。默认为持久化提供者（如 Hibernate）提供的id生成器。 1. @GeneratedValue1234567891011121314@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 123456CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 1.1 GenerationType.TABLE该策略使用一个特殊的数据库表来为各个实体分配主键，并确保主键值的唯一性。它不依赖环境和数据库系统的具体实现，在不同数据库之间可以很容易的进行移植。 1234567891011121314@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.TABLE) private Long id; private String name; private String mail; // getters and setters &#125; 在 Hibernate + MySQL 环境产生的 DDL 语句： 123456789101112CREATE TABLE `person` ( `id` bigint(20) NOT NULL, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `hibernate_sequences` ( `sequence_name` varchar(255) NOT NULL, `sequence_next_hi_value` bigint(20) DEFAULT NULL, PRIMARY KEY (`sequence_name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 其中，hibernate_sequences 表就是用来为各个实体分配主键的，sequence_name 用于存储各个实体名称，sequence_next_hi_value 则是用于存储各个实体的下一个主键的值。 每次保存 Person 实体对象的数据的时候，首先会到 hibernate_sequences 表中查询该实体名称是否已经存在，若不存在，则向 hibernate_sequences 表插入一行该实体名称的记录，若已经存在，则直接取出 sequence_next_hi_value 的值作为本次 Person 数据的主键值，接着更新 hibernate_sequences 表的记录，使该实体名称的记录的 sequence_next_hi_value 值加1。最后保存 Person 实体对象的记录。 1.1.1 @TableGenerator表生成器，GenerationType.TABLE 策略通常结合该注解一起使用。 参数 类型 描述 name String 生成器的名称，它可以被一个或多个类引用为主键的生成器。 table String 生成器表的名称。默认为持久化提供者（如 Hibernate）提供的名称。 catalog String 生成器表的 catalog，默认为数据库系统缺省的 catalog。 schema String 生成器表的 schema，默认为用户缺省的 schema。 pkColumnName String 生成器表的主键列的名称，默认为持久化提供者（如 Hibernate）提供的名称。 valueColumnName String 生成器表存储生成的值的列的名称，默认为持久化提供者（如 Hibernate）提供的名称。 pkColumnValue String 生成器表中的主键值，用于将不同的实体区分开来。默认为实体名称（@Entity 注解的 name 参数的值）。 initialValue int 用于初始化生成器生成的初始值。默认值是0。在 Hibernate 环境中，需要开启 hibernate.id.new_generator_mappings=true（Spring JPA 配置为：spring.jpa.hibernate.use-new-id-generator-mappings=true），否则此参数无效。并且如果实体记录已经存在生成器表中，此参数也无效（即只有当实体记录第一次写入生成器表中时此参数生效）。 allocationSize int 每次分配的值的数量大小，用完之后再分配此数量的值，默认为50。 uniqueConstraints UniqueConstraint[] 表的唯一约束，参考 @UniqueConstraint indexes Index[] 表的索引，参考 @Index 注：catalog 和 schema 可参考 catalog 和 schema 的区别。 123456789101112131415161718192021@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.TABLE, generator = \"pkGenerator\") @TableGenerator( name = \"pkGenerator\", table = \"pk_sequences\", pkColumnName = \"entity_name\", valueColumnName = \"sequence_value\", allocationSize = 10 ) private Long id; private String name; private String mail; // getters and setters &#125; 12345678910111213141516171819@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.TABLE, generator = \"pkGenerator\") @TableGenerator( name = \"pkGenerator\", table = \"pk_sequences\", pkColumnName = \"entity_name\", valueColumnName = \"sequence_value\", allocationSize = 10 ) private Long id; private String name; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 123456789101112131415161718CREATE TABLE `person` ( `id` bigint(20) NOT NULL, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `user` ( `id` bigint(20) NOT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; CREATE TABLE `pk_sequences` ( `entity_name` varchar(255) NOT NULL, `sequence_value` bigint(20) DEFAULT NULL, PRIMARY KEY (`entity_name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 1.2 GenerationType.SEQUENCE某些数据库系统（如：Oracle、DB2、PostgreSQL 等）底层支持使用序列对象来为表的主键提供唯一值，而对于不支持序列对象的数据库（如：MySQL、SQLServer），则不应使用此策略。 1234567891011121314@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.SEQUENCE) private Long id; private String name; private String mail; // getters and setters &#125; 1234567891011121314151617181920212223242526@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.SEQUENCE) private Long id; private String name; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; 这种方式是多个实体共用同一个序列对象，这将导致各个实体分配到的序列值不连续，并且消耗加快。 1.2.1 @SequenceGenerator序列生成器，GenerationType.SEQUENCE 策略通常结合该注解一起使用。 参数 类型 描述 name String 生成器的名称，它可以被一个或多个类引用为主键的生成器。 sequenceName String 序列对象的名称，默认为持久化提供者（如 Hibernate）提供的名称。 catalog String 序列生成器的 catalog。 schema String 序列生成器的 schema。 initialValue int 用于初始化序列对象生成的初始值。默认值是1。 allocationSize int 每次分配的值的数量大小，用完之后再分配此数量的值，默认为50。 12345678910111213141516171819@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"personSeqGenerator\") @SequenceGenerator( name = \"personSeqGenerator\", sequenceName = \"PERSON_SEQ\", allocationSize = 10 ) private Long id; private String name; private String mail; // getters and setters &#125; 1234567891011121314151617@Entity(name = \"user\")public class User implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"userSeqGenerator\") @SequenceGenerator( name = \"userSeqGenerator\", sequenceName = \"USER_SEQ\", allocationSize = 10 ) private Long id; private String name; // getters and setters &#125; 1.3 GenerationType.IDENTITY大部分数据库系统（如：MySQL、SQLServer、DB2、Sybase、HypersonicSQL 等）底层支持表的主键自增长，而对于不支持主键自增长的数据库（如：Oracle），则不能使用此策略。 1234567891011121314@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 123456CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 1.4 GenerationType.AUTO自动为特定的数据库选择适当的策略，这是比较常用的策略。 1234567891011121314@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; private String mail; // getters and setters &#125; 由于 @GeneratedValue 注解默认采用的策略就是 GenerationType.AUTO，因此可以简写成： 1234567891011121314@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue private Long id; private String name; private String mail; // getters and setters &#125;","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA @Id 注解","date":"2017-02-13T12:44:47.000Z","path":"post/jpa-id-annotation.html","text":"@Id 是属性或方法级别的注解，该注解没有参数，用于标注实体的主键（映射到数据库表的主键）。 1. 示例12345678910111213@Entity(name = \"person\")public class Person implements Serializable &#123; @Id private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 123456CREATE TABLE `person` ( `id` bigint(20) NOT NULL, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA @Basic 注解","date":"2017-02-13T12:44:43.000Z","path":"post/jpa-basic-annotation.html","text":"@Basic 是属性或方法级别的注解，该注解可以应用于任何以下类型的实体类属性： Java 原始类型 原始类型的包装类型 String java.math.BigInteger java.math.BigDecimal java.util.Date java.util.Calendar java.sql.Date java.sql.Time java.sql.Timestamp byte[] Byte[] char[] Character[] 枚举 任意实现 java.io.Serializable 接口的类型 在实体类中，对以上这些类型的属性，如果没有标注 @Basic 注解，则将使用 @Basic 注解的默认值。 参数 类型 描述 fetch FetchType 属性值的加载策略。可选值：FetchType.EAGER：即时加载；FetchType.LAZY：延迟加载，当第一次访问属性时才进行数据的加载；默认为 FetchType.EAGER。 optional boolean 是否允许为 null，默认为 true。 1. 示例123456789101112131415@Entity(name = \"person\")public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; @Basic(optional = false, fetch = FetchType.LAZY) private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 123456CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) NOT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA @MappedSuperclass 注解","date":"2017-02-11T16:18:20.000Z","path":"post/jpa-mappedsuperclass-annotation.html","text":"@MappedSuperclass 是类级别注解，该注解没有任何参数，被该注解标注的类不会映射到数据库中单独的表，但该类所拥有的属性都将映射到其子类的数据库表的列中。 1. 示例12345678910111213@MappedSuperclasspublic class BaseEntity &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) protected Long id; @Column(name = \"create_time\") protected Date createTime; // getters and setters &#125; 12345678910@Entity(name = \"person\")public class Person extends BaseEntity implements Serializable &#123; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `create_time` datetime DEFAULT NULL, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2. @AttributeOverride对于被 @MappedSuperclass 注解标注的类派生出来的子类，可以使用 @AttributeOverride 注解重新定义以覆盖父类中的映射信息。 参数 类型 描述 name String 属性名称 column Column 列信息 1234567891011@Entity(name = \"person\")@AttributeOverride(name = \"createTime\", column = @Column(name = \"create_date\"))public class Person extends BaseEntity implements Serializable &#123; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `create_date` datetime DEFAULT NULL, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 3. @AttributeOverrides如果需要重新定义父类中的多个映射信息，需要使用 @AttributeOverrides 注解。 参数 类型 描述 value AttributeOverride[] @AttributeOverride 注解列表 1234567891011121314@Entity(name = \"person\")@AttributeOverrides(&#123; @AttributeOverride(name = \"id\", column = @Column(name = \"person_id\")), @AttributeOverride(name = \"createTime\", column = @Column(name = \"create_date\"))&#125;)public class Person extends BaseEntity implements Serializable &#123; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567CREATE TABLE `person` ( `person_id` bigint(20) NOT NULL AUTO_INCREMENT, `create_date` datetime DEFAULT NULL, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`person_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA @Table 注解","date":"2017-02-07T16:14:00.000Z","path":"post/jpa-table-annotation.html","text":"@Table 是类级别的注解，用于声明实体映射到数据库中的具体的表。 参数 类型 描述 name String 表的名称，默认为实体名称（参考 @Entity 注解的 name 参数说明），因此如果实体名称与映射的表名称一致时，@Table 注解常常可以省略。 catalog String 默认为数据库系统缺省的 catalog。 schema String 默认为用户缺省的 schema。 uniqueConstraints UniqueConstraint[] 表的唯一约束（除了由 @Column 和 @JoinColumn 注解指定的约束以及主键的约束之外的约束），通过使用 @UniqueConstraint 注解来声明，仅在允许自动更新数据库表结构的场景中起到作用，默认没有其他额外的约束条件。 indexes Index[] 表的索引，通过使用 @Index 注解来声明，仅在允许自动更新数据库表结构的场景中起到作用，默认没有其他额外的索引。 1 catalog 和 schema 的区别catalog 和 schema 主要用来解决数据库系统命名冲突的问题。一个数据库系统可以包含多个 catalog，每个 catalog 可以包含多个 schema，而每个 schema 又可以包含多个数据库对象（表、视图等）。不同的数据库系统对 catalog 和 schema 的支持方式有所不同，常见的数据库系统： 数据库系统 catalog schema MySQL 不支持 数据库名 Oracle 不支持 用户 ID SQLServer 数据库名 对象属主名 DB2 指定数据库对象时，Catalog 可以省略 Catalog 属主名 Sybase 数据库名 数据库属主名 2 唯一约束和索引的区别唯一约束是用来确保数据的正确性，它不允许表中存在重复的数据，若新插入的数据在表中已经存在，则更新操作失败。在数据库系统中，创建一个唯一约束的同时，也会为该约束所指定的所有列创建一个唯一索引，即约束包含索引。 索引是用来优化数据库表数据的检索性能的。通常，出现在查询 SQL 的 WHERE 子句和 JOIN 子句中的列可以考虑为其建立索引。 3. @UniqueConstraint用于声明表的唯一约束，这些仅在允许自动更新数据库表结构的场景中起到作用。 参数 类型 描述 name String 约束名称，如果不指定，默认使用数据库提供商所生成的值。 columnNames String[] 约束的列名称 4. @Index用于声明表的索引，这些仅在允许自动更新数据库表结构的场景中起到作用。另外，不需要为表的主键指定索引，因为主键索引会自动被创建。 参数 类型 描述 name String 索引名称，如果不指定，默认使用数据库提供商所生成的值。 columnList String 要包含在索引中的列名称。 unique boolean 索引是否唯一，默认为 false。 5. @Table5.1 唯一约束name 列、mail 列的值必须是唯一的，不允许出现重复的值： 123456789101112131415161718@Entity(name = \"person\")@Table(uniqueConstraints = &#123; @UniqueConstraint(name = \"unique_name\", columnNames = \"name\"), @UniqueConstraint(name = \"unique_mail\", columnNames = \"mail\")&#125;)public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 12345678CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `unique_name` (`name`), UNIQUE KEY `unique_mail` (`mail`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 5.2 联合唯一约束多列联合唯一约束，name 列和 mail 列不能同时出现相同的值： 123456789101112131415@Entity(name = \"person\")@Table(uniqueConstraints = @UniqueConstraint(name = \"unique_name_mail\", columnNames = &#123;\"name\", \"mail\"&#125;))public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `unique_name_mail` (`name`,`mail`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 5.3 单列索引为 name 列和 mail 列分别建立索引： 123456789101112131415161718@Entity(name = \"person\")@Table(indexes = &#123; @Index(name = \"index_name\", columnList = \"name\"), @Index(name = \"index_mail\", columnList = \"mail\")&#125;)public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 12345678CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_name` (`name`), KEY `index_mail` (`mail`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 5.4 多列索引为 name 列和 mail 列建立多列索引： 123456789101112131415@Entity(name = \"person\")@Table(indexes = @Index(name = \"index_name_mail\", columnList = \"name,mail\"))public class Person implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; private String mail; // getters and setters &#125; 产生的 DDL 语句（MySQL）： 1234567CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `mail` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), KEY `index_name_mail` (`name`,`mail`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 5.5 单列索引和多列索引的区别当 SQL 查询条件中包含 name 和 mail 时： 1SELECT * FROM PERSON WHERE NAME = 'U79028' AND MAIL = '79029@163.com' 如果为 name 和 mail 列分别建立索引，当执行查询时，MySQL 只能使用一个索引。如果发现有多个单列索引可用，MySQL 会试图选择一个限制最严格的索引来检索，而其他索引则利用不上。 使用分析器分析查询 SQL： 1EXPLAIN SELECT * FROM PERSON WHERE NAME = 'U79028' AND MAIL = '79029@163.com' 结果如下： 12345+----+-------------+--------+------+-----------------------+------------+---------+-------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+-----------------------+------------+---------+-------+------+-------------+| 1 | SIMPLE | PERSON | ref | index_name,index_mail | index_mail | 768 | const | 1 | Using where |+----+-------------+--------+------+-----------------------+------------+---------+-------+------+-------------+ MySQL 优化器如果发现可以使用多个索引查找后的交集/并集定位数据，那么 MySQL 优化器就会尝试使用 index merge（索引合并）的方式来查询： 1EXPLAIN SELECT * FROM PERSON WHERE NAME = 'U79028' AND MAIL = '79028@163.com' 结果如下： 12345+----+-------------+--------+-------------+-----------------------+-----------------------+---------+------+------+------------------------------------------------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+-------------+-----------------------+-----------------------+---------+------+------+------------------------------------------------------------------+| 1 | SIMPLE | PERSON | index_merge | index_name,index_mail | index_name,index_mail | 768,768 | NULL | 1 | Using intersect(index_name,index_mail); Using where; Using index |+----+-------------+--------+-------------+-----------------------+-----------------------+---------+------+------+------------------------------------------------------------------+ 对于多列索引，由于索引文件以B树的数据结构存储，MySQL 能够快速转到合适的 name，然后再转到合适的 mail。在建立多列索引时，应该将严格的索引放在前面，这样筛选数据的时候力度会更大，效率更高。 使用分析器分析查询 SQL： 1EXPLAIN SELECT * FROM PERSON WHERE NAME = 'U79028' AND MAIL = '79028@163.com' 结果如下： 12345+----+-------------+--------+------+-----------------+-----------------+---------+-------------+------+--------------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+--------+------+-----------------+-----------------+---------+-------------+------+--------------------------+| 1 | SIMPLE | PERSON | ref | index_name_mail | index_name_mail | 1536 | const,const | 2 | Using where; Using index |+----+-------------+--------+------+-----------------+-----------------+---------+-------------+------+--------------------------+","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"JPA @Entity 注解","date":"2017-02-06T14:16:11.000Z","path":"post/jpa-entity-annotation.html","text":"@Entity 是类级别注解，用于声明标注的类是持久的，我们把这样的类称为实体类。每个实体类映射到数据库中的一张表，实体类所拥有的属性将映射成数据库表的列。并由 JPA 负责将对实体的操作转换为对数据库表的操作。 参数 类型 描述 name String 实体名称，在 JPQL 中用于引用该实体类。默认为该类的简单类名称。 示例123456@Entity(name = \"person\")public class Person implements Serializable &#123; ... ... &#125;","tags":[{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"}]},{"title":"mybatis-template-generator 帮助文档","date":"2017-02-04T07:36:55.000Z","path":"post/mybatis-template-generator-document.html","text":"获取依赖123456789101112131415161718&lt;!-- 仓库地址 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;github-maven-repo&lt;/id&gt; &lt;url&gt;https://raw.github.com/fanlychie/maven-repo/releases&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;dependencies&gt; &lt;!-- 声明依赖，版本信息参考：https://github.com/fanlychie/mybatis-template-generator/releases --&gt; &lt;dependency&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;mybatis-template-generator&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;!-- 打包时可顺利排除此依赖 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 环境要求JDK1.7 或以上版本 项目地址https://github.com/fanlychie/mybatis-template-generator 配置配置文件在项目类路径下新建一个文件 mybatis-template-generator.xml (右键链接另存为下载), 内容如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;!-- 自定义属性, 通过 $&#123;&#125; 占位符来引用 --&gt; &lt;properties&gt; &lt;!-- 引入属性配置文件 --&gt; &lt;include location=\"jdbc.properties\"/&gt; &lt;!-- 自定义属性键值对 --&gt; &lt;property name=\"basePackage\" value=\"com.domain\"/&gt; &lt;/properties&gt; &lt;!-- 数据源配置 --&gt; &lt;datasource&gt; &lt;!-- 数据库连接地址 --&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;!-- 数据库账户名称 --&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;!-- 数据库账户密码 --&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;!-- 数据库连接驱动 --&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;/datasource&gt; &lt;!-- 表配置 --&gt; &lt;table&gt; &lt;!-- 表名分隔符 --&gt; &lt;property name=\"separator\" value=\"_\"/&gt; &lt;!-- 忽略表, 匹配的表将被忽略不处理 --&gt; &lt;property name=\"ignores\"&gt; &lt;value&gt;temp*&lt;/value&gt; &lt;/property&gt; &lt;!-- 逃逸表, 匹配的表总是会输出文件 --&gt; &lt;property name=\"escapes\"&gt; &lt;value&gt;none&lt;/value&gt; &lt;/property&gt; &lt;!-- 表前缀, 输出的类文件忽略此名称 --&gt; &lt;property name=\"prefixs\"&gt; &lt;value&gt;tb_&lt;/value&gt; &lt;/property&gt; &lt;/table&gt; &lt;!-- 列配置 --&gt; &lt;column&gt; &lt;!-- 列名分隔符 --&gt; &lt;property name=\"separator\" value=\"_\"/&gt; &lt;!-- 忽略列, 匹配的列将被忽略不处理 --&gt; &lt;property name=\"ignores\"&gt; &lt;value&gt;temp*&lt;/value&gt; &lt;/property&gt; &lt;!-- 逃逸列, 匹配的列总是会输出属性 --&gt; &lt;property name=\"escapes\"&gt; &lt;value&gt;none&lt;/value&gt; &lt;/property&gt; &lt;!-- 列前缀, 输出的属性忽略此前缀名 --&gt; &lt;property name=\"prefixs\"&gt; &lt;value&gt;none&lt;/value&gt; &lt;/property&gt; &lt;/column&gt; &lt;!-- 输出配置 --&gt; &lt;output&gt; &lt;!-- 实体类 --&gt; &lt;property name=\"entity\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.entity\"/&gt; &lt;!-- Mybatis 实体类对应的 Xml 文件 --&gt; &lt;property name=\"mapperXml\" folder=\"$&#123;basedir&#125;/src/main/resources\" package=\"$&#123;basePackage&#125;.mapper\"/&gt; &lt;!-- Dao 接口 --&gt; &lt;property name=\"dao\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.dao\"/&gt; &lt;!-- Dao 实现类 --&gt; &lt;property name=\"daoImpl\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.dao.impl\"/&gt; &lt;!-- Service 接口 --&gt; &lt;property name=\"service\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.service\"/&gt; &lt;!-- Service 实现类 --&gt; &lt;property name=\"serviceImpl\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.service.impl\"/&gt; &lt;!-- 每次生成时总是覆盖输出 --&gt; &lt;property name=\"overwrite\"&gt; &lt;value&gt;none&lt;/value&gt; &lt;/property&gt; &lt;/output&gt;&lt;/configuration&gt; properties配置模板文件上下文参数键值对, 上下文环境可以通过 ${} 语法来引用自定义的键值对。 通过类路径下的属性文件引入: 1&lt;include location=\"jdbc.properties\"/&gt; 直接声明键值对: 1&lt;property name=\"basePackage\" value=\"com.domain\"/&gt; datasource配置数据源信息: 12345678910&lt;!-- 数据库连接地址 --&gt;&lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt;&lt;!-- 数据库账户名称 --&gt;&lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt;&lt;!-- 数据库账户密码 --&gt;&lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;!-- 数据库连接驱动 --&gt;&lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/&gt;&lt;!-- 元数据类, 默认配置 --&gt;&lt;property name=\"metadataClass\" value=\"org.fanlychie.mybatis.template.db.MySQLMetadata\"/&gt; metadataClass 默认使用 MySQL 数据库实现。 其它数据库生成模板代码需实现抽象类 org.fanlychie.mybatis.template.db.DatabaseMetadata。 table数据库表配置信息: 1234567891011121314&lt;!-- 表名分隔符 --&gt;&lt;property name=\"separator\" value=\"_\"/&gt;&lt;!-- 忽略表, 匹配的表将被忽略不处理 --&gt;&lt;property name=\"ignores\"&gt; &lt;value&gt;temp*&lt;/value&gt;&lt;/property&gt;&lt;!-- 逃逸表, 匹配的表总是会输出文件 --&gt;&lt;property name=\"escapes\"&gt; &lt;value&gt;none&lt;/value&gt;&lt;/property&gt;&lt;!-- 表前缀, 输出的类文件忽略此名称 --&gt;&lt;property name=\"prefixs\"&gt; &lt;value&gt;tb_&lt;/value&gt;&lt;/property&gt; 参数 描述 separator 表名分隔符, 用于驼峰拼写, 例: user_info -&gt; UserInfo ignores 忽略表, 匹配的表将被忽略不处理 escapes 逃逸表, 它无视 ignores 配置的规则, 匹配的表总是会输出文件 prefixs 表前缀, 输出的类文件忽略此名称, 例: tb_user_info -&gt; UserInfo column数据库列配置信息: 123456789101112131415161718&lt;!-- 列名分隔符 --&gt;&lt;property name=\"separator\" value=\"_\"/&gt;&lt;!-- 忽略列, 匹配的列将被忽略不处理 --&gt;&lt;property name=\"ignores\"&gt; &lt;value&gt;temp*&lt;/value&gt;&lt;/property&gt;&lt;!-- 逃逸列, 匹配的列总是会输出属性 --&gt;&lt;property name=\"escapes\"&gt; &lt;value&gt;none&lt;/value&gt;&lt;/property&gt;&lt;!-- 列前缀, 输出的属性忽略此前缀名 --&gt;&lt;property name=\"prefixs\"&gt; &lt;value&gt;none&lt;/value&gt;&lt;/property&gt;&lt;!-- 数据库类型和 JAVA 数据类型的映射表 --&gt;&lt;property name=\"typeMapping\"&gt; &lt;value jdbcType=\"varchar\" javaType=\"String\" /&gt;&lt;/property&gt; 参数 描述 separator 列名分隔符, 用于驼峰拼写, 例: user_id -&gt; userId ignores 忽略列, 匹配的表将被忽略不处理 escapes 逃逸列, 它无视 ignores 配置的规则, 匹配的列总是输出到对象属性或文件 prefixs 列前缀, 输出的属性忽略此前缀名 typeMapping 数据库类型和 JAVA 数据类型的映射表 output模板文件输出配置信息: 12345678910111213141516&lt;!-- 实体类 --&gt;&lt;property name=\"entity\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.entity\"/&gt;&lt;!-- Mybatis 实体类对应的 Xml 文件 --&gt;&lt;property name=\"mapperXml\" folder=\"$&#123;basedir&#125;/src/main/resources\" package=\"$&#123;basePackage&#125;.mapper\"/&gt;&lt;!-- Dao 接口 --&gt;&lt;property name=\"dao\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.dao\"/&gt;&lt;!-- Dao 实现类 --&gt;&lt;property name=\"daoImpl\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.dao.impl\"/&gt;&lt;!-- Service 接口 --&gt;&lt;property name=\"service\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.service\"/&gt;&lt;!-- Service 实现类 --&gt;&lt;property name=\"serviceImpl\" folder=\"$&#123;basedir&#125;/src/main/java\" package=\"$&#123;basePackage&#125;.service.impl\"/&gt;&lt;!-- 每次生成时总是覆盖输出 --&gt;&lt;property name=\"overwrite\"&gt; &lt;value&gt;none&lt;/value&gt;&lt;/property&gt; ${basedir} 表示当前项目的路径。 参数 描述 folder 模板文件输出到的目录路径 package 模板文件使用的包名 overwrite 可以指定哪些模板文件强制重新生成输出。例: 只重新生成 user_info 表相关的文件 UserInfo*例: 只重新生成 user_info 表 XML 文件 UserInfo*.xml 生成模板文件maven 命令1mvn exec:java -Dexec.mainClass=MyBatisTemplateGenerator -Dexec.classpathScope=test Java 方法调用123public static void main(String[] args) &#123; org.fanlychie.mybatis.template.Generator.generate();&#125; 使用引入测试依赖包: 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 以 user 用户表为例: 模板文件除常规文件生成外代码生成器还会为每一个表生成对应的 Criteria 类，用于 SQL 条件操作，例: user 表 -&gt; UserCriteria。 Criteria 类拥有和实体类一致的 set 方法，不同的是 Criteria 类的 set 方法的参数接收的是 Criterion 对象，Criterion 对象通过 Value 静态方法来构建，见下文。 日志设置输出 SQL 语句 ( com.domain 替换成你自己的包名 ) : 1log4j.logger.com.domain.dao = DEBUG 保存数据12345678910111213141516171819202122232425262728293031import com.domain.entity.User;import com.domain.service.UserService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.Date;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"/spring-context.xml\")public class UserTest &#123; @Autowired private UserService userService; @Test public void testSave() &#123; User user = new User(); user.setName(\"张三\"); user.setAge(23); user.setSalary(8600F); user.setProvince(\"广东\"); user.setCity(\"广州\"); user.setArea(\"天河区\"); user.setCreateTime(new Date()); // 保存数据 Integer id = userService.save(user); &#125;&#125; 单元测试: 123DEBUG [save:145] - ==&gt; Preparing: INSERT INTO USER ( ID, NAME, AGE, SALARY, PROVINCE, CITY, AREA, CREATE_TIME ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? ) DEBUG [save:145] - ==&gt; Parameters: null, 张三(String), 23(Integer), 8600.0(Float), 广东(String), 广州(String), 天河区(String), 2017-02-04 17:33:09.373(Timestamp)DEBUG [save:145] - &lt;== Updates: 1 更新数据根据主键更新12345678@Testpublic void testUpdate() &#123; User user = new User(); user.setId(21); user.setName(\"张三丰\"); // 根据主键更新数据 boolean result = userService.update(user);&#125; 单元测试: 123DEBUG [update:145] - ==&gt; Preparing: UPDATE USER SET NAME = ? WHERE id = ? DEBUG [update:145] - ==&gt; Parameters: 张三丰(String), 21(Integer)DEBUG [update:145] - &lt;== Updates: 1 根据条件更新123456789101112@Testpublic void testUpdate() &#123; User user = new User(); // 期望更新用户的薪资 user.setSalary(9000F); // 条件对象 UserCriteria criteria = new UserCriteria(); // 姓名等于张三丰的用户 criteria.setName(Value.eq(\"张三丰\")); // 根据条件更新数据 int result = userService.update(user, criteria);&#125; 单元测试: 123DEBUG [update:145] - ==&gt; Preparing: UPDATE USER SET SALARY = ? WHERE name = ? DEBUG [update:145] - ==&gt; Parameters: 9000.0(Float), 张三丰(String)DEBUG [update:145] - &lt;== Updates: 1 删除数据根据主键删除12345@Testpublic void testDelete() &#123; // 根据主键删除数据 boolean result = userService.delete(21);&#125; 单元测试: 123DEBUG [delete:145] - ==&gt; Preparing: DELETE FROM USER WHERE id = ? DEBUG [delete:145] - ==&gt; Parameters: 21(Integer)DEBUG [delete:145] - &lt;== Updates: 1 根据条件删除123456789@Testpublic void testDelete() &#123; // 条件对象 UserCriteria criteria = new UserCriteria(); // 年龄大于 30 的用户 criteria.setAge(Value.gt(30)); // 根据条件删除数据 int result = userService.delete(criteria);&#125; 单元测试: 123DEBUG [delete:145] - ==&gt; Preparing: DELETE FROM USER WHERE age &gt; ? DEBUG [delete:145] - ==&gt; Parameters: 30(Integer)DEBUG [delete:145] - &lt;== Updates: 2 查询数据查询全部1234567@Testpublic void testSelect() &#123; List&lt;User&gt; user = userService.selectAll(); for (User u : user) &#123; System.out.println(u.getName()); &#125;&#125; 单元测试: 123DEBUG [selectList:145] - ==&gt; Preparing: SELECT * FROM USER DEBUG [selectList:145] - ==&gt; Parameters: DEBUG [selectList:145] - &lt;== Total: 18 主键查询1234@Testpublic void testSelect() &#123; User user = userService.selectOne(8);&#125; 单元测试: 123DEBUG [selectList:145] - ==&gt; Preparing: SELECT * FROM USER WHERE id = ? DEBUG [selectList:145] - ==&gt; Parameters: 8(Integer)DEBUG [selectList:145] - &lt;== Total: 1 条件查询唯一记录12345678910@Testpublic void testSelect() &#123; UserCriteria criteria = new UserCriteria(); // 年龄大于 20 criteria.setAge(Value.gt(20)); // 用户名为 \"用户08\" criteria.setName(Value.eq(\"用户08\")); // 条件查询, 需确保数据是唯一的 User user = userService.selectOne(criteria);&#125; 单元测试: 123DEBUG [selectList:145] - ==&gt; Preparing: SELECT * FROM USER WHERE age &gt; ? AND name = ? DEBUG [selectList:145] - ==&gt; Parameters: 20(Integer), 用户08(String)DEBUG [selectList:145] - &lt;== Total: 1 列表查询123456789@Testpublic void testSelect() &#123; // 条件对象 UserCriteria criteria = new UserCriteria(); // 年龄小于 25 criteria.setAge(Value.lt(25)); // 查询列表 List&lt;User&gt; users = userService.selectList(criteria);&#125; 单元测试: 123DEBUG [selectList:145] - ==&gt; Preparing: SELECT * FROM USER WHERE age &lt; ? DEBUG [selectList:145] - ==&gt; Parameters: 25(Integer)DEBUG [selectList:145] - &lt;== Total: 7 查询条数123456789@Testpublic void testSelect() &#123; // 条件对象 UserCriteria criteria = new UserCriteria(); // 年龄小于 25 criteria.setAge(Value.lt(25)); // 查询总条数 long counts = userService.selectCount(criteria);&#125; 单元测试: 123DEBUG [selectCount:145] - ==&gt; Preparing: SELECT COUNT(1) FROM USER WHERE age &lt; ? DEBUG [selectCount:145] - ==&gt; Parameters: 25(Integer)DEBUG [selectCount:145] - &lt;== Total: 1 分页查询bootstrap 插件分页12345678910111213141516@Testpublic void testSelect() &#123; // 分页对象 Pagination pagination = new Pagination(); // 条件对象, 根据情况设置 SQL 条件, 此处不设 UserCriteria criteria = new UserCriteria(); // 分页查询, 无需提供任何参数, 极简分页 pagination = userService.selectPage(criteria, pagination); // 查询结果总条数 System.out.println(pagination.getTotal()); // 查询的结果集 for (Object row : pagination.getRows()) &#123; User user = (User) row; System.out.println(user.getName() + \" - ¥\" + user.getSalary()); &#125;&#125; 单元测试: 1234567DEBUG [selectCount:145] - ==&gt; Preparing: SELECT COUNT(1) FROM USER DEBUG [selectCount:145] - ==&gt; Parameters: DEBUG [selectCount:145] - &lt;== Total: 1DEBUG [selectList:145] - ==&gt; Preparing: SELECT * FROM USER LIMIT ?, ? DEBUG [selectList:145] - ==&gt; Parameters: 0(Integer), 10(Integer)DEBUG [selectList:145] - &lt;== Total: 10 bootstrap 插件分页 Pagination 参数说明表: 参数 是否必须 描述 rows 否 分页结果集合, 返回字段, 无需设值 total 否 查询结果总条数, 返回字段, 无需设值 limit 否 每页显示的条数, 默认 10 offset 否 查询的起始索引值, 默认 0 sort 否 排序字段的名称 order 否 排序的关键字 search 否 搜索的关键字 field 否 搜索字段名称, bootstrap 分页插件不发送此参数, 如果有需要, 需手工设置, 建议不使用此参数 普通分页12345678910111213141516171819202122232425262728@Testpublic void testSelect() &#123; // 分页对象 Pagination pagination = new Pagination(); // 设置第一页, 普通分页必设 pagination.setPage(1); // 条件对象 UserCriteria criteria = new UserCriteria(); // 薪资升序排序 criteria.setSalary(Value.orderBy(OrderBy.ASC)); // 薪资相同则按年龄升序排序 criteria.setAge(Value.orderBy(OrderBy.ASC)); // 分页查询, 无需提供任何参数, 极简分页 pagination = userService.selectPage(criteria, pagination); // 查询结果总条数 System.out.println(\"查询结果总条数: \" + pagination.getTotal()); // 查询结果总页数 System.out.println(\"查询结果总页数: \" + pagination.getPages()); // 上一页的页码 System.out.println(\"上一页的页码: \" + pagination.getPrev()); // 下一页的页码 System.out.println(\"下一页的页码: \" + pagination.getNext()); // 查询的结果集 for (Object row : pagination.getRows()) &#123; User user = (User) row; System.out.println(user.getName() + \" \" + user.getAge() + \" - ¥\" + user.getSalary()); &#125;&#125; 单元测试: 1234567DEBUG [selectCount:145] - ==&gt; Preparing: SELECT COUNT(1) FROM USER DEBUG [selectCount:145] - ==&gt; Parameters: DEBUG [selectCount:145] - &lt;== Total: 1DEBUG [selectList:145] - ==&gt; Preparing: SELECT * FROM USER ORDER BY salary ASC , age ASC LIMIT ?, ? DEBUG [selectList:145] - ==&gt; Parameters: 0(Integer), 10(Integer)DEBUG [selectList:145] - &lt;== Total: 10 bootstrap 插件分页 Pagination 参数说明表: 参数 是否必须 描述 rows 否 分页结果集合, 返回字段, 无需设值 total 否 查询结果总条数, 返回字段, 无需设值 limit 否 每页显示的条数, 默认 10 offset 否 查询的起始索引值, 默认 0 sort 否 排序字段的名称 order 否 排序的关键字 search 否 搜索的关键字 field 否 搜索字段名称 page 是 当前请求的页码, 页码从 1 开始 prev 否 上一页的页码, 返回字段, 无需设值 next 否 下一页的页码, 返回字段, 无需设值 pages 否 查询结果总页数, 返回字段, 无需设值 逻辑操作多个 Criterion 条件默认是 AND 逻辑: 1234567891011@Testpublic void testSelect() &#123; // 条件对象 UserCriteria criteria = new UserCriteria(); // 年龄小于 28 criteria.setAge(Value.lt(28)); // 薪资高于 8000 criteria.setSalary(Value.gt(8000)); // 查询结果 List&lt;User&gt; users = userService.selectList(criteria);&#125; 单元测试: 123DEBUG [selectList:145] - ==&gt; Preparing: SELECT * FROM USER WHERE age &lt; ? AND salary &gt; ? DEBUG [selectList:145] - ==&gt; Parameters: 28(Integer), 8000(Integer)DEBUG [selectList:145] - &lt;== Total: 4 支持简单的 OR 逻辑: 123456789@Testpublic void testSelect() &#123; // 条件对象 UserCriteria criteria = new UserCriteria(); // 年龄小于 28 或 薪资高于 12000 criteria.setAge(Value.lt(28)).or(criteria.setSalary(Value.gt(12000))); // 查询结果 List&lt;User&gt; users = userService.selectList(criteria);&#125; 单元测试: 123DEBUG [selectList:145] - ==&gt; Preparing: SELECT * FROM USER WHERE age &lt; ? OR salary &gt; ? DEBUG [selectList:145] - ==&gt; Parameters: 28(Integer), 12000(Integer)DEBUG [selectList:145] - &lt;== Total: 15","tags":[{"name":"开发工具包","slug":"开发工具包","permalink":"http://yoursite.com/tags/开发工具包/"}]},{"title":"commons-httpclient 帮助文档","date":"2017-01-28T02:40:33.000Z","path":"post/commons-httpclient-document.html","text":"获取依赖12345678910111213141516&lt;!-- 仓库地址 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;github-maven-repo&lt;/id&gt; &lt;url&gt;https://raw.github.com/fanlychie/maven-repo/releases&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;dependencies&gt; &lt;!-- 声明依赖，版本信息参考：https://github.com/fanlychie/commons-httpclient/releases --&gt; &lt;dependency&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;commons-httpclient&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 环境要求JDK1.8 或以上版本 项目地址https://github.com/fanlychie/commons-httpclient GET 请求12345678910// HTTP URI GET 请求HttpClientUtils.get(\"http://huaban.com/search/\") // 请求参数 .addParameter(\"q\", \"2017\") // 请求参数 .addParameter(\"sort\", \"created_at\") // 执行请求 .execute((statusCode, responseText) -&gt; &#123; // do something &#125;); 参数 类型 描述 statusCode int 响应的状态码值 responseText string 响应的文本内容 完整示例 ( GET/PUT/POST/DELETE 拥有同样的配置项 ) 12345678910111213141516171819202122// HTTP URI GET 请求HttpClientUtils.get(\"http://huaban.com/search/\") // 请求参数 .addParameter(\"q\", \"2017\") // 请求参数 .addParameter(\"sort\", \"created_at\") // 请求头参数 .addHeader(\"arg\", \"value\") // 设置响应内容编码, 默认 UTF-8 .setContentEncoding(\"UTF-8\") // 设置连接超时时间, 默认30秒 .setConnectTimeout(30 * 1000) // 设置读取超时时间, 默认3分钟 .setReadTimeout(3 * 60 * 1000) // 设置失败重试次数, 默认3次 .setRetryTimes(3) // 设置 HTTP 代理, HTTPS 代理通过 setHttpsProxy 设置 .setHttpProxy(\"116.226.136.135\", 8118) // 执行请求 .execute((statusCode, responseText) -&gt; &#123; // do something &#125;); DELETE 请求12345678910// HTTP URI DELETE 请求HttpClientUtils.delete(\"http://domain.com\") // 请求参数 .addParameter(\"arg1\", \"value1\") // 请求参数 .addParameter(\"arg2\", \"value2\") // 执行请求 .execute((statusCode, responseText) -&gt; &#123; // do something &#125;); POST 请求普通表单提交键值对参数： 12345678910// HTTP 普通表单 POST 请求HttpClientUtils.post(\"http://domain.com\") // 请求参数 .addParameter(\"arg1\", \"value1\") // 请求参数 .addParameter(\"arg2\", \"value2\") // 执行请求 .execute((statusCode, responseText) -&gt; &#123; // do something &#125;); JSON 参数： 12345678// HTTP 普通表单 POST 请求HttpClientUtils.post(\"http://domain.com\") // JSON 请求参数 .addJSONParameter(\"&#123;\\\"arg1\\\":\\\"value1\\\",\\\"arg2\\\":\\\"value2\\\"&#125;\") // 执行请求 .execute((statusCode, responseText) -&gt; &#123; // do something &#125;); 文件上传表单123456789101112// HTTP 文件上传表单 POST 请求HttpClientUtils.postMultipartForm(\"http://domain.com\") // 普通参数 .addParameter(\"arg1\", \"value1\") // 普通参数 .addParameter(\"arg2\", \"value2\") // 文件参数, 或输入流参数 .addParameter(\"file\", new File(\"pom.xml\")) // 执行请求 .execute((statusCode, responseText) -&gt; &#123; // do something &#125;); PUT 请求普通表单提交键值对参数： 12345678910// HTTP 普通表单 PUT 请求HttpClientUtils.put(\"http://domain.com\") // 请求参数 .addParameter(\"arg1\", \"value1\") // 请求参数 .addParameter(\"arg2\", \"value2\") // 执行请求 .execute((statusCode, responseText) -&gt; &#123; // do something &#125;); JSON 参数： 12345678// HTTP 普通表单 PUT 请求HttpClientUtils.put(\"http://domain.com\") // JSON 请求参数 .addJSONParameter(\"&#123;\\\"arg1\\\":\\\"value1\\\",\\\"arg2\\\":\\\"value2\\\"&#125;\") // 执行请求 .execute((statusCode, responseText) -&gt; &#123; // do something &#125;); 文件上传表单123456789101112// HTTP 文件上传表单 PUT 请求HttpClientUtils.putMultipartForm(\"http://domain.com\") // 普通参数 .addParameter(\"arg1\", \"value1\") // 普通参数 .addParameter(\"arg2\", \"value2\") // 文件参数, 或输入流参数 .addParameter(\"file\", new File(\"pom.xml\")) // 执行请求 .execute((statusCode, responseText) -&gt; &#123; // do something &#125;); 调试日志1log4j.logger.org.fanlychie.commons.httpclient = DEBUG","tags":[{"name":"开发工具包","slug":"开发工具包","permalink":"http://yoursite.com/tags/开发工具包/"}]},{"title":"commons-jsp-tag 帮助文档","date":"2017-01-25T17:06:37.000Z","path":"post/commons-jsp-tag-document.html","text":"获取依赖12345678910111213141516&lt;!-- 仓库地址 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;github-maven-repo&lt;/id&gt; &lt;url&gt;https://raw.github.com/fanlychie/maven-repo/releases&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;dependencies&gt; &lt;!-- 声明依赖，版本信息参考：https://github.com/fanlychie/commons-jsp-tag/releases --&gt; &lt;dependency&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;commons-jsp-tag&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 环境要求JDK1.7 或以上版本 项目地址https://github.com/fanlychie/commons-jsp-tag 引入标签库1&lt;%@ taglib prefix=\"f\" uri=\"http://fanlychie.org/tags/function\" %&gt; resource 标签此标签用于表示 web 项目中 webapp 目录下的资源文件。 12345678// 脚本资源&lt;script src='&lt;f:resource path=\"/statics/js/index.js\"/&gt;'&gt;&lt;/script&gt;// 样式资源&lt;link href='&lt;f:resource path=\"/statics/css/index.css\"/&gt;' rel=\"stylesheet\" type=\"text/css\"&gt;// 图片资源&lt;img src='&lt;f:resource path=\"/statics/images/logo.png\"/&gt;' /&gt; 资源文件版本默认每次服务重新启动时，资源标签输出一个新的版本，强制客户端刷新资源文件，避免客户端缓存旧版的文件资源。如要自行控制管理资源文件，可在 Spring 配置文件中添加如下代码： 12&lt;!-- 引入 p 命名空间 xmlns:p=\"http://www.springframework.org/schema/p\" --&gt;&lt;bean class=\"org.fanlychie.commons.jsp.tag.WebappResourceTagConfig\" p:version=\"1.0\"/&gt; url 标签此标签用于表示链接地址，可以是 http 或 https 的绝对地址，也可以是相对于项目的相对地址： 12345// 绝对地址，输出 http://www.baidu.com&lt;f:url href=\"http://www.baidu.com\" /&gt;// 相对地址，输出 /项目名/user/home&lt;f:url href=\"/user/home\" /&gt; date 标签此标签用于将 java.util.Date 对象转成字符串内容： 1234567891011// 日期，输出 2017-01-26&lt;f:date value=\"$&#123;now&#125;\" type=\"date\" /&gt;// 时间，输出 01:41:41&lt;f:date value=\"$&#123;now&#125;\" type=\"time\" /&gt;// 日期时间，输出 2017-01-26 01:41:41&lt;f:date value=\"$&#123;now&#125;\" type=\"datetime\" /&gt;// 自定义模式串，输出 2017/01/26 01:41:41:236&lt;f:date value=\"$&#123;now&#125;\" pattern=\"yyyy/MM/dd HH:mm:ss:SSS\" /&gt;","tags":[{"name":"开发工具包","slug":"开发工具包","permalink":"http://yoursite.com/tags/开发工具包/"}]},{"title":"commons-file 帮助文档","date":"2017-01-15T14:06:03.000Z","path":"post/commons-file-api.html","text":"获取依赖12345678910111213141516&lt;!-- 仓库地址 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;github-maven-repo&lt;/id&gt; &lt;url&gt;https://raw.github.com/fanlychie/maven-repo/releases&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;dependencies&gt; &lt;!-- 声明依赖，版本信息参考：https://github.com/fanlychie/commons-file/releases --&gt; &lt;dependency&gt; &lt;groupId&gt;org.fanlychie&lt;/groupId&gt; &lt;artifactId&gt;commons-file&lt;/artifactId&gt; &lt;version&gt;1.0.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 环境要求JDK1.8 或以上版本 项目地址https://github.com/fanlychie/commons-file 读取文件12345678910// 读取当前项目下的 pom.xml 文件的内容String content = FileUtils.readFileAsString(\"pom.xml\");// 读取到 List 容器，容器的每个元素代表文件的一行List&lt;String&gt; list = FileUtils.readFileAsListOfString(\"pom.xml\");// 按行读取FileUtils.readFileLineByLine(\"pom.xml\", line -&gt; &#123; System.out.println(line);&#125;); 写出文件文本内容12345// 将字符串内容写出到 readme.txt 文件，若文件不存在则自动创建此文件，若文件已经存在则覆盖此文件FileUtils.writeFile(\"readme.txt\", \"Hello, World!\");// 将字符串内容追加到 readme.txt 文件FileUtils.appendFile(\"readme.txt\", \"\\n你好，世界！\"); 文件拷贝123456789// 拷贝到文件// 将 readme.txt 文件拷贝到 readme2.txt 文件// 若 readme2.txt 文件尚未存在，则创建 readme2.txt 文件// 若 readme2.txt 文件已经存在，则将 readme.txt 文件内容覆盖 readme2.txt 文件内容FileUtils.copyFile(\"readme.txt\", \"readme2.txt\");// 拷贝到目录// 将 readme.txt 文件拷贝到当前项目的 readme 目录中，此目录必须已经存在，否则抛出异常FileUtils.copyFileToDirectory(\"readme.txt\", \"readme\"); Base64 图片文件编码图片文件1234567// Base64 编码 URL 图片，将编码后的字符串内容置于 &lt;img /&gt; 标签的 src 属性中即可展示此图片// 此方式将图片转成字符串，可减少 HTTP 请求，适合小图片，大图片会导致字符串内容过大加载变慢// 如下图可 F12 查看 src 属性值String str = FileUtils.encodeImageUrlBase64(\"http://www.qncye.com/buttom/images/hk06.jpg\");// 编码项目下的 logo.png 图片文件String str = FileUtils.encodeImageFileBase64(\"logo.png\"); 解码图片文件123456789// 编码后的图片文件字符串内容String base64ImageStr = \"data:image/jpeg;base64,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\";// 解码到目录// 将图片解码到项目根目录下的 readme 目录中，使用随机串作为图片的文件名File img = FileUtils.decodeBase64ImageStrToDirectory(\"readme\", base64ImageStr);// 解码到目录，并指定图片的文件名File img = FileUtils.decodeBase64ImageStrToDirectory(\"readme\", \"2017.jpg\", base64ImageStr); URL 文件12345678910111213141516171819// 获取 URL 输入流InputStream is = FileUtils.openUrlFile(\"http://www.qncye.com/buttom/images/hk06.jpg\").getInputStream();// 下载到文件FileUtils.openUrlFile(\"http://www.qncye.com/buttom/images/hk06.jpg\").writeToFile(\"readme/2017_1.jpg\");// 下载到目录FileUtils.openUrlFile(\"http://www.qncye.com/buttom/images/hk06.jpg\").writeToDirectory(\"readme\");// 读取文本内容String str = FileUtils.openUrlFile(\"https://www.duitang.com\").readString();// 配置项String str = FileUtils.openUrlFile(\"https://www.duitang.com\") // 设置连接超时时间, 默认为 30秒 .setConnectTimeout(30 * 1000) // 设置读取超时时间, 默认为 3分钟 .setReadTimeout(3 * 60 * 1000) .readString(); 文件下载1234567891011// 提供任意文件下载@RequestMapping(\"/download\")public void downloadFile(HttpServletResponse response) &#123; FileUtils.provideFileDownload(response, new File(\"readme.txt\"));&#125;// 提供任意文件下载，并指定下载的文件名称@RequestMapping(\"/download\")public void downloadFile(HttpServletResponse response) &#123; FileUtils.provideFileDownload(response, new File(\"readme.txt\"), \"读我.txt\");&#125; 本地文件本地文件上传在项目的 web.xml 中添加如下配置： 123456789&lt;servlet&gt; &lt;servlet-name&gt;LocalFileUploadServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.fanlychie.commons.file.web.LocalFileUploadServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;LocalFileUploadServlet&lt;/servlet-name&gt; &lt;!-- 配置本地文件上传的 URL --&gt; &lt;url-pattern&gt;/files/upload&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在 JSP 文件中添加如下代码 ( 以下代码仅做示例用 )： 123456789101112131415161718192021222324252627&lt;!-- JQuery JS --&gt;&lt;script src=\"//cdn.bootcss.com/jquery/2.2.4/jquery.min.js\"&gt;&lt;/script&gt;&lt;!-- JQuery 表单异步提交组件 --&gt;&lt;script src=\"//cdn.bootcss.com/jquery.form/3.51/jquery.form.min.js\"&gt;&lt;/script&gt;&lt;!-- 文件上传表单, 支持多文件上传 --&gt;&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/files/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;!-- 拷贝多个此节点即可上传多个文件 --&gt; &lt;input type=\"file\" name=\"file\"&gt;&lt;/form&gt;&lt;button&gt;提交&lt;/button&gt;&lt;script&gt; $('button').click(function () &#123; $('form').ajaxSubmit(&#123; dataType: 'json', success: function (result) &#123; console.log(result); if (result.healthy) &#123; alert('本地文件上传成功，Key : ' + result.fileKeys[0]); &#125; else &#123; alert('本地文件上传失败，信息 : ' + result.failedMsgs[0]); &#125; &#125; &#125;); &#125;);&lt;/script&gt; 参数 类型 描述 healthy 布尔 文件上传报告是否健康，若是，表明文件上传全部成功，否则表示存在文件上传失败或空 failedNumber 整型 文件上传失败的个数 successfulNumber 整型 文件上传成功的个数 fileKeys 字符串数组 上传成功的文件 Key 列表，每个 Key 表示本地文件的地址 failedMsgs 字符串数组 文件上传失败的信息列表 可选配置项123456789101112131415161718192021222324252627&lt;servlet&gt; &lt;servlet-name&gt;LocalFileUploadServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.fanlychie.commons.file.web.LocalFileUploadServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 上传的文件最小大小, 默认0, 表示不限制 --&gt; &lt;param-name&gt;minSize&lt;/param-name&gt; &lt;!-- 1KB --&gt; &lt;param-value&gt;1024&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!-- 上传的文件最大大小, 默认0, 表示不限制 --&gt; &lt;param-name&gt;maxSize&lt;/param-name&gt; &lt;!-- 100KB --&gt; &lt;param-value&gt;102400&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!-- 允许上传的文件类型 --&gt; &lt;param-name&gt;allowedFileExtensions&lt;/param-name&gt; &lt;!-- *.jpg, *.png --&gt; &lt;param-value&gt;jpg,png&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;LocalFileUploadServlet&lt;/servlet-name&gt; &lt;!-- 配置本地文件上传的 URL --&gt; &lt;url-pattern&gt;/files/upload&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 自定义文件上传在 SpringMVC 的 Controller 文件中添加如下代码 ( 以下代码仅做示例用 ) 12345678910111213141516171819202122232425262728293031323334@ResponseBody@RequestMapping(\"/files/upload2\")public FileUploadReport upload(@RequestParam(\"file\") MultipartFile[] files) &#123; // 文件上传 return FileUtils.uploadFile(files) // 设置允许上传的文件大小, 1KB ~ 100KB .setAllowedFileSize(1 * 1024, 100 * 1024) // 设置允许上传的文件类型, *.jpg, *.png .setAllowedFileExtensions(\"jpg\", \"png\") // 当上传的文件大小超出限制时, 通过此功能处理并手工完成上传作业, 处理成功返回 true, 否则需返回 false .setFileSizeSupportedFunction((inputStrean, file) -&gt; &#123; try &#123; // 保持图片比例不变压缩图片大小 Thumbnails.of(inputStrean).scale(1).outputQuality(0.8).toFile(file); return true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return false; &#125;) // 当上传的文件是不支持的文件类型时, 通过此功能处理并手工完成上传作业, 处理成功返回 true, 否则需返回 false .setFileExtensionSupportedFunction((inputStrean, file) -&gt; &#123; try &#123; // 其余文件统统转成 jpg 文件 Thumbnails.of(inputStrean).outputFormat(\"jpg\").toFile(file); return true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return false; &#125;) // 上传文件 .upload();&#125; 本地文件上传配置本地文件上传的根目录默认使用 Java IO 的目录，建议修改此路径。 在 Spring 配置文件中加入如下代码： 123&lt;!-- 本地文件上传配置 --&gt;&lt;!-- 引入 p 命名空间 xmlns:p=\"http://www.springframework.org/schema/p\" --&gt;&lt;bean class=\"org.fanlychie.commons.file.LocalFileUploadConfig\" p:storageRootFolder=\"C:/fileUplad\"/&gt; 参数 类型 描述 storageRootFolder 字符串 本地上传的文件存储根目录路径, 默认为 Java IO 目录 childFolderLength 字符串 本地上传的文件存储的子目录长度, 默认为 5 本地文件访问在项目的 web.xml 中添加如下配置： 123456789&lt;servlet&gt; &lt;servlet-name&gt;LocalFileAccessServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.fanlychie.commons.file.web.LocalFileAccessServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;LocalFileAccessServlet&lt;/servlet-name&gt; &lt;!-- 配置本地文件访问的 URL --&gt; &lt;url-pattern&gt;/files/access&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 访问示例： http://domain.com/files/access?file=df1cdb878bf44e76b9ea5a4aca7959ea 可选配置项123456789101112131415&lt;servlet&gt; &lt;servlet-name&gt;LocalFileAccessServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.fanlychie.commons.file.web.LocalFileAccessServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 本地文件 Key 参数名称 --&gt; &lt;param-name&gt;fileKeyParameter&lt;/param-name&gt; &lt;!-- 默认参数名为 file, 值即为本地文件上传返回的 Key 字符串 --&gt; &lt;param-value&gt;key&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;LocalFileAccessServlet&lt;/servlet-name&gt; &lt;!-- 配置本地文件访问的 URL --&gt; &lt;url-pattern&gt;/files/access&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 访问示例： http://domain.com/files/access?key=df1cdb878bf44e76b9ea5a4aca7959ea 自定义文件访问在 SpringMVC 的 Controller 文件中添加如下代码 ( 以下代码仅做示例用 ) 1234@RequestMapping(\"/files/access2\")public void access(HttpServletResponse response, String fileKey) &#123; FileUtils.accessLocalFile(response, fileKey);&#125; http://domain.com/files/access2?fileKey=df1cdb878bf44e76b9ea5a4aca7959ea 本地文件下载在项目的 web.xml 中添加如下配置： 123456789&lt;servlet&gt; &lt;servlet-name&gt;LocalFileDownloadServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.fanlychie.commons.file.web.LocalFileDownloadServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;LocalFileDownloadServlet&lt;/servlet-name&gt; &lt;!-- 配置本地文件下载的 URL --&gt; &lt;url-pattern&gt;/files/download&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 访问示例： http://domain.com/files/download?file=df1cdb878bf44e76b9ea5a4aca7959ea 或： http://domain.com/files/download?file=df1cdb878bf44e76b9ea5a4aca7959ea&amp;name=示例文件 可选配置项123456789101112131415161718192021&lt;servlet&gt; &lt;servlet-name&gt;LocalFileDownloadServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.fanlychie.commons.file.web.LocalFileDownloadServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 文件 Key 参数的名称 --&gt; &lt;param-name&gt;fileKeyParameter&lt;/param-name&gt; &lt;!-- 默认参数名为 file, 值即为本地文件上传返回的 Key 字符串 --&gt; &lt;param-value&gt;key&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!-- 文件名参数名称, 供下载时使用 --&gt; &lt;param-name&gt;fileNameParameter&lt;/param-name&gt; &lt;!-- 默认参数名为 name, 缺省值为原文件名称 --&gt; &lt;param-value&gt;filename&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;LocalFileDownloadServlet&lt;/servlet-name&gt; &lt;!-- 配置本地文件下载的 URL --&gt; &lt;url-pattern&gt;/files/download&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 访问示例： http://domain.com/files/download?key=df1cdb878bf44e76b9ea5a4aca7959ea 或： http://domain.com/files/download?key=df1cdb878bf44e76b9ea5a4aca7959ea&amp;filename=示例文件 其他1234567891011121314151617181920212223// 创建本地文件对象LocalFile localFile = FileUtils.createLocalFile(\"jpg\");// 获取 classpath 下的资源文件File file = FileUtils.getClassPathFile(\"spring-mvc.xml\");// 获取 classpath 下的资源文件流InputStream is = FileUtils.getClassPathFileStream(\"spring-mvc.xml\");// 获取文件扩展名, 输出 txtString extension = FileUtils.getFileExtension(\"readme.txt\");// 获取文件大小字符串，输出 100KBString size = FileUtils.getFileSize(102401);// 获取本地文件File src = FileUtils.getLocalFile(\"df1cdb878bf44e76b9ea5a4aca7959ea\");// 获取 URL 文件名称, 输出 hk06.jpgString filename = FileUtils.getUrlFileName(\"http://www.qncye.com/buttom/images/hk06.jpg\");// 获取 URL 文件扩展名, 输出 jpgString fileExtension = FileUtils.getUrlFileExtension(\"http://www.qncye.com/buttom/images/hk06.jpg\"); 调试日志1log4j.logger.org.fanlychie.commons.file.web = DEBUG","tags":[{"name":"开发工具包","slug":"开发工具包","permalink":"http://yoursite.com/tags/开发工具包/"}]},{"title":"CAS 实现 SSO 单点登录","date":"2016-10-24T16:47:29.000Z","path":"post/java-cas-server-client-configure.html","text":"环境 cas-server-4.1.8，cas-client-3.4.0，Java-8，Maven-3，Tomcat-7.0.72 CAS Server 安装 点此进入 CAS 下载列表，选择下载 cas-4.1.8.zip。 解压缩 cas-4.1.8.zip 并进入 cas-server-webapp 目录，在当前目录打开 cmd 并执行安装命令 1mvn -e -ff clean install -Dmaven.test.skip=true 经亲身测试（自己拉的电信12M网络），该安装过程非常漫长，主要因为镜像原因导致依赖包下载非常慢，此过程需静心等待。或直接下载我已经打好包的 cas.war 文件（注：该文件的依赖包版本有稍做修改，此不影响正常使用）。 安装完成后，在 cas-server-webapp/target 目录下可以看到 cas.war 文件，该文件便是 cas server 应用服务的 war 包。 cas server 安全认证是基于 https 的，这里使用 JDK 自带的 keytool 工具生成数字证书，生产环境系统的应用需要到证书提供商处购买证书。证书的生成及 Tomcat 的配置可参考文章：keytool 生成数字证书 - tomcat https 配置 。 首先确保 tomcat 的 https 可以正常访问，将 cas.war 文件拷贝到 apache-tomcat-7.0.72/webapps 下进行发布，启动 tomcat，访问 https://www.fanlychie.com:8443/cas 上图是用火狐浏览器打开的链接，选择高级 -&gt; 添加例外 -&gt; 确认安全例外 用户名和密码在 apache-tomcat-7.0.72/webapps/cas/WEB-INF/deployerConfigContext.xml 配置文件中，找到并打开该文件，大概在 105 行 12345678&lt;bean id=\"primaryAuthenticationHandler\" class=\"org.jasig.cas.authentication.AcceptUsersAuthenticationHandler\"&gt; &lt;property name=\"users\"&gt; &lt;map&gt; &lt;entry key=\"casuser\" value=\"Mellon\" /&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 可以看到默认的用户名是 casuser，密码是 Mellon。 看到上图的页面，表明 cas server 已经部署成功。 CAS Server 配置基于数据库用户认证 回到 cas-4.1.8.zip 解压缩的目录，并进入 cas-server-support-jdbc 目录，在当前目录打开 cmd 并执行安装命令 1mvn -e -ff clean install -Dmaven.test.skip=true 安装完成后在 target 目录得到 cas-server-support-jdbc-4.1.8.jar 文件。 将该文件拷贝到 apache-tomcat-7.0.72/webapps/cas/WEB-INF/lib 目录下，并向此目录添加 c3p0-0.9.1.2.jar，mysql-connector-java-5.1.17.jar 两个文件。嫌麻烦的话，点此下载这三个 jar 包的压缩包文件。 再次打开 apache-tomcat-7.0.72/webapps/cas/WEB-INF/deployerConfigContext.xml 文件，大概在第 54 行 12345678910111213141516171819202122232425262728293031323334353637&lt;bean id=\"authenticationManager\" class=\"org.jasig.cas.authentication.PolicyBasedAuthenticationManager\"&gt; &lt;constructor-arg&gt; &lt;map&gt; &lt;!-- | IMPORTANT | Every handler requires a unique name. | If more than one instance of the same handler class is configured, you must explicitly | set its name to something other than its default name (typically the simple class name). --&gt; &lt;entry key-ref=\"proxyAuthenticationHandler\" value-ref=\"proxyPrincipalResolver\" /&gt; &lt;!-- 注销此项 &lt;entry key-ref=\"primaryAuthenticationHandler\" value-ref=\"primaryPrincipalResolver\" /&gt; --&gt; &lt;!-- 添加此项 --&gt; &lt;entry key-ref=\"myAuthenticationHandler\" value-ref=\"primaryPrincipalResolver\" /&gt; &lt;/map&gt; &lt;/constructor-arg&gt; &lt;!-- Uncomment the metadata populator to capture the password. &lt;property name=\"authenticationMetaDataPopulators\"&gt; &lt;util:list&gt; &lt;bean class=\"org.jasig.cas.authentication.CacheCredentialsMetaDataPopulator\"/&gt; &lt;/util:list&gt; &lt;/property&gt; --&gt; &lt;!-- | Defines the security policy around authentication. Some alternative policies that ship with CAS: | | * NotPreventedAuthenticationPolicy - all credential must either pass or fail authentication | * AllAuthenticationPolicy - all presented credential must be authenticated successfully | * RequiredHandlerAuthenticationPolicy - specifies a handler that must authenticate its credential to pass --&gt; &lt;property name=\"authenticationPolicy\"&gt; &lt;bean class=\"org.jasig.cas.authentication.AnyAuthenticationPolicy\" /&gt; &lt;/property&gt;&lt;/bean&gt; 按以上配置注销掉第二个 entry 并添加一个 entry。接着在后面添加两个 bean 配置 1234567891011121314151617181920&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" destroy-method=\"close\"&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://127.0.0.1:3306/cas_test_db?autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8\" /&gt; &lt;property name=\"user\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"root\" /&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"initialPoolSize\" value=\"10\" /&gt; &lt;property name=\"maxIdleTime\" value=\"1800\" /&gt; &lt;property name=\"maxPoolSize\" value=\"60\" /&gt; &lt;property name=\"acquireIncrement\" value=\"5\" /&gt; &lt;property name=\"acquireRetryAttempts\" value=\"60\" /&gt; &lt;property name=\"acquireRetryDelay\" value=\"2000\" /&gt; &lt;property name=\"breakAfterAcquireFailure\" value=\"false\" /&gt; &lt;property name=\"autoCommitOnClose\" value=\"false\" /&gt; &lt;property name=\"checkoutTimeout\" value=\"30000\" /&gt; &lt;property name=\"idleConnectionTestPeriod\" value=\"900\" /&gt;&lt;/bean&gt;&lt;bean id=\"myAuthenticationHandler\" class=\"org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler\" p:dataSource-ref=\"dataSource\" p:sql=\"SELECT passwd FROM user WHERE name = ?\" /&gt; 其中 cas_test_db 数据库中的 user 建表语句为 123456CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, `passwd` varchar(255) NOT NULL, PRIMARY KEY (`id`)) 重启 tomcat，访问 https://www.fanlychie.com:8443/cas，用数据库中的 name/passwd 作为用户名和密码登录系统，若登录成功，表明配置已成功。 CAS Client 客户端使用和配置 使用 maven 创建两个 web 项目 cas-client1，cas-client2。点此下载 demo 文件。 cas-client1 项目 pom.xml 配置 123456789101112131415161718192021222324252627282930313233&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jasig.cas.client&lt;/groupId&gt; &lt;artifactId&gt;cas-client-core&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/&lt;/path&gt; &lt;port&gt;8881&lt;/port&gt; &lt;httpsPort&gt;8081&lt;/httpsPort&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;protocol&gt;org.apache.coyote.http11.Http11NioProtocol&lt;/protocol&gt; &lt;clientAuth&gt;false&lt;/clientAuth&gt; &lt;keystoreFile&gt;C:\\Users\\fanlychie\\.keystore\\selfissue.jks&lt;/keystoreFile&gt; &lt;keystorePass&gt;123654&lt;/keystorePass&gt; &lt;keystoreType&gt;JKS&lt;/keystoreType&gt; &lt;url&gt;http://localhost:8081/manager/html&lt;/url&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 首先必须确保项目 https 协议可以正常访问，否则 cas server 无法认证。 选中项目 -&gt; Run As -&gt; Maven build… -&gt; tomcat7:run 访问 https://www.fanlychie.com:8081，若能访问到，表明 tomcat 已准备好。 cas-client1 项目 web.xml 配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"&gt; &lt;listener&gt; &lt;listener-class&gt;org.jasig.cas.client.session.SingleSignOutHttpSessionListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.session.SingleSignOutFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;!-- 此处配置的是 cas server 地址 --&gt; &lt;param-value&gt;https://www.fanlychie.com:8443/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Authentication Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerLoginUrl&lt;/param-name&gt; &lt;!-- 此处配置的是 cas server 登录地址 --&gt; &lt;param-value&gt;https://www.fanlychie.com:8443/cas/login&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;!-- 此处配置的是当前项目地址, 且必须使用 https 服务, 否则 cas server 无法认证 --&gt; &lt;param-value&gt;https://www.fanlychie.com:8081&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Authentication Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;!-- 此处配置的是 cas server 地址 --&gt; &lt;param-value&gt;https://www.fanlychie.com:8443/cas&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;!-- 此处配置的是当前项目地址, 且必须使用 https 服务, 否则 cas server 无法认证 --&gt; &lt;param-value&gt;https://www.fanlychie.com:8081&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.HttpServletRequestWrapperFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.AssertionThreadLocalFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 以上是 cas client 标准配置，具体信息可参考 https://github.com/apereo/java-cas-client cas-client2 配置基本与 cas-client1 配置相同，详情可见 demo，同时启动这两个项目 cas-client1 - https://www.fanlychie.com:8081 cas-client2 - https://www.fanlychie.com:8082 访问其中的一个项目 https://www.fanlychie.com:8081，会自动跳到 https://www.fanlychie.com:8443/cas/login?service=https%3A%2F%2Fwww.fanlychie.com%3A8081%2F 由于还没有登录过 CAS 认证系统，CAS 认证系统拦截到你的访问，进入到认证系统登录界面，当登录成功后，CAS 服务会跳转向到你刚刚访问的地址。 当你访问 https://www.fanlychie.com:8082，此时是不需要登录了的 至此，CAS 实现 SSO 单点登录系统搭建结束。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"CAS","slug":"CAS","permalink":"http://yoursite.com/tags/CAS/"}]},{"title":"keytool 生成数字证书 - tomcat https 配置","date":"2016-10-24T06:36:59.000Z","path":"post/java-keytool-tomcat-https.html","text":"环境 Java8 + Tomcat7 + Windows10 生成证书 Win + R 打开 cmd，接下来使用 JDK 自带的 keytool 工具生成数字证书，首先查看命令参数 1C:\\Users\\fanlychie\\.keystore&gt;keytool -genkey -help 创建一个存放密钥库的目录，并进入此目录 12C:\\Users\\fanlychie&gt;md .keystoreC:\\Users\\fanlychie&gt;cd .keystore 生成一个密钥库文件 1C:\\Users\\fanlychie\\.keystore&gt;keytool -genkey -alias selfissue -keyalg RSA -keysize 2048 -keypass 123654 -validity 3660 -keystore selfissue.jks -storepass 123654 -alias 设定一个别名，-validity 设定证书的有效天数，-keypass 密钥口令设置和 -storepass 密钥库口令相同，-keystore 设定密钥库名称。 第一处询问 “您的名字与姓氏是什么?“，该处填写的是单点登录服务器的域名。其余项可自由填写。 执行完成后生成的密钥库文件在 C:\\Users\\fanlychie\\.keystore\\selfissue.jks 查看密钥库 1C:\\Users\\fanlychie\\.keystore&gt;keytool -list -keystore selfissue.jks 输入口令 123654 返回上层目录，创建一个存放证书的目录，并进入该目录 123C:\\Users\\fanlychie\\.keystore&gt;cd ..C:\\Users\\fanlychie&gt;md .certificateC:\\Users\\fanlychie&gt;cd .certificate 导出证书 1C:\\Users\\fanlychie\\.certificate&gt;keytool -export -alias selfissue -keystore ../.keystore/selfissue.jks -file selfissue.crt -storepass 123654 执行完成后生成的证书文件在 C:\\Users\\fanlychie\\.certificate\\selfissue.crt 客户端导入证书 1C:\\Users\\fanlychie\\.certificate&gt;keytool -import -keystore %JAVA_HOME%\\jre\\lib\\security\\cacerts -file selfissue.crt -alias selfissue 需要注意的是密钥库口令不是上面生成证书设置的密码 123654，而必须是 changeit Tomcat7 Https 配置 打开 conf/server.xml，找到 1&lt;Connector port=\"8080\" redirectPort=\"8443\" connectionTimeout=\"20000\" protocol=\"HTTP/1.1\"/&gt; 改成 12345678910&lt;Connector port=\"8443\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\" maxThreads=\"200\" SSLEnabled=\"true\" scheme=\"https\" secure=\"true\" clientAuth=\"false\" sslProtocol=\"TLS\" keystoreFile=\"C:\\Users\\fanlychie\\.keystore\\selfissue.jks\" keystorePass=\"123654\" keystoreType=\"JKS\" /&gt; 配置参数可参考 https://tomcat.apache.org/tomcat-7.0-doc/ssl-howto.html https://tomcat.apache.org/tomcat-7.0-doc/config/http.html 打开 C:\\Windows\\System32\\drivers\\etc\\hosts（以管理员身份取得该文件所有权限，否则无法编辑该文件），向该文件添加如下一行，并保存退出。 1127.0.0.1 www.fanlychie.com 启动 Tomcat，访问 https://www.fanlychie.com:8443","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}]},{"title":"Spring+MyBatis 多数据源配置和切换","date":"2016-10-22T12:21:58.000Z","path":"post/spring-mybatis-multiple-datasource.html","text":"环境 两台 MySQL 数据库（属于 master-slave 主从关系），基于 Java8，Spring4，MyBatis3.2 环境。 maven 依赖配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;4.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.1.5.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjlib&lt;/artifactId&gt; &lt;version&gt;1.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; jdbc.properties 配置 12345678910111213141516171819202122jdbc.driver = com.mysql.jdbc.Driverjdbc.key.slave = slavejdbc.username.slave = rootjdbc.password.slave = rootjdbc.url.slave = jdbc:mysql://192.168.1.104:3306/test_db?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8jdbc.key.master = masterjdbc.username.master = rootjdbc.password.master = rootjdbc.url.master = jdbc:mysql://192.168.1.102:3306/test_db?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8c3p0.initialPoolSize = 10c3p0.maxIdleTime = 1800c3p0.maxPoolSize = 60c3p0.acquireIncrement = 5c3p0.acquireRetryAttempts = 60c3p0.acquireRetryDelay = 2000c3p0.breakAfterAcquireFailure = falsec3p0.autoCommitOnClose = falsec3p0.checkoutTimeout = 30000c3p0.idleConnectionTestPeriod = 900 spring-datasources.xml 配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\"&gt; &lt;!-- aspectj 注解 --&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;context:annotation-config /&gt; &lt;context:component-scan base-package=\"org.fanlychie\" /&gt; &lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"baseDataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" destroy-method=\"close\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"initialPoolSize\" value=\"$&#123;c3p0.initialPoolSize&#125;\" /&gt; &lt;property name=\"maxIdleTime\" value=\"$&#123;c3p0.maxIdleTime&#125;\" /&gt; &lt;property name=\"maxPoolSize\" value=\"$&#123;c3p0.maxPoolSize&#125;\" /&gt; &lt;property name=\"acquireIncrement\" value=\"$&#123;c3p0.acquireIncrement&#125;\" /&gt; &lt;property name=\"acquireRetryAttempts\" value=\"$&#123;c3p0.acquireRetryAttempts&#125;\" /&gt; &lt;property name=\"acquireRetryDelay\" value=\"$&#123;c3p0.acquireRetryDelay&#125;\" /&gt; &lt;property name=\"breakAfterAcquireFailure\" value=\"$&#123;c3p0.breakAfterAcquireFailure&#125;\" /&gt; &lt;property name=\"autoCommitOnClose\" value=\"$&#123;c3p0.autoCommitOnClose&#125;\" /&gt; &lt;property name=\"checkoutTimeout\" value=\"$&#123;c3p0.checkoutTimeout&#125;\" /&gt; &lt;property name=\"idleConnectionTestPeriod\" value=\"$&#123;c3p0.idleConnectionTestPeriod&#125;\" /&gt; &lt;/bean&gt; &lt;!-- slave 从库只读数据源 --&gt; &lt;bean id=\"slaveDataSource\" parent=\"baseDataSource\"&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url.slave&#125;\" /&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username.slave&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password.slave&#125;\" /&gt; &lt;/bean&gt; &lt;!-- master 主库读写数据源(主要负责写操作) --&gt; &lt;bean id=\"masterDataSource\" parent=\"baseDataSource\"&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url.master&#125;\" /&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username.master&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password.master&#125;\" /&gt; &lt;/bean&gt; &lt;!-- 多数据源自动切换 --&gt; &lt;bean id=\"dataSource\" class=\"org.fanlychie.core.MultipleDataSource\"&gt; &lt;property name=\"targetDataSources\"&gt; &lt;map key-type=\"java.lang.String\"&gt; &lt;entry key=\"$&#123;jdbc.key.slave&#125;\" value-ref=\"slaveDataSource\" /&gt; &lt;entry key=\"$&#123;jdbc.key.master&#125;\" value-ref=\"masterDataSource\" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 默认使用的数据源 --&gt; &lt;!-- &lt;property name=\"defaultTargetDataSource\" ref=\"masterDataSource\"/&gt; --&gt; &lt;/bean&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"typeAliasesPackage\" value=\"org.fanlychie.entity\" /&gt; &lt;/bean&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"org.fanlychie.mapper\" /&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\" /&gt; &lt;/bean&gt; &lt;!-- 配置使用 slave 数据源的业务方法前缀列表 --&gt; &lt;util:list id=\"useSlaveDataSourceMethodPrefix\"&gt; &lt;value&gt;select&lt;/value&gt; &lt;/util:list&gt; &lt;!-- 配置使用 master 数据源的业务方法前缀列表 --&gt; &lt;util:list id=\"useMasterDataSourceMethodPrefix\"&gt; &lt;value&gt;insert&lt;/value&gt; &lt;value&gt;update&lt;/value&gt; &lt;value&gt;delete&lt;/value&gt; &lt;/util:list&gt; &lt;bean class=\"org.fanlychie.core.MultipleDataSourceAspect\" /&gt; &lt;bean class=\"org.fanlychie.core.MultipleDataSourceContext\" /&gt;&lt;/beans&gt; 基于 AbstractRoutingDataSource 和 AOP 实现多数据源自动切换 1234567891011121314151617181920212223242526272829import org.springframework.beans.factory.annotation.Value;public class MultipleDataSourceContext &#123; public static String slave; public static String master; private static final ThreadLocal&lt;String&gt; context = new ThreadLocal&lt;&gt;(); public static void setKey(String name) &#123; context.set(name); &#125; public static String getKey() &#123; return context.get(); &#125; @Value(\"$&#123;jdbc.key.slave&#125;\") void setSlave(String slave) &#123; MultipleDataSourceContext.slave = slave; &#125; @Value(\"$&#123;jdbc.key.master&#125;\") void setMaster(String master) &#123; MultipleDataSourceContext.master = master; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334import java.util.List;import javax.annotation.Resource;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before; @Aspectpublic class MultipleDataSourceAspect &#123; @Resource private List&lt;String&gt; useSlaveDataSourceMethodPrefix; @Resource private List&lt;String&gt; useMasterDataSourceMethodPrefix; @Before(\"execution(* org.fanlychie.service.*.*(..))\") public void before(JoinPoint point) &#123; String method = point.getSignature().getName(); boolean useSlave = useSlaveDataSourceMethodPrefix.stream().anyMatch(i -&gt; method.startsWith(i)); if (useSlave) &#123; MultipleDataSourceContext.setKey(MultipleDataSourceContext.slave); System.out.println(\"--- slave ---\"); return ; &#125; boolean useMaster = useMasterDataSourceMethodPrefix.stream().anyMatch(i -&gt; method.startsWith(i)); if (useMaster) &#123; MultipleDataSourceContext.setKey(MultipleDataSourceContext.master); System.out.println(\"--- master ---\"); return ; &#125; throw new UnsupportedOperationException(\"can not match datasource for method '\" + method + \"'\"); &#125;&#125; 12345678910import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;public class MultipleDataSource extends AbstractRoutingDataSource &#123; @Override protected Object determineCurrentLookupKey() &#123; return MultipleDataSourceContext.getKey(); &#125;&#125; 实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.Date;public class User &#123; private Integer id; private String sex; private String name; private Date createTime; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Date getCreateTime() &#123; return createTime; &#125; public void setCreateTime(Date createTime) &#123; this.createTime = createTime; &#125; @Override public String toString() &#123; return \"User [id=\" + id + \", sex=\" + sex + \", name=\" + name + \", createTime=\" + createTime + \"]\"; &#125; &#125; mapper 配置文件 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"org.fanlychie.mapper.UserMapper\"&gt; &lt;resultMap id=\"UserResultMap\" type=\"org.fanlychie.entity.User\"&gt; &lt;id property=\"id\" column=\"ID\" /&gt; &lt;result property=\"sex\" column=\"SEX\" /&gt; &lt;result property=\"name\" column=\"NAME\" /&gt; &lt;result property=\"createTime\" column=\"CREATE_TIME\" /&gt; &lt;/resultMap&gt; &lt;select id=\"selectList\" resultMap=\"UserResultMap\"&gt; SELECT * FROM USER ORDER BY ID &lt;/select&gt; &lt;insert id=\"insert\" useGeneratedKeys=\"true\" keyProperty=\"id\" parameterType=\"User\"&gt; INSERT INTO USER (ID, NAME, SEX, CREATE_TIME) VALUES (#&#123;id&#125;, #&#123;name&#125;, #&#123;sex&#125;, #&#123;createTime&#125;) &lt;/insert&gt;&lt;/mapper&gt; mapper 接口 123456789101112package org.fanlychie.mapper;import java.util.List;import org.fanlychie.entity.User;public interface UserMapper &#123; public int insert(User user); public List&lt;User&gt; selectList(); &#125; service 接口 12345678910import java.util.List;import org.fanlychie.entity.User;public interface UserService &#123; boolean insert(User user); List&lt;User&gt; selectList(); &#125; service 实现类 123456789101112131415161718192021222324import java.util.List;import org.fanlychie.entity.User;import org.fanlychie.mapper.UserMapper;import org.fanlychie.service.UserService;import org.springframework.stereotype.Service;import org.springframework.beans.factory.annotation.Autowired;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserMapper mapper; @Override public boolean insert(User user) &#123; return mapper.insert(user) == 1; &#125; @Override public List&lt;User&gt; selectList() &#123; return mapper.selectList(); &#125;&#125; Junit 测试 123456789101112131415161718192021222324252627282930import java.util.Date;import org.fanlychie.entity.User;import org.fanlychie.service.UserService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"/spring-datasources.xml\")public class JTest &#123; @Autowired private UserService userService; @Test public void doTest() &#123; User user = new User(); user.setName(\"李四\"); user.setSex(\"男\"); user.setCreateTime(new Date()); boolean success = userService.insert(user); if (success) &#123; System.out.println(\"保存数据成功\"); &#125; userService.selectList().forEach(u -&gt; System.out.println(u)); &#125; &#125; 测试结果 12345--- master ---保存数据成功--- slave ---User [id=1, sex=男, name=张三, createTime=Thu Oct 20 05:04:59 CST 2016]User [id=2, sex=男, name=李四, createTime=Sat Oct 22 21:27:30 CST 2016]","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"MySQL 主从配置 - 实现读写分离","date":"2016-10-20T08:41:01.000Z","path":"post/mysql-master-slave.html","text":"环境 两台 CentOS 6.5 测试机，均已安装 MySQL 5.6 服务。选取其中一台作为主（master），另外一台作为从（salve）服务。 主：192.168.1.102 从：192.168.1.104 主（master）配置 主库负责写操作（INSERT，UPDATE，DELETE），设置 InnoDB 为默认存储引擎，编辑 my.cnf 1# vi /etc/my.cnf 在 [mysqld] 后面加上 12345default-storage-engine=InnoDB // InnoDB 为行级锁, 支持事务, 并发写入性能比 MyISAM 好server-id=102 // 只要主从不一样即可, 通常取IP的最后一段log_bin=master-log-bin // 开启二进制日志, 同步的原理是salve从master同步日志并在slave本地执行一次binlog_do_db=test_db // 需要做同步的数据库名字, 多个配置多行binlog-ignore-db=mysql // 不需要做同步的数据库名, 多个配置多行 重启 MySQL 服务 1# service mysqld restart 在主库创建复制权限的用户 1mysql&gt; GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO salveusr@'%' IDENTIFIED BY 'salveusr'; 从（slave）配置 从库负责读操作，设置 MyISAM 为默认存储引擎，编辑 my.cnf 1# vi /etc/my.cnf 在 [mysqld] 后面加上 1234default-storage-engine=MyISAM // MyISAM 查询速度比 InnoDB 快一些server-id=104replicate-do-db=test_dbreplicate-ignore-db=mysql 重启 MySQL 服务 1# service mysqld restart 在从库执行 12mysql&gt; CHANGE MASTER TO MASTER_HOST='192.168.1.102', MASTER_USER='salveusr', MASTER_PASSWORD='salveusr';mysql&gt; start slave; 准备测试的 SQL 在主从服务器分别创建 test_db 数据库 1CREATE DATABASE test_db DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; 在主从服务器 test_db 数据库中分别创建 user 表 1234567CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, `sex` varchar(255) NOT NULL, `create_time` datetime NOT NULL, PRIMARY KEY (`id`)) JDBC 测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.time.LocalDateTime;import java.time.ZoneId;import java.util.Date;public class Test &#123; private static final String USERNAME = \"root\"; private static final String PASSWORD = \"root\"; private static final String SLAVE_URL = \"jdbc:mysql://192.168.1.104:3306/test_db?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8\"; private static final String MASTER_URL = \"jdbc:mysql://192.168.1.102:3306/test_db?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8\"; public static void main(String[] args) throws SQLException &#123; // 先查询一次, 查询使用的是 slave 数据源 select(); // 插入一条数据, 插入使用的是 master 数据源 insert(\"张三\", \"男\"); // 再次查询, 有一条数据, 该数据便是上面 master 数据源插入的数据 select(); &#125; // 查询 public static void select() throws SQLException &#123; try (Connection conn = getSlaveConnection()) &#123; String sql = \"SELECT * FROM USER\"; try (PreparedStatement stmt = conn.prepareStatement(sql)) &#123; try (ResultSet rs = stmt.executeQuery()) &#123; while (rs.next()) &#123; int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); String sex = rs.getString(\"sex\"); Date createTime = rs.getTimestamp(\"create_time\"); LocalDateTime datetime = createTime.toInstant().atZone(ZoneId.systemDefault()) .toLocalDateTime(); System.out.println(id + \"\\t\" + name + \"\\t\" + sex + \"\\t\" + datetime); &#125; System.out.println(\"--- 查询结束 ---\"); &#125; &#125; &#125; &#125; // 插入 public static void insert(String name, String sex) throws SQLException &#123; try (Connection conn = getMasterConnection()) &#123; String sql = \"INSERT INTO USER(id, name, sex, create_time) VALUES(null, ?, ?, now())\"; try (PreparedStatement stmt = conn.prepareStatement(sql)) &#123; stmt.setString(1, name); stmt.setString(2, sex); stmt.executeUpdate(); &#125; &#125; &#125; // slave 连接 public static Connection getSlaveConnection() throws SQLException &#123; return DriverManager.getConnection(SLAVE_URL, USERNAME, PASSWORD); &#125; // master 连接 public static Connection getMasterConnection() throws SQLException &#123; return DriverManager.getConnection(MASTER_URL, USERNAME, PASSWORD); &#125; static &#123; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 测试结果 123--- 查询结束 ---1 张三 男 2016-10-20T05:04:59--- 查询结束 ---","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Java Http 工具类","date":"2016-09-26T00:58:05.000Z","path":"post/java-http-util.html","text":"开发环境 基于 JAVA-8，HttpClient-4.5.2 开发，源码地址见 HttpUtils.java 发送 Http 请求 工具类提供了常用的 GET，POST，PUT，DELETE 方法请求 12345678// GET 请求HttpUtils.get(\"http://www.duitang.com\")...// PUT 请求HttpUtils.put(\"http://www.duitang.com\")...// POST 请求HttpUtils.post(\"http://www.duitang.com\")...// DELETE 请求HttpUtils.delete(\"http://www.duitang.com\")... 可选配置项 以下 set 方法都是可选的配置项，下面设定的都是它们的原始默认数值。 1234567891011// GET 请求HttpUtils.get(\"http://www.duitang.com\") // 设置连接超时时间 .setConnectTimeoutSecond(60) // 设置读取超时时间 .setReadTimeoutSecond(120) // 设置失败重试次数 .setRetryTimes(3) // 设置读取结果使用的字符集编码 .setReadResultCharset(\"UTF-8\") ... 设置代理 通过 setProxy(host, port, schema) 可设置代理，schema 的可选值为 http 或 https，默认为 http。若为 HTTP 的代理，可直接通过调用 setProxy(host, port) 来设置代理。 12345// GET 请求HttpUtils.get(\"http://www.duitang.com\") // 设置代理 .setProxy(\"122.96.59.106\", 80, \"http\") ... 设置请求参数 通过 addParam(String, Object) 可设置请求的参数 12345// GET 请求HttpUtils.get(\"http://www.duitang.com/search/\") // 请求参数 .addParam(\"type\", \"feed\").addParam(\"kw\", \"插画\") ... 或者通过 setParams(Object…) 来设置请求的参数 12345// GET 请求HttpUtils.get(\"http://www.duitang.com/search/\") // 请求参数 .setParams(\"type\", \"feed\", \"kw\", \"插画\") ... 或者通过 setParams(Map) 来设置请求的参数 123456789Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();params.put(\"type\", \"feed\");params.put(\"kw\", \"插画\");// GET 请求HttpUtils.get(\"http://www.duitang.com/search/\") // 请求参数 .setParams(params) .... JSON 参数的请求可以通过 setBody(String) 来设置 12345// GET 请求HttpUtils.get(\"http://www.duitang.com/search/\") // 请求参数 .setBody(\"&#123;\\\"kw\\\":\\\"插画\\\",\\\"type\\\":\\\"feed\\\"&#125;\") ... 设置请求头参数 请求头参数的设值与请求参数的设值相似，如： 12345// GET 请求HttpUtils.get(\"http://www.duitang.com\") // 请求头参数 .setHeader(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36 SE 2.X MetaSr 1.0\") ... 执行 HTTP 请求 通过调用 execute(BiConsumer&lt;Integer, String&gt;) 方法来执行 HTTP 请求。 其中，第一个参数为 HTTP 请求结果的状态码值，第二个参数为 HTTP 请求结果的文本内容。一个完整的示例： 1234567HttpUtils.get(\"http://www.duitang.com\").execute((status, response) -&gt; &#123; if (status == 200) &#123; System.out.println(response); &#125; else &#123; System.out.println(\"--- 请求失败 ---\"); &#125;&#125;);","tags":[{"name":"工具类","slug":"工具类","permalink":"http://yoursite.com/tags/工具类/"}]},{"title":"Eclipse PyDev 插件离线安装和配置","date":"2016-09-21T07:35:05.000Z","path":"post/eclipse-pydev-install.html","text":"目前 PyDev 最新版本为 5.2.0，点此下载 PyDev 5.2.0.zip。 下载完成后解压缩 features 和 plugins 两个文件夹的内容到 Eclipse 安装路径下的 features 和 plugins 目录中，重启 Eclipse。打开 Window -&gt; Preferences -&gt; PyDev -&gt; Interpreters -&gt; Python 点击右上侧的 New，在弹出的窗口中点击 Browse，并选到 Python 安装目录下的 python.exe 文件，点击 OK 在弹出的窗口中直接点击 OK 回到主面板点击 OK 创建一个 Python 项目，New -&gt; Other -&gt; PyDev -&gt; PyDev Project 在 src 目录下新建一个 hello.py 文件 1print('Hello World!') 选中 hello.py 右键 Run As -&gt; Python Run，即可看到结果。","tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://yoursite.com/tags/Eclipse/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Java8 Map 新增方法","date":"2016-09-21T01:19:10.000Z","path":"post/java8-map.html","text":"Java8 中的 Map 接口新增了一批由 default 声明的默认方法。以下示例中列举了 getOrDefault(Object, V) putIfAbsent(K, V) remove(Object, Object) replace(K, V) replace(K, V, V) replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt;) forEach(BiConsumer&lt;? super K, ? super V&gt;) compute(K, BiFunction&lt;? super K, ? super V, ? extends V&gt;) Map.Entry.comparingByValue() / Map.Entry.comparingByKey() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182private static Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();private static Map&lt;String, Integer&gt; unsorted = new HashMap&lt;&gt;();static &#123; map.put(\"Paris\", \"巴黎\"); map.put(\"London\", \"伦敦\"); map.put(\"NewYork\", \"纽约\"); unsorted.put(\"a\", 2); unsorted.put(\"b\", 1); unsorted.put(\"c\", 3);&#125;public static void main(String[] args) &#123; // Java8 以前, 根据 Key 获取值, 若没有匹配的项, 则返回 null Object hk1 = map.get(\"HongKong\"); // null // 根据 Key 获取值, 若没有匹配的项, 则返回 defaultValue Object hk2 = map.getOrDefault(\"HongKong\", \"香港\"); // 香港 // 遍历 map.forEach((k, v) -&gt; System.out.println(k + \" = \" + v)); // London = 伦敦 // NewYork = 纽约 // Paris = 巴黎 // 当 key 匹配的项不存在或为 null 时, 则执行 put 并返回 null Object result1 = map.putIfAbsent(\"HongKong\", \"香港\"); // null // 当 key 匹配的项存在且不为 null 时, 则直接返回该项的值 Object result2 = map.putIfAbsent(\"HongKong\", \"香干\"); // 香港 // 若 key 或 value 其中的一个不匹配时, 则直接返回 false boolean bool1 = map.remove(\"HongKong\", \"香干\"); // false // 当 key 和 value 同时匹配时, 则执行 remove 并返回 true boolean bool2 = map.remove(\"HongKong\", \"香港\"); // true // 当 key 匹配的项不存在时, 则直接返回 null Object value1 = map.replace(\"HongKong\", \"香港\"); // null // 当 key 匹配的项存在时, 用 value 替换之前的值, 并返回替换之前的值 Object value2 = map.replace(\"NewYork\", \"纽约！纽约\"); // 纽约 // 与新增的 remove 方法类似, key 和 value 同时匹配时才替换 boolean bool3 = map.replace(\"Paris\", \"巴黎\", \"巴黎！巴黎\"); // 全部替换 map.replaceAll((k, v) -&gt; k + \", \" + v); // 输出替换后的结果 map.forEach((k, v) -&gt; System.out.println(k + \" = \" + v)); // London = London, 伦敦 // NewYork = NewYork, 纽约！纽约 // Paris = Paris, 巴黎！巴黎 // 简而言之, replace 规则 : 存在则替换 // 只要 BiFunction 函数产生 non-null 值, 皆执行 put 操作, 并返回该结果 Object obj1 = map.compute(\"HongKong\", (k, v) -&gt; k); // HongKong // 只要 BiFunction 函数产生 null 值, 如果 map 中存在该 key 匹配的项, 执行 remove 移除, 并返回 null Object obj2 = map.compute(\"HongKong\", (k, v) -&gt; null); // null // 未排序之前 unsorted.forEach((k, v) -&gt; System.out.println(k + \" = \" + v)); // a = 2 // b = 1 // c = 3 // 用于存储排序的结果 Map&lt;String, Integer&gt; sorted = new LinkedHashMap&lt;&gt;(); // 按值自然排序 unsorted.entrySet().stream().sorted(Map.Entry.comparingByValue()).forEach((e) -&gt; sorted.put(e.getKey(), e.getValue())); // 按值自然排序的结果 sorted.forEach((k, v) -&gt; System.out.println(k + \" = \" + v)); // b = 1 // a = 2 // c = 3 sorted.clear(); // 按值降序排序 unsorted.entrySet().stream().sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue().reversed()).forEach((e) -&gt; sorted.put(e.getKey(), e.getValue())); // 按值降序排序的结果 sorted.forEach((k, v) -&gt; System.out.println(k + \" = \" + v)); // c = 3 // a = 2 // b = 1&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 日期时间处理","date":"2016-09-18T06:55:13.000Z","path":"post/java-8-date-time.html","text":"在 Java8 之前，为了得到一个过去或未来的日期时间，我们往往需要组合 Date 和 Calendar 一起使用。不幸的是，这对组合并不那么好使，正所谓谁用谁知道，心照不宣吧。 Java8 中新增了一套全新的日期时间 API，它明确的将日期时间划分为 LocalDate、LocalTime 以及 LocalDateTime，分别用于表示日期、时间和日期时间，并且产生的结果是不可变的和线程安全的。 Month 月份在 Java8 中声明成了枚举类型，增强了代码的可读性和可靠性。 123456789101112131415161718// 枚举类型Month january = Month.JANUARY; // JANUARY// 获取显示的名字String displayName = january.getDisplayName(TextStyle.FULL, Locale.getDefault()); // 一月// 月份+1, 得到的是2月份Month february = january.plus(1); // FEBRUARY// 2月份的天数最少的时候的值int minDaysOfMonth = february.minLength(); // 28// 2月份的天数最多的时候的值int maxDaysOfMonth = february.maxLength(); // 29// 获取2016年2月份的天数int daysOfMonth = february.length(Year.isLeap(2016)); // 29// 获取2月份表示的整数值int februaryValue = february.getValue(); // 2// 月份-2, 得到的是12月份Month december = february.minus(2); // DECEMBER// 用整数值构造月份, 1表示1月份, 4表示4月份...Month april = Month.of(4); // APRIL DayOfWeek 星期在 Java8 中也声明成了枚举类型，增强了代码的可读性和可靠性。 123456789101112// 枚举类型DayOfWeek monday = DayOfWeek.MONDAY; // MONDAY// 获取显示的名字String displayName = monday.getDisplayName(TextStyle.FULL, Locale.getDefault()); // 星期一// 星期+4, 得到的是星期五DayOfWeek friday = monday.plus(4); // FRIDAY// 获取星期五表示的整数值int fridayValue = friday.getValue(); // 5// 星期-2, 得到的是星期三DayOfWeek wednesday = friday.minus(2); // WEDNESDAY// 用整数值构造星期, 1表示星期一, 7表示星期日...DayOfWeek sunday = DayOfWeek.of(7); // SUNDAY LocalDate 用于表示日期，不包含时间和时区，采用标准的 ISO-8601 日历日期表示方法（年-月-日, yyyy-MM-dd），如 2007-12-03 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 当前的日期LocalDate now = LocalDate.now(); // 2016-09-19// 获取年份值int year = now.getYear(); // 2016// 获取月份值int month = now.getMonthValue(); // 9// 获取天数值int dayOfMonth = now.getDayOfMonth(); // 19// 获取今天是今年的第几天int dayOfYear = now.getDayOfYear(); // 263// 获取月份Month currMonth = now.getMonth(); // SEPTEMBER// 获取星期DayOfWeek dayOfWeek = now.getDayOfWeek(); // MONDAY// 是否为闰年boolean leapYear = now.isLeapYear(); // true// 今年有多少天int lengthOfYear = now.lengthOfYear(); // 366// 本月有多少天int lengthOfMonth = now.lengthOfMonth(); // 30// 修改月份为10月LocalDate date1 = now.withMonth(Month.OCTOBER.getValue()); // 2016-10-19// 修改年份为2017年LocalDate date2 = now.withYear(2017); // 2017-09-19// 修改天数为今年的第2天LocalDate date3 = now.withDayOfYear(2); // 2016-01-02// 修改天数为本月的第2天LocalDate date4 = now.withDayOfMonth(2); // 2016-09-02// 天数+1LocalDate date5 = now.plusDays(1); // 2016-09-20// 月份+1LocalDate date6 = now.plusMonths(1); // 2016-10-19// 增加一个星期LocalDate date7 = now.plusWeeks(1); // 2016-09-26// 年份+1LocalDate date8 = now.plusYears(1); // 2017-09-19// 天数-1LocalDate date9 = now.minusDays(1); // 2016-09-18// 月份-1LocalDate date10 = now.minusMonths(1); // 2016-08-19// 减少一个星期LocalDate date11 = now.minusWeeks(1); // 2016-09-12// 年份-1LocalDate date12 = now.minusYears(1); // 2015-09-19// 构造一个日期对象LocalDate date13 = LocalDate.of(2016, Month.OCTOBER, 1); // 2016-10-01// 修改日期LocalDate date14 = now.with(TemporalAdjusters.next(DayOfWeek.MONDAY)); // 2016-09-26// 必须是严格的 yyyy-MM-dd 格式, 否则将抛出 DateTimeParseException 异常LocalDate date15 = LocalDate.parse(\"2016-09-09\");// 自定义解析格式LocalDate date16 = LocalDate.parse(\"2016/09/09\", DateTimeFormatter.ofPattern(\"yyyy/MM/dd\")); 除此之外，用于表示日期的还有 YearMonth（年月），MonthDay（月日），Year（年）。 12345678910111213141516171819202122232425262728// 当前的年月YearMonth yearMonth1 = YearMonth.now(); // 2016-09// 构造一个年月YearMonth yearMonth2 = YearMonth.of(2016, Month.FEBRUARY); // 2016-02// 本月份的天数int lengthOfMonth = yearMonth2.lengthOfMonth(); // 29// ----------------------------------------------------------------------// 当前的月天MonthDay monthDay1 = MonthDay.now(); // --09-19// 构造一个月天MonthDay monthDay2 = MonthDay.of(Month.FEBRUARY, 29); // --02-29// 先后判断boolean bool = monthDay2.isBefore(monthDay1); // true// ----------------------------------------------------------------------// 当前的年份Year year = Year.now(); // 2016// 2014年Year year2014 = Year.of(2014);// 判断是否为闰年boolean leapYear1 = year2014.isLeap(); // false// 判断是否为闰年boolean leapYear2 = Year.isLeap(2016); // true// 获取该年份有多少天int length = year2014.length(); // 365 LocalTime 表示与时区无关的本地时间，不包含日期，采用标准的 ISO-8601 日历时间表示方法：HH:mm，HH:mm:ss，HH:mm:ss.SSS，HH:mm:ss.SSSSSS，HH:mm:ss.SSSSSSSSS对于某个特定的时间，LocalTime 将采用其中的一个能表示它且格式是最短的一个，其余位没有的则隐含为0。如 10:15:30. 用法与 LocalDate 相似： 12345678// 当前时间LocalTime now = LocalTime.now(); // 16:14:15.809// 获取小时int hour = now.getHour(); // 16// 小时+2LocalTime time1 = now.plusHours(2); // 18:14:15.809// 构造时间LocalTime time2 = LocalTime.of(20, 18, 16); // 20:18:16 LocalDateTime 表示与时区无关的本地日期时间，采用标准的 ISO-8601 日历日期时间表示方法，按 ISO-8601 标准，日期和时间的组合表示时，需要在时间前面加一大写字母 T，如2004年5月3日下午5点30分8秒表示成2004-05-03T17:30:08. 用法与 LocalDate 和 LocalTime 相似： 1234567891011121314// 当前日期时间LocalDateTime now = LocalDateTime.now(); // 2016-09-19T16:46:12.988// 转化成日期LocalDate date = now.toLocalDate(); // 2016-09-19// 转化成时间LocalTime time = now.toLocalTime(); // 16:46:12.988// 构造日期时间LocalDateTime datetime1 = LocalDateTime.of(2018, Month.APRIL, 1, 8, 30, 20); // 2018-04-01T08:30:20// 构造日期时间LocalDateTime datetime2 = date.atTime(8, 30, 20); // 2016-09-19T08:30:20// 构造日期时间LocalDateTime datetime3 = time.atDate(LocalDate.of(2016, Month.DECEMBER, 8)); // 2016-12-08T16:46:12.988// 格式化日期时间String formatStr = now.format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\")); // 2016-09-19 16:46:12","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 Stream","date":"2016-09-16T14:44:36.000Z","path":"post/java8-stream.html","text":"Java8 中新引入的 Stream 和以往的 I/O 流是完全不同的两个东西，Java8 中的 Stream 是对集合功能的增强，它结合 Java8 中新引入的 Lambda 表达式，可以使我们编写少量的代码就能够完成一些复杂的功能。 你可以对 Stream 进行两种操作，Intermediate 操作（中间操作）和 Terminal 操作（最终操作）。 Intermediate 操作是将修改后的 Stream 返回给调用方，因此，对一个 Stream 可以使用零个或多个 Intermediate 操作。 Terminal 操作是对 Stream 的最后一个操作，此后，该 Stream 无法再被操作，一个 Stream 只能有一个 Terminal 操作。 forEach Terminal 操作，用于遍历元素。 1234public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); list.stream().forEach(System.out::print); // 135246&#125; filter Intermediate 操作，用于对 Stream 的每个元素进行判断，符合判断的元素才会被留下来。 1234public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); list.stream().filter((i) -&gt; i % 2 == 0).forEach(System.out::print); // 246&#125; sorted Intermediate 操作，用于对 Stream 的元素进行自然排序。 1234public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); list.stream().sorted().forEach(System.out::print); // 123456&#125; map Intermediate 操作，用于将原始 Stream 的每一个元素映射成任意类型的另外一个元素。 1234public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); list.stream().map((i) -&gt; (char)('a' + i)).forEach(System.out::print); // bdfceg&#125; match Terminal 操作，用于判断元素是否满足某种特定的条件。 123456789101112public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); // allMatch : 所有元素符合条件才返回 true boolean result1 = list.stream().allMatch((i -&gt; i % 2 == 0)); // anyMatch : 只要有一个元素符合条件即返回 true boolean result2 = list.stream().anyMatch((i -&gt; i % 2 == 0)); // noneMatch : 所有元素都不符合条件才返回 true boolean result3 = list.stream().noneMatch((i -&gt; i % 2 == 0)); System.out.println(result1); // false System.out.println(result2); // true System.out.println(result3); // false&#125; count Terminal 操作，用于统计 Stream 中元素的总数。 12345public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); long result = list.stream().filter((i) -&gt; i % 2 == 0).count(); System.out.println(result); // 3&#125; limit Intermediate 操作，用于取得 Stream 的前 n 个元素。 1234public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); list.stream().limit(3).forEach(System.out::print); // 135&#125; skip Intermediate 操作，用于跳过 Stream 的前 n 个元素。 1234public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); list.stream().skip(3).forEach(System.out::print); // 246&#125; reduce Terminal 操作，用于依据参数给定的 BinaryOperator 运算规则，将 Stream 中的元素组合起来。 BinaryOperator（二元操作）是一个函数式接口，它继承于 BiFunction（二元函数）。 BiFunction 与 Function 接口非常相似，不同的是，BiFunction 有两个输入参数，而 Function 只有一个参数输入。 BinaryOperator 继承于 BiFunction，其目的仅仅是为了将两个输入参数声明为同一种类型而已。以下为源码片段： 12345678910111213@FunctionalInterfacepublic interface BiFunction&lt;T, U, R&gt; &#123;... ...&#125;@FunctionalInterfacepublic interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; &#123;... ...&#125; 使用 reduce 对 Stream 中的元素进行求和。 12345public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); Integer result = list.stream().reduce(0, (n1, n2) -&gt; n1 + n2); System.out.println(result); // 21&#125; 这里用到 T reduce(T identity, BinaryOperator&lt;T&gt; accumulator); 其中 identity 是作为此次运算的起始值（种子），然后依据 accumulator 提供的运算规则将 Stream 中的元素逐个逐个与前面的组合起来。这相当于： 12345int result = 0; // 参数 identity 指定的起始值for (int item : list) &#123; result += item;&#125;return result; 因为我们给定了起始值，因此我们认为 Stream 中至少存在一个元素，因此它总能返回一个具体的值。 与它非常相似的还有一个方法 Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator); 由于此方法中没有起始值参数，当 Stream 中没有元素，即空的 Stream，此时会返回一个空的 Optional 对象，以防止 NullPointerException 的发生。这是两者之间的区别。 1234567public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); // 没有起始值, 返回的是 Optional 对象 Optional&lt;Integer&gt; optional = list.stream().reduce((n1, n2) -&gt; n1 + n2); Integer result = optional.get(); System.out.println(result); // 21&#125; min Terminal 操作，是一种特殊的 reduce，由于 Stream 可能是空的，返回值为 Optional。 123456public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); Optional&lt;Integer&gt; optional = list.stream().min(Integer::compareTo); Integer result = optional.get(); System.out.println(result); // 1&#125; max Terminal 操作，是一种特殊的 reduce，由于 Stream 可能是空的，返回值为 Optional。 123456public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); Optional&lt;Integer&gt; optional = list.stream().max(Integer::compareTo); Integer result = optional.get(); System.out.println(result); // 6&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 Optional","date":"2016-09-16T02:38:35.000Z","path":"post/java8-optional.html","text":"Optional 是 Java8 中新引入的一个类，它用于作为一个值可能为 null 或 non-null 的容器对象。如果一个方法的返回值是一个 Optional 类型，这是在向我们表明该方法的返回值可能为 null，调用时需要进行判空处理，这样可以有效的防止 NullPointerException 异常。如果通过调用 Optional.isPresent() 返回 true，则表明结果 non-null，此时可以放心调用 Optional.get() 获得此对象。 of 通过调用 Optional.of 可以构造一个 Optional 对象，参数要求是 non-null 值，否则抛出 NullPointerException 异常。 1234567public static void main(String[] args) &#123; Optional&lt;String&gt; optional = Optional.of(\"foo\"); if (optional.isPresent()) &#123; String result = optional.get(); System.out.println(result); // foo &#125;&#125; ofNullable 通过调用 Optional.ofNullable 可以构造一个 Optional 对象，参数如果是 null 值，则返回一个值为空的 Optional 对象。 1234public static void main(String[] args) &#123; Optional&lt;String&gt; optional = Optional.ofNullable(null); System.out.println(optional.isPresent()); // false&#125; orElse 如果 Optional 对象的值不存在，则返回 orElse 给定的值。 12345public static void main(String[] args) &#123; Optional&lt;String&gt; optional = Optional.ofNullable(null); String result = optional.orElse(\"foo\"); System.out.println(result); // foo&#125; ifPresent 如果 Optional 对象的值存在，则将该值作为参数执行 Consumer。否则，什么事情都不做。 1234public static void main(String[] args) &#123; Optional&lt;String&gt; optional = Optional.of(\"foo\"); optional.ifPresent((s) -&gt; System.out.println(s.length())); // 3&#125; orElseGet 如果 Optional 对象的值存在，则直接返回该值。否则，调用 Supplier 并返回调用的结果值。 12345public static void main(String[] args) &#123; Optional&lt;Date&gt; optional = Optional.ofNullable(null); Date result = optional.orElseGet(Date::new); System.out.println(result); // Fri Sep 16 18:35:30 CST 2016&#125; filter 如果 Optional 对象的值不存在或值存在且该值匹配参数给定的 Predicate 规则，则返回当前的 Optional 对象本身。否则，返回一个空的 Optional 对象。 123456public static void main(String[] args) &#123; Optional&lt;String&gt; optional1 = Optional.of(\"foo\"); Optional&lt;String&gt; optional2 = optional1.filter((s) -&gt; s.length() == 3); System.out.println(optional2.isPresent()); // true System.out.println(optional2.get()); // foo&#125; map 如果 Optional 对象的值存在，则将该值作为参数调用 Function，如果调用的结果为 non-null 值，则返回一个新的以该结果作为值的 Optional 对象，否则，返回一个空的 Optional 对象。 123456public static void main(String[] args) &#123; Optional&lt;String&gt; optional1 = Optional.of(\"foo\"); Optional&lt;Integer&gt; optional2 = optional1.map((s) -&gt; s.length()); System.out.println(optional2.isPresent()); // true System.out.println(optional2.get()); // 3&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 Supplier","date":"2016-09-15T14:33:04.000Z","path":"post/java8-supplier.html","text":"Supplier 是一个无参并返回一个任意类型值的函数式接口。 12345public static void main(String[] args) &#123; Supplier&lt;Date&gt; supplier = Date::new; Date date = supplier.get(); System.out.println(date); // Fri Sep 16 00:20:19 CST 2016&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 Consumer","date":"2016-09-15T14:32:54.000Z","path":"post/java8-consumer.html","text":"Consumer 是一个接收一个任意类型的参数并不产生任何结果的函数式接口。 1234public static void main(String[] args) &#123; Consumer&lt;String&gt; consumer = (s) -&gt; System.out.println(\"The input string is : \" + s); consumer.accept(\"Hello Java8\"); // The input string is : Hello Java8&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 Function","date":"2016-09-15T13:55:20.000Z","path":"post/java8-function.html","text":"Function 是一个接收一个参数并返回一个任意类型值的函数式接口。 12345public static void main(String[] args) &#123; Function&lt;String, Integer&gt; function = (s) -&gt; s.length(); Integer result = function.apply(\"foo\"); System.out.println(result); // 3&#125; 使用 Function 提供的默认方法可以组合多个 Function 一起工作。 123456public static void main(String[] args) &#123; Function&lt;String, Integer&gt; function1 = (s) -&gt; s.length(); Function&lt;Integer, Boolean&gt; function2 = (i) -&gt; i &gt; 5; Boolean result = function1.andThen(function2).apply(\"foo\"); System.out.println(result); // false&#125; andThen 是比较常见的一种用法，工作时，先执行 function1 再执行 function2。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 Predicate","date":"2016-09-15T12:36:15.000Z","path":"post/java8-predicate.html","text":"Predicate 是一个接收一个参数并返回一个 boolean 类型值的函数式接口。它用于判断输入的参数对象是否符合某个特定的规则。 12345public static void main(String[] args) &#123; Predicate&lt;Integer&gt; predicate = (n) -&gt; n % 2 == 0; boolean result = predicate.test(8); System.out.println(result); // true&#125; 除此之外，你还可以组合 Predicate 中提供的默认方法 or（或）、and（与）、negate（非）进行更加复杂的逻辑判断。 12345public static void main(String[] args) &#123; Predicate&lt;Integer&gt; predicate = (n) -&gt; n % 2 == 0; boolean result = predicate.negate().test(8); System.out.println(result); // false&#125; or 逻辑时，先执行 predicate1 判断再执行 predicate2 判断。 123456public static void main(String[] args) &#123; Predicate&lt;Integer&gt; predicate1 = (n) -&gt; n &gt; 0; Predicate&lt;Integer&gt; predicate2 = (n) -&gt; n &lt; 5; boolean result = predicate1.or(predicate2).test(8); System.out.println(result); // true&#125; and 逻辑时，先执行 predicate1 判断再执行 predicate2 判断。 123456public static void main(String[] args) &#123; Predicate&lt;Integer&gt; predicate1 = (n) -&gt; n &gt; 0; Predicate&lt;Integer&gt; predicate2 = (n) -&gt; n &lt; 5; boolean result = predicate1.and(predicate2).test(8); System.out.println(result); // false&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 方法引用","date":"2016-09-15T07:09:50.000Z","path":"post/java8-method-reference.html","text":"在了解 Lambda 表达式之后，我们来看这样一段代码： 12345public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); Collections.sort(list, (o1, o2) -&gt; o1.compareTo(o2)); System.out.println(list); // [1, 2, 3, 4, 5, 6]&#125; 如果 Lambda 表达式中仅仅是调用了一个已存在的方法，在 Java8 中，可以使 :: 关键字来替代 Lambda 表达式。 关键字 :: 可以用来引用一个方法或构造器，这种特性称为方法引用。 12345public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6); Collections.sort(list, Integer::compareTo); System.out.println(list); // [1, 2, 3, 4, 5, 6]&#125; 声明一个函数式接口 1234@FunctionalInterfaceinterface Converter&lt;I, O&gt; &#123; O convert(I input);&#125; 引用静态方法（类名::静态方法名） 1234567public static void main(String[] args) &#123; // 对应的 Lambda 表达式 // Converter&lt;String, Integer&gt; converter = (s) -&gt; Integer.valueOf(s); Converter&lt;String, Integer&gt; converter = Integer::valueOf; Integer result = converter.convert(\"256\"); System.out.println(result); // 256&#125; 引用对象的实例方法（对象::方法名） 12345678public static void main(String[] args) &#123; DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\"); // 对应的 Lambda 表达式 // Converter&lt;Date, String&gt; converter = (date) -&gt; format.format(date); Converter&lt;Date, String&gt; converter = format::format; String result = converter.convert(new Date()); System.out.println(result); // 2016-09-15&#125; 引用某种类型的任意对象的实例方法（类名::方法名） 1234567public static void main(String[] args) &#123; // 对应的 Lambda 表达式 // Converter&lt;String, Boolean&gt; converter = (s) -&gt; s.isEmpty(); Converter&lt;String, Boolean&gt; converter = String::isEmpty; Boolean result = converter.convert(\"foo\"); System.out.println(result); // false&#125; 引用构造方法（类名::new） 1234567public static void main(String[] args) &#123; // 对应的 Lambda 表达式 // Converter&lt;String, Integer&gt; converter = (s) -&gt; new Integer(s); Converter&lt;String, Integer&gt; converter = Integer::new; Integer result = converter.convert(\"256\"); System.out.println(result); // 256&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 Lambda 表达式","date":"2016-09-14T07:39:00.000Z","path":"post/java8-lambda-expressions.html","text":"在 Java8 之前，当实现只有一个方法的接口，我们通常是通过使用匿名内部类的方式来重写接口的方法，以 Comparator 为例： 12345678List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6);Collections.sort(list, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o1.compareTo(o2); &#125;&#125;);System.out.println(list); // [1, 2, 3, 4, 5, 6] Java8 中引入了 Lambda 表达式，提供了更加简洁的语法：() -&gt; {} 12345List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6);Collections.sort(list, (Integer o1, Integer o2) -&gt; &#123; return o1.compareTo(o2);&#125;);System.out.println(list); // [1, 2, 3, 4, 5, 6] 从 Java8 开始编译器可以从接口的方法签名中自动推导出参数类型，因此可以省略掉类型的声明 12345List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6);Collections.sort(list, (o1, o2) -&gt; &#123; return o1.compareTo(o2);&#125;);System.out.println(list); // [1, 2, 3, 4, 5, 6] 当方法体只有一行代码时，可以省略掉 {} 和 return 关键字以及代码行结束的分号“;” 123List&lt;Integer&gt; list = Arrays.asList(1, 3, 5, 2, 4, 6);Collections.sort(list, (o1, o2) -&gt; o1.compareTo(o2));System.out.println(list); // [1, 2, 3, 4, 5, 6] 对于只有一个抽象方法的接口，都可以使用 Lambda 表达式。为了确保接口符合要求，可以使用 @FunctionalInterface 注解标注接口，被 @FunctionalInterface 注解标注的接口（称为函数式接口），只允许存在一个抽象方法，没有或多于一个抽象方法，编译都将无法通过。由于默认的方法不是抽象的，因此，函数式接口依然可以存在一个或多个默认方法。其中，每个 Lambda 表达式都将匹配函数式接口的这个抽象方法，Lambda 表达式的类型也由该接口类型决定。 123456@FunctionalInterfaceinterface Operation&lt;I, O&gt; &#123; O calculate(I input);&#125; 对函数式接口使用 Lambda 表达式 12345public static void main(String[] args) &#123; Operation&lt;Integer, Integer&gt; square = (i) -&gt; i * i; Integer result = square.calculate(3); System.out.println(result); // 9&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"Java8 接口默认方法","date":"2016-09-13T07:02:19.000Z","path":"post/java-8-interface-default-method.html","text":"在 Java8 中，接口也可以为方法提供默认的实现，即，接口也可以有自己的实现方法，具体的做法是使用关键字 default 即可为接口声明一个默认的方法。 123456789interface Predators &#123; void doSomething(); default void eat() &#123; System.out.println(\"eat meat\"); &#125; &#125; 任何具体类在实现接口时，接口的默认方法不是必须实现的，非默认方法则必须实现。 12345678class Dog implements Predators &#123; @Override public void doSomething() &#123; System.out.println(\"wang....\"); &#125;&#125; 使用方面与平常无异，很自然。 12345public static void main(String[] args) &#123; Dog dog = new Dog(); dog.doSomething(); // wang.... dog.eat(); // eat meat&#125; 关于多重继承： 123456789interface Herbivore &#123; void doSomething(); default void eat() &#123; System.out.println(\"eat fruit\"); &#125; &#125; 以下这段代码将无法通过编译。因 Predators 和 Herbivore 两个接口使用了同样签名的默认方法（eat），那么，在 Person 类中就无法确定最终使用哪个接口的默认实现。 12345678class Person implements Predators, Herbivore &#123; @Override public void doSomething() &#123; System.out.println(\"duang....\"); &#125;&#125; 为了解决冲突，你必须要通过手动重写的方式来修复。若想引用 Herbivore 接口中的 eat 方法，如下所示： 12345678910111213class Person implements Predators, Herbivore &#123; @Override public void eat() &#123; Herbivore.super.eat(); &#125; @Override public void doSomething() &#123; System.out.println(\"duang....\"); &#125;&#125; 使用方面与平常无异，很自然。 12345public static void main(String[] args) &#123; Person person = new Person(); person.doSomething(); // duang.... person.eat(); // eat fruit&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"网络爬虫","date":"2016-01-08T12:57:21.000Z","path":"post/network-crawler.html","text":"Crawler4j 是一个开源的 Java 类库提供一个用于抓取 Web 页面的简单接口。可以利用它来构建一个多线程的 Web 爬虫。 pom.xml 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;edu.uci.ics&lt;/groupId&gt; &lt;artifactId&gt;crawler4j&lt;/artifactId&gt; &lt;version&gt;4.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.8.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt; 资源下载工具 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import java.io.File;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.net.HttpURLConnection;import org.apache.commons.lang3.StringUtils;import org.apache.http.HttpResponse;import org.apache.http.client.HttpClient;import org.apache.http.client.methods.HttpUriRequest;import org.apache.http.client.methods.RequestBuilder;import org.apache.http.impl.client.HttpClientBuilder;/** * 资源下载工具 * * @author fanlychie */public class HttpClientUtils &#123; private static Logger log = LoggerFactory.getLogger(HttpClientUtils.class); /** * 下载资源文件 * * @param url * 资源文件地址 * @param storeFolder * 下载的文件存放的目录 */ public static void download(String url, String storeFolder) &#123; String filename = null; if (StringUtils.isNotBlank(url)) &#123; filename = url.substring(url.lastIndexOf(\"/\") + 1, url.length()); &#125; download(url, storeFolder, filename); &#125; /** * 下载资源文件 * * @param url * 资源文件地址 * @param storeFolder * 下载的文件存放的目录 * @param filename * 下载的文件的名称 */ public static void download(String url, String storeFolder, String filename) &#123; try &#123; if (StringUtils.isBlank(url)) &#123; throw new IllegalArgumentException(\"外部链接地址为空\"); &#125; // HttpClient HttpClient httpClient = HttpClientBuilder.create().build(); // GET 方法请求 HttpUriRequest request = RequestBuilder.get().setUri(url).build(); // 执行 GET 请求 HttpResponse response = httpClient.execute(request); // 状态码 int statusCode = response.getStatusLine().getStatusCode(); // 200 OK if (statusCode == HttpURLConnection.HTTP_OK) &#123; log.info(\"downloading &#123;&#125; ( &#123;&#125; KB )\", url, response.getEntity().getContentLength() / 1024); // 下载资源的临时文件名称 String fileTempName = filename + \".temp\"; File file = new File(storeFolder, fileTempName); downloadFile(response.getEntity().getContent(), new FileOutputStream(file)); // 下载成功后重命名文件 file.renameTo(new File(storeFolder, filename)); &#125; &#125; catch (Throwable e) &#123; log.error(\"下载外部资源失败！\", e); &#125; &#125; /** * 下载文件 * * @param in * 输入流 * @param out * 输入流 * @throws Throwable */ private static void downloadFile(InputStream in, OutputStream out) throws Throwable &#123; byte bytes[] = new byte[1024 * 1024 / 4]; int read; while ((read = in.read(bytes)) != -1) &#123; out.write(bytes, 0, read); &#125; out.close(); &#125; &#125; log4j 123456log4j.rootLogger = INFO, consolelog4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.target = System.outlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.conversionPattern = %p %d&#123;yyyy-MM-dd HH:mm:ss&#125; %c : %L %n%m%n%nlog4j.logger.org.apache.http = WARN 网络爬虫 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import org.jsoup.Jsoup;import java.util.regex.Matcher;import java.util.regex.Pattern;import org.fanlychie.util.HttpClientUtils;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;import edu.uci.ics.crawler4j.crawler.Page;import edu.uci.ics.crawler4j.crawler.WebCrawler;import edu.uci.ics.crawler4j.parser.HtmlParseData;import edu.uci.ics.crawler4j.url.WebURL;/** * 网络爬虫 * * @author fanlychie */public class MyWebCrawler extends WebCrawler &#123; private final static Pattern FILTERS = Pattern.compile(\".*(\\\\.(css|js|gif|jpg|png))$\"); /** * 哪些页面可以被爬取 */ @Override public boolean shouldVisit(Page page, WebURL url) &#123; String href = url.getURL().toLowerCase(); // 链接地址不是 css, js, 图片且链接地址必须以 http://www.hai360.com/shoes-clothes.html 开始的链接才爬取 return !FILTERS.matcher(href).matches() &amp;&amp; href.startsWith(\"http://www.hai360.com/shoes-clothes.html\"); &#125; /** * 当某个页面被爬取时该方法被调用 */ @Override public void visit(Page page) &#123; if (page.getParseData() instanceof HtmlParseData) &#123; HtmlParseData htmlParseData = (HtmlParseData) page.getParseData(); // 爬取到的 HTML 文本内容 String html = htmlParseData.getHtml(); Document doc = Jsoup.parse(html); // 解析 class=\"list-item\" 节点下的 img 标签 // 其中某一个的 img 标签内容如下 // &lt;img data-src=\"http://aimg.hai360.com/item/20151113/140613/617251.jpg@!250\" // width=\"250\" height=\"250\" alt=\"（秒杀国内价 国内同款1459）Kenneth Cole 凯尼斯·柯尔男士休闲皮鞋\"&gt; Elements es = doc.select(\".list-item img\"); // 迭代 class=\"list-item\" 节点下的 img 标签 for (Element e : es) &#123; // 商品图片的地址 String url = e.attr(\"data-src\"); // 商品图片的名称 String filename = e.attr(\"alt\"); // 商品图片文件的后缀格式名 String suffix = url.substring(url.lastIndexOf(\"/\") + 1, url.length()); suffix = suffix.substring(suffix.lastIndexOf(\".\"), suffix.length()); filename += suffix.substring(0, 4); // 下载商品图片 HttpClientUtils.download(url, \"D:/crawl/hai360/images\", filterStr(filename)); &#125; &#125; &#125; /** * 过滤特殊字串 * * @param str * 源字串 * @return 返回过滤后的字串 */ private static String filterStr(String str) &#123; String regex = \"[`~!@#$%^&amp;*()+=|&#123;&#125;':;',//[//].&lt;&gt;/?~！@#￥%……&amp;*（）——+|&#123;&#125;【】‘；：”“’。，、？]\"; Matcher m = Pattern.compile(regex).matcher(str); return m.replaceAll(\"\").trim(); &#125; &#125; 启动爬虫 1234567891011121314151617181920212223242526272829303132import edu.uci.ics.crawler4j.crawler.CrawlConfig;import edu.uci.ics.crawler4j.crawler.CrawlController;import edu.uci.ics.crawler4j.fetcher.PageFetcher;import edu.uci.ics.crawler4j.robotstxt.RobotstxtConfig;import edu.uci.ics.crawler4j.robotstxt.RobotstxtServer;/** * 启动爬虫 * * @author fanlychie */public class Controller &#123; public static void main(String[] args) throws Exception &#123; // 爬取过的 URL 记录目录 String crawlStorageFolder = \"D:/crawl/hai360\"; // 线程数 int numberOfCrawlers = 10; CrawlConfig config = new CrawlConfig(); config.setCrawlStorageFolder(crawlStorageFolder); config.setResumableCrawling(true); PageFetcher pageFetcher = new PageFetcher(config); RobotstxtConfig robotstxtConfig = new RobotstxtConfig(); RobotstxtServer robotstxtServer = new RobotstxtServer(robotstxtConfig, pageFetcher); CrawlController controller = new CrawlController(config, pageFetcher, robotstxtServer); // 种子地址, 可以添加多个 controller.addSeed(\"http://www.hai360.com/shoes-clothes.html\"); // 启动爬虫 controller.start(MyWebCrawler.class, numberOfCrawlers); &#125; &#125; 以上为爬取海360网站的商品图片，种子地址为：http://www.hai360.com/shoes-clothes.html CrawlConfig 配置项 描述 crawlStorageFolder 用于记录爬取过的 URL 目录 resumableCrawling 若设置为 true，重新启动程序可恢复爬取过程中意外发生终止的爬虫，默认为 false maxDepthOfCrawling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置爬取的深度。默认为 -1，即没有限制。第一个页面的深度为 0，第一个页面由超链接到达的第二个页面，则第二个页面的深度为 1，以此类推 maxPagesToFetch 设置页面抓取的最大数量。默认为 -1，即没有限制 userAgentString 向 Web 服务器表明你的爬虫。默认为 crawler4j (https://github.com/yasserg/crawler4j/) politenessDelay 请求前等待的毫秒数。默认为 200 毫秒。由于 crawler4j 并发高效的抓取能力，会给 Web 服务器带来一定量的压力，这可能会使 Web 服务器阻断你的请求 maxTotalConnections 设置最大连接数，默认为 100 connectionTimeout 设置连接超时，单位毫秒，默认为 30000 socketTimeout 设置读取超时，单位毫秒，默认为 20000 proxyHost 代理相关，代理服务器 proxyPort 代理相关，代理服务器端口 proxyUsername 代理相关，代理服务器账户 proxyPassword 代理相关，代理服务器密码 爬虫结果","tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/网络爬虫/"}]},{"title":"基于 memcached 的 tomcat 集群之 session 共享","date":"2015-12-05T18:22:53.000Z","path":"post/memcached-tomcat-session-share.html","text":"实现在多台服务器之间共享 session 会话中的数据。 JAR 包 asm-4.0.jar kryo-1.04.jar minlog-1.2.jar reflectasm-1.04.jar kryo-serializers-0.10.jar spymemcached-2.8.12.jar couchbase-client-1.1.4.jar msm-kryo-serializer-1.6.4.jar memcached-session-manager-1.6.4.jar memcached-session-manager-tc7-1.6.4.jar 配置将 JAR 包全部放到 $Tomcat/lib 目录下（$Tomcat 表示 Tomcat 安装的根目录，以下同）。 编辑 $Tomcat/conf/context.xml 文件，在 &lt;Context&gt; 节点下加入如下配置 12345678&lt;Manager className=&quot;de.javakaffee.web.msm.MemcachedBackupSessionManager&quot; memcachedNodes=&quot;n1:192.168.1.102:11211,n2:192.168.1.103:11211&quot; sticky=&quot;false&quot; lockingMode=&quot;auto&quot; sessionBackupAsync= &quot;false&quot; sessionBackupTimeout=&quot;300&quot; requestUriIgnorePattern= &quot;.*\\.(png|gif|jpg|ico|css|js)$&quot; transcoderFactoryClass=&quot;de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory&quot; /&gt; memcachedNodes必须项 配置 memcached 节点。格式：&lt;id&gt;:&lt;host&gt;:&lt;port&gt;，多个节点之间，用空格或英文逗号分隔 sticky可选项 是否粘性。默认为 true。粘性会话需要保证每个用户的请求都路由到同一台 Tomcat 服务器中。否则，需要设置成非粘性会话。 lockingMode可选项 用于非粘性会话。默认为 none。 可选值 描述 none 不锁定 session all 每个请求访问 session 的期间，session 一直被锁定，直到请求结束 auto 只锁定写请求的 session，只读请求的 session 不会被锁定 uriPattern:&lt;regexp&gt; 通过正则表达式的方式来对请求的 URI 进行匹配，匹配上的会被锁定 sessionBackupAsync可选项 设置 session 会话中的数据是否异步同步到 memcached 中，默认为 true。 requestUriIgnorePattern可选项 设置忽略会话同步的请求的 URI 地址的正则表达式。这应该包含静态资源的请求。 failoverNodes可选项 memcached 故障转移节点配置。用于粘性会话，非粘性会话不可用。如： failoverNodes=&quot;n1&quot;，含义是告诉 msm 将 session 会话中的数据存储到 memcached 的 n2 节点中，如果 n2 节点宕掉等致使其不能正常提供服务，msm 才会将 session 会话中的数据存储到 memcached 的 n1 节点中。 sessionAttributeFilter可选项 配置同步 session 会话数据的属性名称的正则表达式。如果不设置，则将 session 中全部的属性保存到 memcached 中。 transcoderFactoryClass可选项 配置序列化和反序列化 session 会话中的数据到 memcached 中的编码转换器的工厂类名。 默认是 de.javakaffee.web.msm.JavaSerializationTranscoderFactory backupThreadCount可选项 用于异步存储 session 会话中的数据到 memcached 中的线程数。（当 sessionBackupAsync=&quot;true&quot; 时，该配置项有效） sessionBackupTimeout可选项 备份 session 会话数据所需时间如果大于该值，将导致 session 会话数据同步失败。默认为 100（单位毫秒）","tags":[{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/缓存/"},{"name":"Memcached","slug":"Memcached","permalink":"http://yoursite.com/tags/Memcached/"}]},{"title":"jenkins 环境搭建","date":"2015-11-30T04:37:43.000Z","path":"post/jenkins-setup.html","text":"Jenkins 是基于 Java 开发的一种持续集成工具（持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误），用于监控持续重复的工作（持续的软件版本发布/测试、监控外部调用执行的工作）。 环境 CentOS6 JDK7 Maven3.2 jenkins-1.628-1.1.noarch.rpm 安装 Jenkins 1# rpm -ivh jenkins-1.628-1.1.noarch.rpm 目录结构 &nbsp; &nbsp; /usr/lib/jenkins/ war 包目录 /etc/sysconfig/jenkins 配置文件 /var/lib/jenkins/ 默认的 JENKINS_HOME 目录 /var/log/jenkins/ 日志文件目录 端口配置 为避免与 Tomcat 端口冲突，修改 /etc/sysconfig/jenkins 配置文件 123JENKINS_PORT=&quot;8082&quot;JENKINS_AJP_PORT=&quot;8029&quot; 防火墙配置 1# vi /etc/sysconfig/iptables 加入如下一行配置 1-A INPUT -m state --state NEW -m tcp -p tcp --dport 8082 -j ACCEPT 重启防火墙服务 1# service iptables restart 配置 JDK 环境 1# vi /etc/init.d/jenkins 找到如下配置 12345678910candidates=&quot;/etc/alternatives/java/usr/lib/jvm/java-1.6.0/bin/java/usr/lib/jvm/jre-1.6.0/bin/java/usr/lib/jvm/java-1.7.0/bin/java/usr/lib/jvm/jre-1.7.0/bin/java/usr/lib/jvm/java-1.8.0/bin/java/usr/lib/jvm/jre-1.8.0/bin/java/usr/bin/java&quot; 在最后加入如下一行配置（路径指定到你机器的 JDK 安装目录的 /bin/java 文件） 1/usr/local/jdk1.7.0_79/bin/java 完整配置为 1234567891011candidates=&quot;/etc/alternatives/java/usr/lib/jvm/java-1.6.0/bin/java/usr/lib/jvm/jre-1.6.0/bin/java/usr/lib/jvm/java-1.7.0/bin/java/usr/lib/jvm/jre-1.7.0/bin/java/usr/lib/jvm/java-1.8.0/bin/java/usr/lib/jvm/jre-1.8.0/bin/java/usr/bin/java/usr/local/jdk1.7.0_79/bin/java&quot; 启动 Jenkins 1# service jenkins start 重启 Jenkins 1# service jenkins restart 关闭 Jenkins 1# service jenkins stop 访问 Jenkins http://192.168.1.102:8082","tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://yoursite.com/tags/Jenkins/"}]},{"title":"基于 POI 和反射机制实现通用写出 Excel 文档文件","date":"2015-11-17T17:03:53.000Z","path":"post/poi-excel-write.html","text":"分享一个基于 POI 和反射机制实现的通用的写出 Excel 文档文件工具类，及简写出数据到 Excel 文档 源代码清单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370package org.fanlychie.excel;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.util.Date;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import org.apache.poi.ss.usermodel.CellStyle;import org.apache.poi.ss.usermodel.Font;import org.apache.poi.ss.usermodel.IndexedColors;import org.apache.poi.xssf.usermodel.XSSFCell;import org.apache.poi.xssf.usermodel.XSSFRow;import org.apache.poi.xssf.usermodel.XSSFSheet;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import org.fanlychie.util.DynaBean;/** * 可进行写操作的 EXCEL 工具类 * * @author fanlychie */public class WritableExcel &#123; // 数据列表 private List&lt;?&gt; list; // 属性名称集 private String[] props; // 标题集 private String[] title; // 动态 Bean private DynaBean dynaBean; // 工作表 private XSSFSheet sheet; // 工作表的名称 private String sheetName; // 工作簿 private XSSFWorkbook workbook; // 数据格式 private static Map&lt;Class&lt;?&gt;, String&gt; dataFormat; /** * 构造一个可写的 Excel 实例 * * @param list * 数据列表 * @param mapper * 数据对象的属性名称与Excel文档标题之间的映射关系 */ public WritableExcel(List&lt;?&gt; list, LinkedHashMap&lt;String, String&gt; mapper) &#123; init(list, mapper); &#125; /** * 写出到文件 * * @param file * 文件对象 */ public boolean write(File file) &#123; try &#123; return write(new FileOutputStream(file)); &#125; catch (FileNotFoundException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 写出到输出流 * * @param out * 输出流 */ public boolean write(OutputStream out) &#123; try &#123; // 创建工作表 sheet = workbook.createSheet(sheetName); // 构建并填充标题行 fillTitleRow(); // 主体行的索引 int rowIndex = 1; for (Object bean : list) &#123; // 创建并填充行 fillCreatedRow(rowIndex++, bean); &#125; workbook.write(out); return true; &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; finally &#123; try &#123; if (out != null) &#123; out.close(); &#125; &#125; catch (IOException e) &#123;&#125; &#125; &#125; /** * 设置工作表的名称, 默认名称 Sheet1 * * @param sheetName * 工作表的名称 */ public void setSheetName(String sheetName) &#123; this.sheetName = sheetName; &#125; /** * 设置日期格式, 默认格式 yyyy-MM-dd * * @param dateFormat * 日期格式 */ public void setDateFormat(String dateFormat) &#123; dataFormat.put(Date.class, dateFormat); &#125; /** * 初始化 * * @param list * 数据列表 * @param mapper * 数据对象的属性名称与Excel文档标题之间的映射关系 */ private void init(List&lt;?&gt; list, LinkedHashMap&lt;String, String&gt; mapper) &#123; this.list = list; int index = 0; int size = mapper.size(); props = new String[size]; title = new String[size]; // 迭代取出属性名称集和标题集 for (String prop : mapper.keySet()) &#123; props[index] = prop; title[index] = mapper.get(prop); index++; &#125; // 工作簿 this.workbook = new XSSFWorkbook(); // 动态 Bean this.dynaBean = new DynaBean(list.get(0).getClass()); // 默认的工作表名称 this.sheetName = \"Sheet1\"; &#125; /** * 构建并填充标题行 * * @throws Throwable */ private void fillTitleRow() throws Throwable &#123; // 单元格索引 int cellIndex = 0; // 单元格宽度 int cellWidth = 18 * 256; // 创建一行 XSSFRow row = sheet.createRow(0); // 设置行高 row.setHeightInPoints(25); // 标题行样式 CellStyle style = getTitleCellStyle(); // 迭代标题集 for (String text : title) &#123; // 设置宽度 sheet.setColumnWidth(cellIndex, cellWidth); // 创建单元格 XSSFCell cell = row.createCell(cellIndex++); // 设置单元格样式 cell.setCellStyle(style); // 设置单元格的值 cell.setCellValue(text); &#125; &#125; /** * 创建并填充行 * * @param index * 行的索引 * @param bean * 填充行的对象 * @throws Throwable */ private void fillCreatedRow(int index, Object bean) throws Throwable &#123; // 单元格索引 int cellIndex = 0; // 创建一行 XSSFRow row = sheet.createRow(index); // 设置行高 row.setHeightInPoints(20); // 迭代 Bean 属性集 for (String prop : props) &#123; // 属性的值 Object value = dynaBean.getFieldValue(bean, prop); // 属性类型 Class&lt;?&gt; type = dynaBean.getFieldType(prop); // 创建单元格 XSSFCell cell = row.createCell(cellIndex++); // 值为空 if (value == null) &#123; // 设置为空串 cell.setCellValue(\"\"); // 单元格样式 cell.setCellStyle(getBodyCellStyle(String.class)); &#125; else &#123; // 按类型设值 if (type == Boolean.TYPE || type == Boolean.class) &#123; boolean boolValue = Boolean.parseBoolean(value.toString()); cell.setCellValue(boolValue); &#125; else if ((Number.class.isAssignableFrom(type) || type.isPrimitive()) &amp;&amp; type != Byte.TYPE &amp;&amp; type != Character.TYPE) &#123; double doubleValue = Double.parseDouble(value.toString()); cell.setCellValue(doubleValue); &#125; else if (type == Date.class) &#123; Date dateValue = (Date) value; cell.setCellValue(dateValue); &#125; else &#123; cell.setCellValue(value.toString()); &#125; // 单元格样式 cell.setCellStyle(getBodyCellStyle(type)); &#125; &#125; &#125; /** * 主体单元格样式 * * @param type * 单元格填充的数据的类型 * @return CellStyle */ private CellStyle getBodyCellStyle(Class&lt;?&gt; type) &#123; // 单元格样式 CellStyle style = workbook.createCellStyle(); // 单元格数据格式 String cellDataFormat = dataFormat.get(type); if (cellDataFormat == null) &#123; cellDataFormat = dataFormat.get(String.class); &#125; // 水平居中 style.setAlignment(CellStyle.ALIGN_CENTER); // 垂直居中 style.setVerticalAlignment(CellStyle.VERTICAL_CENTER); // 背景颜色 setBackgroundColor(style, IndexedColors.LIGHT_TURQUOISE.index); // 字体 style.setFont(getFont(11, IndexedColors.GREY_50_PERCENT.index)); // 数据格式 style.setDataFormat(workbook.createDataFormat().getFormat(cellDataFormat)); // 自动换行 style.setWrapText(true); return style; &#125; /** * 标题行样式 * * @return CellStyle */ private CellStyle getTitleCellStyle() &#123; // 单元格样式 CellStyle style = workbook.createCellStyle(); // 水平居中 style.setAlignment(CellStyle.ALIGN_CENTER); // 垂直居中 style.setVerticalAlignment(CellStyle.VERTICAL_CENTER); // 背景颜色 setBackgroundColor(style, IndexedColors.YELLOW.index); // 字体 style.setFont(getFont(12, IndexedColors.BLUE_GREY.index)); // 数据格式 style.setDataFormat(workbook.createDataFormat().getFormat(\"GENERAL\")); // 自动换行 style.setWrapText(true); return style; &#125; /** * 设置单元格背景颜色 * * @param style * 单元格样式 * @param color * 颜色值 */ private void setBackgroundColor(CellStyle style, short color) &#123; // 边框设置 style.setBorderBottom(CellStyle.BORDER_THIN); style.setBorderLeft(CellStyle.BORDER_THIN); style.setBorderRight(CellStyle.BORDER_THIN); style.setBorderTop(CellStyle.BORDER_THIN); // 边框颜色 style.setBottomBorderColor(IndexedColors.GREY_25_PERCENT.index); style.setLeftBorderColor(IndexedColors.GREY_25_PERCENT.index); style.setRightBorderColor(IndexedColors.GREY_25_PERCENT.index); style.setTopBorderColor(IndexedColors.GREY_25_PERCENT.index); // 背景颜色 style.setFillPattern(CellStyle.SOLID_FOREGROUND); style.setFillForegroundColor(color); &#125; /** * 获取字体 * * @param fontSize * 字体大小 * @param fontColor * 字体颜色 * @return Font */ private Font getFont(int fontSize, short fontColor) &#123; // 创建字体 Font font = workbook.createFont(); // 字体颜色 font.setColor(fontColor); // 字体大小 font.setFontHeightInPoints((short) fontSize); // 字体名称 if (System.getProperty(\"os.name\").contains(\"Windows\")) &#123; font.setFontName(\"Microsoft YaHei\"); &#125; return font; &#125; // 数据格式 static &#123; dataFormat = new HashMap&lt;Class&lt;?&gt;, String&gt;(); dataFormat.put(Short.TYPE, \"0\"); dataFormat.put(Short.class, \"0\"); dataFormat.put(Integer.TYPE, \"0\"); dataFormat.put(Integer.class, \"0\"); dataFormat.put(Long.TYPE, \"0\"); dataFormat.put(Long.class, \"0\"); dataFormat.put(Float.TYPE, \"0.00\"); dataFormat.put(Float.class, \"0.00\"); dataFormat.put(Double.TYPE, \"0.00\"); dataFormat.put(Double.class, \"0.00\"); dataFormat.put(String.class, \"GENERAL\"); dataFormat.put(Date.class, \"yyyy-MM-dd\"); &#125; &#125; POI 依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt; 测试对象清单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public static class Person &#123; private int id; private String name; private boolean local; private Date birthday; public Person() &#123; &#125; public Person(int id, String name, boolean local, Date birthday) &#123; this.id = id; this.name = name; this.local = local; this.birthday = birthday; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public boolean isLocal() &#123; return local; &#125; public void setLocal(boolean local) &#123; this.local = local; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; &#125; 测试清单1 1234567891011121314151617181920212223242526272829private static DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\");public static void main(String[] args) throws Throwable &#123; File excelFile = new File(\"src/test/resources/test_excel.xlsx\"); List&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); for (int i = 1; i &lt; 10; i++) &#123; list.add(new Person(i, \"范忠云\" + i, i % 2 == 0, format.parse(\"1990-04-0\" + i))); &#125; // 属性与 Excel 列的映射关系 LinkedHashMap&lt;String, String&gt; mapper = new LinkedHashMap&lt;String, String&gt;(); mapper.put(\"id\", \"编号\"); mapper.put(\"name\", \"姓名\"); mapper.put(\"local\", \"本地户口\"); mapper.put(\"birthday\", \"出生日期\"); // 创建一个可写的 Excel 对象 WritableExcel excel = new WritableExcel(list, mapper); // 写出 Excel 文档文件 boolean success = excel.write(excelFile); if (success) &#123; System.out.println(\"Excel 生成成功！\"); &#125; &#125; 测试结果","tags":[{"name":"工具类","slug":"工具类","permalink":"http://yoursite.com/tags/工具类/"}]},{"title":"基于 POI 和反射机制实现通用读取 Excel 表格数据","date":"2015-11-17T15:46:35.000Z","path":"post/poi-excel-read.html","text":"分享一个基于 POI 和反射机制实现的通用的读取 Excel 表格数据工具类，读取 Excel 表格数据只需 2 行代码 源代码清单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256package org.fanlychie.excel;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.InputStream;import java.util.ArrayList;import java.util.Date;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import org.apache.poi.ss.usermodel.Cell;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.ss.usermodel.Sheet;import org.apache.poi.ss.usermodel.Workbook;import org.apache.poi.ss.usermodel.WorkbookFactory;import org.fanlychie.util.DynaBean;/** * 可进行读操作的 EXCEL 工具类 * * @author fanlychie */public class ReadableExcel &#123; // 工作表 private Sheet sheet; // 工作表索引 private int sheetIndex; // Excel 列 与 Bean 属性的顺序映射集 private Map&lt;Integer, String&gt; mapper; // 动态 Bean private DynaBean dynaBean; // 最大解析的单元格索引 private int maxColumnIndex; /** * 构造可读的 Excel 实例 * * @param file * Excel 文件 */ public ReadableExcel(File file) &#123; try &#123; init(new FileInputStream(file)); &#125; catch (FileNotFoundException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 构造可读的 Excel 实例 * * @param in * Excel 文件输入流 */ public ReadableExcel(InputStream in) &#123; init(in); &#125; /** * 解析 Excel 文档到一个 List 列表, 约定第一行为标题行, 标题行不被解析 * * @param beanClass * 简单的 JavaBean 类型, Excel 文档的每一行解析成该类的一个实例 * @param mapper * Excel 文档的列映射到 JavaBean 对象的属性列表&lt;br&gt; * 格式串 A：[\"prop_name1\", \"prop_name2\", ...]&lt;br&gt; * 格式串 B：[\"1:prop_name1\", \"2:prop_name2\", ...] * @return 返回解析 Excel 文档的 List 结果列表 */ public &lt;T&gt; List&lt;T&gt; asList(Class&lt;T&gt; beanClass, String... mapper) &#123; // 解析映射对照表 this.mapper = parseMapper(mapper); // 实例化一个动态 Bean 对象 this.dynaBean = new DynaBean(beanClass); List&lt;T&gt; beanList = new ArrayList&lt;T&gt;(); // 工作表的行集 Iterator&lt;Row&gt; rows = sheet.iterator(); // 约定第一行为标题行, 不解析 Row rowOfTitle = rows.next(); // 实际的总的列数 this.maxColumnIndex = rowOfTitle.getPhysicalNumberOfCells(); // 迭代工作表的行集 while (rows.hasNext()) &#123; @SuppressWarnings(\"unchecked\") T bean = (T) parseRow(rows.next()); beanList.add(bean); &#125; return beanList; &#125; /** * 设置读取的工作表的索引 * * @param sheetIndex * 工作表的索引 */ public void setSheetIndex(int sheetIndex) &#123; this.sheetIndex = sheetIndex; &#125; /** * 初始化工作表 * * @param in * Excel 输入流 */ private void init(InputStream in) &#123; try &#123; // 工作薄 Workbook workbook = WorkbookFactory.create(in); // 获取索引指定的工作表 sheet = workbook.getSheetAt(sheetIndex); &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 解析 Excel 文档的一行到一个 Bean 的对象里 * * @param row * Excel 文档中的行对象 * @return 返回解析行的 Bean 对象 */ private Object parseRow(Row row) &#123; // 创建一个 Bean 的实例 dynaBean.newBeanInstance(); // 行的单元格列表 Iterator&lt;Cell&gt; cells = row.cellIterator(); // 迭代单元格列表 while (cells.hasNext()) &#123; // 单元格 Cell cell = cells.next(); // 当前的单元格的索引 int columnIndex = cell.getColumnIndex(); // 索引超出最大解析的索引值结束迭代 if (columnIndex &gt;= maxColumnIndex) &#123; break; &#125; // 单元格映射到 Bean 的属性名称 String name = mapper.get(columnIndex); // 如果不在对照表内, 跳过该列 if (name == null) &#123; continue ; &#125; // 单元格映射到 Bean 的属性类型 Class&lt;?&gt; type = dynaBean.getFieldType(name); // 单元格映射到 Bean 的属性的值 Object value; if (type == Date.class) &#123; value = cell.getDateCellValue(); &#125; else &#123; // 设置单元格的类型为字符串类型 cell.setCellType(Cell.CELL_TYPE_STRING); // 获取单元格字符串内容的值 String stringCellValue = cell.getStringCellValue(); // 进行数据类型转换 value = commonTypeConvert(stringCellValue, type); &#125; // 设置到 Bean 对象 dynaBean.setFieldValue(name, value); &#125; // 返回 Bean 的实例 return dynaBean.getBean(); &#125; /** * 解析映射的字符串 * * @param mapper * 格式串 A：[\"prop_name1\", \"prop_name2\", ...] * 格式串 B：[\"1:prop_name1\", \"2:prop_name2\", ...] * @return 返回解析后的对照表 */ private Map&lt;Integer, String&gt; parseMapper(String... mapper) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(); String item; int length = mapper.length; for (int i = 0; i &lt; length; i++) &#123; item = mapper[i]; if (item.contains(\":\")) &#123; String[] items = item.split(\":\"); map.put(Integer.valueOf(items[0]), items[1]); &#125; else &#123; map.put(i, item); &#125; &#125; return map; &#125; /** * 常用的数据类型转换 * * @param value * 被转换的对象 * @param type * 期望得到的类型 * @return 返回转换后的数据类型对象 */ private Object commonTypeConvert(String value, Class&lt;?&gt; type) &#123; if (type == String.class) &#123; return value; &#125; if (type == Character.TYPE || type == Character.class) &#123; return value.charAt(0); &#125; if (type == Boolean.TYPE || type == Boolean.class) &#123; // 真值 if (value == \"1\" || value.equals(\"是\") || value.equalsIgnoreCase(\"Y\") || value.equalsIgnoreCase(\"YES\") || value.equalsIgnoreCase(\"T\") || value.equalsIgnoreCase(\"TRUE\")) &#123; return true; &#125; // 假值 if (value == \"0\" || value.equals(\"否\") || value.equalsIgnoreCase(\"N\") || value.equalsIgnoreCase(\"NO\") || value.equalsIgnoreCase(\"F\") || value.equalsIgnoreCase(\"FALSE\")) &#123; return false; &#125; &#125; // 解析成双精度类型 Double objVal = Double.valueOf(value); // 以下均基于双精度数据上作的类型转换 if (type == Byte.TYPE || type == Byte.class) &#123; return objVal.byteValue(); &#125; if (type == Short.TYPE || type == Short.class) &#123; return objVal.shortValue(); &#125; if (type == Integer.TYPE || type == Integer.class) &#123; return objVal.intValue(); &#125; if (type == Long.TYPE || type == Long.class) &#123; return objVal.longValue(); &#125; if (type == Float.TYPE || type == Float.class) &#123; return objVal.floatValue(); &#125; if (type == Double.TYPE || type == Double.class) &#123; return objVal; &#125; throw new ClassCastException(\"Cannot cast java.lang.String to \" + type.getName()); &#125;&#125; POI 依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt; 测试对象清单 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public static class Person &#123; private int id; private String name; private String sex; private boolean local; private Date birthday; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public boolean isLocal() &#123; return local; &#125; public void setLocal(boolean local) &#123; this.local = local; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getBirthdayStr() &#123; if (birthday == null) &#123; return null; &#125; return new SimpleDateFormat(\"yyyy-MM-dd\").format(birthday); &#125; @Override public String toString() &#123; return id + \"\\t\" + name + \"\\t\" + sex + \"\\t\" + local + \"\\t\" + getBirthdayStr(); &#125; &#125; 测试 Excel 表格数据清单 测试清单1 1234567891011121314151617public static void main(String[] args) &#123; File excelFile = new File(\"src/test/resources/person_excel.xlsx\"); // 创建一个可读的 Excel 对象 ReadableExcel excel = new ReadableExcel(excelFile); // 解析 Excel 数据为 JavaBean 对象 List&lt;Person&gt; persons = excel.asList(Person.class, \"id\", \"name\", \"sex\", \"local\", \"birthday\"); for (Person person : persons) &#123; System.out.println(person); &#125; &#125; 解析语法1：[&quot;id&quot;, &quot;name&quot;, &quot;sex&quot;, &quot;local&quot;, &quot;birthday&quot;] 从左至右依次对应 Excel 表格的列数据 测试结果 12345678910111213141516171 刘一 男 false 1990-04-022 陈二 男 false 1991-08-013 张三 女 false 1990-04-014 李四 女 false 1992-05-045 王五 女 true 1992-05-026 赵六 男 true 1991-07-067 孙七 女 true 1990-09-038 周八 女 false 1990-03-059 吴九 男 true 1993-01-03 测试清单2 1234567891011121314151617public static void main(String[] args) &#123; File excelFile = new File(\"src/test/resources/person_excel.xlsx\"); // 创建一个可读的 Excel 对象 ReadableExcel excel = new ReadableExcel(excelFile); // 解析 Excel 数据为 JavaBean 对象 List&lt;Person&gt; persons = excel.asList(Person.class, \"0:id\", \"2:name\", \"1:sex\"); for (Person person : persons) &#123; System.out.println(person); &#125; &#125; 解析语法2：[&quot;0:id&quot;, &quot;2:name&quot;, &quot;1:sex&quot;] 只提取想要的列的数据（0 代表第 1 列） &quot;2:name&quot; 表示将 Excel 表格第 3 列的数据解析成 JavaBean 对象的 name 属性的值 [&quot;0:id&quot;, &quot;2:name&quot;, &quot;1:sex&quot;] 等效于 [&quot;id&quot;, &quot;2:name&quot;, &quot;1:sex&quot;]，其余类似，可灵活提取表格数据 场景： 我们公司使用的短信供应商目前已有 3 家，在统计数据的时候，需要先在供应商短信系统导出短信 消息的 Excel 文档然后统计相关信息，但是不同供应商导出的 Excel 模板文件格式不一致，因此衍生 了这种解析 Excel 表格数据的处理方法。 假设供应商 A 导出的手机号码在第 2 列，供应商 B 导出的手机号码在第 3 列，我们可以这样做： 供应商 A 使用 &quot;1:mobile&quot; 供应商 B 使用 &quot;2:mobile&quot; 这样一来，我们只需要根据不同的供应商传整数值定向解析列的数据即可，这样可以适配多个不同 的 Excel 模板，只要 2 行代码完成解析工作 注：非公开公司代码，纯为个人积累及思考编码实现 测试结果 12345678910111213141516171 男 刘一 false null2 男 陈二 false null3 女 张三 false null4 女 李四 false null5 女 王五 false null6 男 赵六 false null7 女 孙七 false null8 女 周八 false null9 男 吴九 false null [&quot;0:id&quot;, &quot;2:name&quot;, &quot;1:sex&quot;] 这里故意将 name 和 sex 倒了过来，将第 2 列解析成 sex，第 3 列解析成 name，以示区分","tags":[{"name":"工具类","slug":"工具类","permalink":"http://yoursite.com/tags/工具类/"}]},{"title":"基于反射机制实现动态操纵 JavaBean","date":"2015-11-17T14:39:29.000Z","path":"post/java-reflect-bean.html","text":"分享一个基于反射机制实现的动态操纵 JavaBean 的工具类 源代码清单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146package org.fanlychie.util;import java.util.Map;import java.util.HashMap;import java.lang.reflect.Field;import java.lang.reflect.Modifier;/** * 动态 Bean * * @author 范忠云（fanlychie） */public class DynaBean &#123; // Bean 对象 private Object bean; // Bean 类型 private Class&lt;?&gt; beanClass; // Bean 对象的非静态属性对照表 private Map&lt;String, Field&gt; beanProps; /** * 实例化一个动态 Bean * * @param beanClass * Bean 类型 */ public DynaBean(Class&lt;?&gt; beanClass) &#123; this.beanClass = beanClass; this.beanProps = getDeclaredFieldsMap(beanClass); &#125; /** * 实例化一个 Bean 对象 */ public void newBeanInstance() &#123; try &#123; bean = beanClass.newInstance(); &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 获取属性的类型 * * @param name * 属性名称 * @return 返回属性的类型 */ public Class&lt;?&gt; getFieldType(String name) &#123; Field field = beanProps.get(name); if (field == null) &#123; throw new RuntimeException(castExceptionMessage(name)); &#125; return field.getType(); &#125; /** * 设置属性的值 * * @param name * 属性名称 * @param value * 属性的值 */ public void setFieldValue(String name, Object value) &#123; Field field = beanProps.get(name); if (field == null) &#123; throw new RuntimeException(castExceptionMessage(name)); &#125; try &#123; field.set(bean, value); &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 获取属性的值 * * @param bean * 对象 * @param name * 属性名称 * @return 返回对象中属性的值 */ public Object getFieldValue(Object bean, String name) &#123; Field field = beanProps.get(name); if (field == null) &#123; throw new RuntimeException(castExceptionMessage(name)); &#125; try &#123; return field.get(bean); &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 获取 Bean 的实例 * * @return 返回 Bean 的实例 */ public Object getBean() &#123; return bean; &#125; /** * 获取类声明的非静态属性表 * * @param beanClass * 类 * @return 返回类声明的非静态属性表 */ private Map&lt;String, Field&gt; getDeclaredFieldsMap(Class&lt;?&gt; beanClass) &#123; // 获取类声明的属性集合 Field[] fields = beanClass.getDeclaredFields(); Map&lt;String, Field&gt; map = new HashMap&lt;String, Field&gt;(); // 迭代属性集合 for (Field field : fields) &#123; // 剔除静态属性 if ((field.getModifiers() &amp; Modifier.STATIC) != Modifier.STATIC) &#123; // 强行设置成可访问 field.setAccessible(true); map.put(field.getName(), field); &#125; &#125; return map; &#125; /** * 异常信息 * * @param name * 属性名称 * @return 返回异常信息 */ private String castExceptionMessage(String name) &#123; return String.format(&quot;Can not found property \\&quot;%s\\&quot; in class %s&quot;, name, beanClass.getSimpleName()); &#125; &#125; 测试对象清单12345678910111213141516171819202122232425262728public class Person &#123; private String name; private String sex; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; @Override public String toString() &#123; return &quot;Person [name=&quot; + name + &quot;, sex=&quot; + sex + &quot;]&quot;; &#125; &#125; 测试清单11234567891011121314151617181920212223242526public static void main(String[] args) &#123; List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;(); // 创建动态 Bean 实例 DynaBean dynaBean = new DynaBean(Person.class); // 创建一个 Bean 的实例 dynaBean.newBeanInstance(); // 设置 Bean 属性的值 dynaBean.setFieldValue(&quot;name&quot;, &quot;张三&quot;); dynaBean.setFieldValue(&quot;sex&quot;, &quot;男&quot;); // 取出 Bean 对象 persons.add((Person) dynaBean.getBean()); // 创建一个 Bean 的实例 dynaBean.newBeanInstance(); // 设置 Bean 属性的值 dynaBean.setFieldValue(&quot;name&quot;, &quot;李四&quot;); dynaBean.setFieldValue(&quot;sex&quot;, &quot;女&quot;); // 取出 Bean 对象 persons.add((Person) dynaBean.getBean()); System.out.println(persons); &#125; 使用场景可参考 ReadableExcel - 基于 POI 和反射机制实现通用读取 Excel 表格数据 测试结果1[Person [name=张三, sex=男], Person [name=李四, sex=女]] 测试清单212345678910111213141516171819202122232425262728public static void main(String[] args) &#123; List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;(); Person person1 = new Person(); person1.setName(&quot;张三&quot;); person1.setSex(&quot;男&quot;); persons.add(person1); Person person2 = new Person(); person2.setName(&quot;李四&quot;); person2.setSex(&quot;女&quot;); persons.add(person2); // 创建动态 Bean 实例 DynaBean dynaBean = new DynaBean(Person.class); for (Person person : persons) &#123; System.out.println(String.format(&quot;[name=%s, sex=%s]&quot;, // 获取 Bean 对象的 name 属性的值 dynaBean.getFieldValue(person, &quot;name&quot;), // 获取 Bean 对象的 sex 属性的值 dynaBean.getFieldValue(person, &quot;sex&quot;))); &#125;&#125; 使用场景可参考 WritableExcel - 基于 POI 和反射机制实现通用写出 Excel 文档文件 测试结果123[name=张三, sex=男][name=李四, sex=女]","tags":[{"name":"工具类","slug":"工具类","permalink":"http://yoursite.com/tags/工具类/"}]},{"title":"nginx 防盗链配置","date":"2015-11-14T18:00:16.000Z","path":"post/nginx-anti-theft-chain.html","text":"以图片资源为例 12345678910111213location ~ \\.(gif|jpg|jpeg|png|ico)$ &#123; valid_referers none blocked fanlychie.com www.fanlychie.com; if ($invalid_referer) &#123; return 403; &#125; expires 7d;&#125; 来路是 fanlychie.com 或 www.fanlychie.com 的请求图片正常显示 如一个 http://aabb.com 的站点发起一个 http://fanlychie.com/aabb.png 的请求，nginx 会拒绝 该请求，并给它返回 403 状态码，在 http://aabb.com 站点看到的图是一个破图","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"nginx 负载均衡配置","date":"2015-11-13T07:42:32.000Z","path":"post/nginx-slb.html","text":"配置文件的位置：/usr/local/nginx/conf/nginx.conf user1#user www www; nginx 运行的用户和用户组，默认为 nobody pid1pid logs/nginx.pid; 进程文件配置，默认为 logs/nginx.pid error_log1error_log logs/error.log warn; 错误日志配置。 日志级别可选：debug &lt; info &lt; notice &lt; warn &lt; error &lt; crit 日志级别越高，记录的日志信息越少 worker_processes1worker_processes 1; nginx 对外提供 web 服务的 worder 进程数。通常设置和 cpu 核数的数量相等 worker_rlimit_nofile1worker_rlimit_nofile 1024; 一个 worker 进程能打开的文件的最大数目。 理论值应该是系统最多能打开的文件数（在 linux 中执行 ulimit -n 可得到值）与 worker 进程数相 除得到的值，但是 nginx 分配请求并不均匀，建议与 ulimit -n 的值保持一致 events1234567events &#123; worker_connections 1024; use epoll;&#125; worker_connections1worker_connections 1024; 设置单个 worker 进程最大连接数 use1use epoll; 设置复用客户端线程的轮询方法 use &nbsp;[ &nbsp;kqueue&nbsp; | &nbsp;rtsig&nbsp; | &nbsp;epoll&nbsp; | &nbsp;select&nbsp; | &nbsp;poll&nbsp; ] epoll 是 linux 2.6 以上版本内核中的高性能网络 I / O 模型 如果不设置，nginx 会选择一个最适合你操作系统的模型 http123http &#123;&#125; http 服务器配置 include1include mime.types; 设置 MIME 类型（资源的媒体类型），通过 http 协议由 web 服务器返回给客户端浏览器，浏览器会自动使用指定应用程序来打开资源文件 mime.types 文件位于 /usr/local/nginx/conf/mime.types default_type1default_type application/octet-stream; 默认的资源文件的媒体类型，application/octet-stream 为任意的二进制数据流传输 log_format123log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; 日志格式。&quot;log_format &nbsp;main&quot;&nbsp; 这里的 main 是日志格式的名称，通过不同名称来定义多种日志格式 参数 描述 $remote_addr 客户端 IP 地址 $http_x_forwarded_for 客户端 IP 地址 $remote_user 客户端用户名 $time_local 访问时间和时区 $http_host 请求主机（域名） $request 请求的 uri 和 http 协议 $http_referer url 跳转来源（从哪个页面链接访问过来的） $status http 请求状态 $request_time 处理请求的时间 $body_bytes_sent 发送给客户端文件的主体内容大小 $http_user_agent 客户端浏览器信息 access_log1access_log logs/access.log main; 配置访问日志。可以指定使用的日志格式，如这里的 main charset1charset UTF-8; 使用的字符集编码 sendfile1sendfile on; 通过调用 sendfile 函数（sendfile 是一个系统调用，在内核空间中完成），可以高效的发送静态文件 tcp_nopush1tcp_nopush on; 一次性发送数据包。与 tcp_nodelay 配置项互斥，与 sendfile 配合工作 tcp_nodelay1#tcp_nodelay on; 每 0.2 秒后立即发送一个数据包，可以有效的防止网络阻塞，当需要及时发送数据时，应该开启它 keepalive_timeout1keepalive_timeout 60; 配置长连接的超时时间。服务器将在这个超时时间过后关闭链接 client_header_timeout1client_header_timeout 120; 等待客户端发送一个请求头的超时时间，超时 Nginx 返回一个请求超时的状态码（408，Request Timeout） client_body_timeout1client_body_timeout 120; 等待客户端发送一个请求体的超时时间，超时 Nginx 返回一个请求超时的状态码（408，Request Timeout） send_timeout1send_timeout 120; 客户端读取数据的超时时间，超时 Nginx 就会关闭该连接 client_header_buffer_size1client_header_buffer_size 16k; 缓存客户端请求头的大小 large_client_header_buffers1large_client_header_buffers 4 32k; 缓存客户端请求头的最大大小，此处为 4 个 32K 的大小 gzip1gzip on; 采用 gzip 压缩的形式发送数据，可以减少发送的数据量 gzip_min_length1gzip_min_length 1k; 大于该值的内容才压缩，0 表示所有的内容都压缩 gzip_buffers1gzip_buffers 4 16k; 缓存 gzip 压缩数据的空间大小，此处为 4 个 16K 的大小 gzip_types1gzip_types text/plain text/css application/x-javascript application/xml; 只有匹配配置的 MIME 类型的文档内容才会被压缩 nginx 默认会对 text/html 类型进行压缩，此处无需再配，若配置 text/html，nginx 会发出警告： nginx: [ warn ] duplicate MIME type &quot;text/html&quot; server_names_hash_bucket_size1server_names_hash_bucket_size 128; 服务器名称的 hash 表大小，如果太小，Nginx 无法启动 server123server &#123;&#125; 虚拟主机配置 listen1listen 80; 监听端口 server_name1server_name fanlychie.com www.fanlychie.com; 域名，可以配置多个，以空格分开 access_log1access_log logs/fanlychie.access.log main; 虚拟主机访问日志。 root1root www.fanlychie.com; 网站根目录，用于存放网站静态资源文件。若为相对路径，则是相对于 nginx 安装的目录。如此处的物理路径为 /usr/local/nginx/www.fanlychie.com location123location / &#123;&#125; 配置请求处理的方式 语法 描述 / 通用配置，可匹配任意请求的 url 地址 = 精确匹配 url 地址 ~ 区分大小写的正则表达式匹配 url 地址 ~* 不区分大小写的正则表达式匹配 url 地址 ^~ 禁止正则表达式的普通字串匹配 url 地址 多个 location 匹配 url 地址的优先级： &quot;=&quot; 被匹配，停止搜索其他匹配 &quot;^~&quot; 被匹配，停止搜索其他匹配 &quot;~&quot; 和 &quot;~*&quot; 按配置文件中出现的先后顺序，一旦匹配，停止搜索其他匹配 若以上都没有匹配到，则交给 &quot;/&quot; 处理请求 expires12345location ~ \\.(js|css)$ &#123; expires 1d;&#125; js 和 css 文件由 nginx 直接提供，缓存一天 如客户端访问 http://www.fanlychie.com/styles/main.css 由于上面已经配置 root &nbsp;www.fanlychie.com，nginx 会将 /usr/local/nginx/www.fanlychie.com/styles/main.css 文件直接返回给客户端 12345location ~ \\.(gif|jpg|jpeg|png|ico)$ &#123; expires 7d;&#125; 同上面，图片文件缓存 7 天 deny12345location ~* \\.jsp &#123; deny all;&#125; 禁止直接访问 *.jsp 文件（返回 403 状态码给客户端） proxy_pass1234567891011location = / &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://www.fanlychie.com/index;&#125; proxy_pass 配置反向代理 即通过域名访问网站首页，nginx 将请求转发给真实的运用服务器处理，即 http://www.fanlychie.com/index&nbsp;（www.fanlychie.com 是上面配置的 server_name 的名称） proxy_set_header设置请求报头域的值 参数 描述 Host 指定请求的服务器的域名和端口号 X-Forwarded-For&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用于记录代理 IP 信息每经过一级代理（匿名代理除外），代理服务器都会把这次请求的来源 IP追加在 X-Forwarded-For 中。一个 IP 来自 4.4.4.4 的请求，请求头中可能包含这样一行X-Forwarded-For&nbsp; : &nbsp;1.1.1.1, &nbsp;2.2.2.2, &nbsp;3.3.3.3 X-Real-IP 用于记录真实发出请求的客户端 IP上面的例子，如果配置了 X-Read-IP，将会是X-Real-IP&nbsp; : &nbsp;1.1.1.1 Referer url 跳转来源（从哪个页面链接访问过来的） 12345678910111213141516171819202122232425location / &#123; proxy_pass http://www.fanlychie.com; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 90; proxy_send_timeout 90; proxy_read_timeout 90; proxy_buffers 32 4k;&#125; proxy_redirectproxy_redirect 与 proxy_pass 用法类似，proxy_pass 是转发请求，客户端 url 地址不变； proxy_redirect 是请求重定向，客户端 url 地址发生变化。 client_max_body_size允许客户端请求的最大单文件字节数 client_body_buffer_size代理缓冲用户端请求的缓冲区最大字节数 proxy_connect_timeout代理连接超时时间（nginx 跟后端服务器连接超时时间） proxy_send_timeout代理发送超时时间（后端服务器数据回传时间） proxy_read_timeout代理接收超时时间（连接成功后，后端服务器响应时间） proxy_buffers代理缓冲区的大小 error_page1234567891011121314151617181920212223location = /403.html &#123; root html;&#125;location = /404.html &#123; root html;&#125;location = /50x.html &#123; root html;&#125;error_page 403 /403.html;error_page 404 /404.html;error_page 500 502 503 504 /50x.html; 错误页面配置。 upstream1234567upstream www.fanlychie.com &#123; server 192.168.1.102:8080; server 192.168.1.103:8080;&#125; 负载均衡配置 upstream &nbsp;www.fanlychie.com，此处的 www.fanlychie.com 是上面 server 模块配置的 server_name。server 指定真实的运用服务主机地址，可以配置多个。 nginx 默认采用轮询的策略，将请求平均的分配到各个运用服务主机中，当其中一台服务主机宕机 后，会自动的被剔除，另外一台服务主机仍然能正常提供服务。 weight1234567upstream www.fanlychie.com &#123; server 192.168.1.102:8080 weight=1; server 192.168.1.103:8080 weight=2;&#125; 在轮询的基础上加上权重，数值越大，表示权值越大，nginx 分发的请求越多 用于运用服务器性能不均的情况。当其中一台服务主机宕机后，会自动的被剔除，另外一台服务主 机仍然能正常提供服务 ip_hash123456789upstream www.fanlychie.com &#123; ip_hash; server 192.168.1.102:8080; server 192.168.1.103:8080;&#125; 每个请求按访问 ip 的 hash 结果分配服务主机 当新的请求到达时，先将用户 ip 通过哈希算法求值，在随后的请求客户端 ip 的哈希值只要相同， 就会被分配至同一个后端服务器，这种调度可以解决 session 共享的问题，但有时会导致分配不均 即无法保证负载均衡 附完整配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#user nobody;pid logs/nginx.pid;worker_processes 1;worker_rlimit_nofile 1024;error_log logs/error.log warn;events &#123; worker_connections 1024; use epoll;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; charset UTF-8; sendfile on; tcp_nopush on; #tcp_nodelay on; keepalive_timeout 60; client_header_timeout 120; client_body_timeout 120; send_timeout 120; client_header_buffer_size 16k; large_client_header_buffers 4 32k; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_types text/plain text/css application/x-javascript application/xml; server_names_hash_bucket_size 128; upstream www.fanlychie.com &#123; server 192.168.1.102:8080; server 192.168.1.103:8080; &#125; server &#123; listen 80; server_name fanlychie.com www.fanlychie.com; access_log logs/fanlychie.access.log main; root www.fanlychie.com; location = / &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://www.fanlychie.com/index; &#125; location ~ \\.(js|css)$ &#123; expires 1d; &#125; location ~ \\.(gif|jpg|jpeg|png|ico)$ &#123; expires 7d; &#125; location ~* \\.jsp &#123; deny all; &#125; location / &#123; proxy_pass http://www.fanlychie.com; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 90; proxy_send_timeout 90; proxy_read_timeout 90; proxy_buffers 32 4k; &#125; location = /403.html &#123; root html; &#125; location = /404.html &#123; root html; &#125; location = /50x.html &#123; root html; &#125; error_page 404 /404.html; error_page 403 /403.html; error_page 500 502 503 504 /50x.html; &#125;&#125; 附全局变量表 变量 描述 $args 请求的参数 $content_length 请求头中的 Content-length 域的值 $content_type 请求头中的 Content-Type 域的值 $host 请求主机域的值，否则为服务器名称 $http_user_agent 客户端 agent 信息 $http_cookie 客户端 cookie 信息 $request_method 客户端请求的动作，通常为 GET 或 POST $remote_addr 客户端的 IP 地址 $remote_port 客户端的端口 $remote_user 已经经过 Auth Basic Module 验证的用户名 $request_filename 当前请求的文件路径 $query_string 与 $args 同 $scheme HTTP 方法（如 http，https） $server_protocol 请求使用的协议，通常是 HTTP/1.0 或 HTTP/1.1 $server_addr 服务器地址，在完成一次系统调用后可以确定这个值 $server_name 服务器名称 $server_port 请求到达服务器的端口号 $request_uri 包含请求参数的原始 URI，不包含主机名，如：&quot;/foo/bar.php?arg=baz&quot; $uri 不带请求参数的当前 URI，$uri 不包含主机名，如 &quot;/foo/bar.html&quot; $document_uri 与 $uri 同 附表达式列表 表达式 表达式 描述 -f !-f 判断文件是否存在 -d !-d 判断目录是否存在 -e !-e 判断文件或目录是否存在 -x !-x 判断文件是否可执行","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"nginx 安装","date":"2015-11-13T06:10:17.000Z","path":"post/nginx-setup.html","text":"nginx 是一个高性能的 HTTP 和反向代理服务器，它具有很多非常优越的特性，支持高并发和高效的负载均衡，目前，包括百度、新浪、网易、腾讯等知名网站已经开始使用 nginx 作为 WEB 应用服务器。 安装环境 CentOS 6.5 pcre-8.36.tar.gz zlib-1.2.8.tar.gz openssl-1.0.2d.tar.gz nginx-1.8.0.tar.gz 将下载的文件全部上传至服务器 /usr/local/src 目录下 安装 pcre 12345# tar xzvf pcre-8.36.tar.gz# cd pcre-8.36# ./configure# make# make install 若执行 ./configure 报错： configure: error: You need a C++ compiler for C++ support 则需要先安装 C++（pcre 模块需要 C++ 编译） 安装 C++（若已安装，跳过此步骤） 1# yum install -y gcc gcc-c++ 安装 zlib 12345# tar xzvf zlib-1.2.8.tar.gz# cd zlib-1.2.8# ./configure# make# make install 安装 openssl 12345# tar xzvf openssl-1.0.2d.tar.gz# cd openssl-1.0.2d# ./config# make# make install 安装 nginx 12345# tar xzvf nginx-1.8.0.tar.gz# cd nginx-1.8.0# ./configure# make# make install 建立 pcre 库链接 32 位系统 1# ln -s /usr/local/lib/libpcre.so.1 /lib 64 位系统 1# ln -s /usr/local/lib/libpcre.so.1 /lib64 防火墙配置 1# vi /etc/sysconfig/iptables 加入如下一行配置（开放 80 端口） 1-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT 重启防火墙服务 1# service iptables restart 启动 nginx 1# /usr/local/nginx/sbin/nginx 关闭 nginx 1# /usr/local/nginx/sbin/nginx -s stop 或 1# /usr/local/nginx/sbin/nginx -s quit 重新打开日志文件 1# /usr/local/nginx/sbin/nginx -s reopen 重新加载（使配置文件修改后生效） 1# /usr/local/nginx/sbin/nginx -s reload 查看 nginx 进程 1# ps -ef | grep nginx 测试 Nginx 安装是否成功，访问 http://192.168.1.104","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"SolrJ 的运用","date":"2015-11-11T15:17:30.000Z","path":"post/solrj-usage.html","text":"SolrJ 是操作 Solr 的 Java 客户端，它提供了增加、修改、删除、查询 Solr 索引的 Java 接口。SolrJ 针对 Solr 提供了 REST 的 Http 接口进行了封装， SolrJ 底层是通过使用 HttpClient 来完成 Solr 的操作。 pom.xml123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.solr&lt;/groupId&gt; &lt;artifactId&gt;solr-solrj&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; SQL 脚本（MySQL）12345678910CREATE TABLE `product` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;, `name` varchar(200) NOT NULL COMMENT &apos;商品名称&apos;, `sort_name` varchar(128) NOT NULL COMMENT &apos;分类名称&apos;, `sub_sort_name` varchar(128) NOT NULL COMMENT &apos;子分类名称&apos;, `price` decimal(10,0) NOT NULL COMMENT &apos;价格&apos;, `sales` int(11) DEFAULT &apos;0&apos; COMMENT &apos;销量&apos;, `area` varchar(64) NOT NULL COMMENT &apos;地区&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=742 DEFAULT CHARSET=utf8 COMMENT=&apos;商品表&apos;; 点此下载数据库脚本（数据从爱淘宝网站中爬取） 建立数据模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package org.fanlychie.model;import org.apache.solr.client.solrj.beans.Field;public class Product &#123; /** * 主键 */ @Field(&quot;id&quot;) private Integer id; /** * 商品名称 */ @Field(&quot;name&quot;) private String name; /** * 分类名称 */ @Field(&quot;sortName&quot;) private String sortName; /** * 子分类名称 */ @Field(&quot;subSortName&quot;) private String subSortName; /** * 价格 */ @Field(&quot;price&quot;) private Double price; /** * 销量 */ @Field(&quot;sales&quot;) private Integer sales; /** * 地区 */ @Field(&quot;area&quot;) private String area; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSortName() &#123; return sortName; &#125; public void setSortName(String sortName) &#123; this.sortName = sortName; &#125; public String getSubSortName() &#123; return subSortName; &#125; public void setSubSortName(String subSortName) &#123; this.subSortName = subSortName; &#125; public Double getPrice() &#123; return price; &#125; public void setPrice(Double price) &#123; this.price = price; &#125; public Integer getSales() &#123; return sales; &#125; public void setSales(Integer sales) &#123; this.sales = sales; &#125; public String getArea() &#123; return area; &#125; public void setArea(String area) &#123; this.area = area; &#125; @Override public String toString() &#123; return &quot;Product [id=&quot; + id + &quot;, name=&quot; + name + &quot;, sortName=&quot; + sortName + &quot;, subSortName=&quot; + subSortName + &quot;, price=&quot; + price + &quot;, sales=&quot; + sales + &quot;, area=&quot; + area + &quot;]&quot;; &#125;&#125; @Field(&quot;id&quot;) 与 schema.xml 中的 &lt;field name=&quot;id&quot; /&gt; 节点相呼应 建立索引文件时，SolrJ 会将 @Field 注解的属性转换成 Solr 文档对象的字段 在检索的时候，SolrJ 会将 Solr 文档对象的字段转换成 @Field 注解的 Bean 的属性 schema.xml 配置片段123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;schema name=&quot;core1&quot; version=&quot;1.5&quot;&gt; [ . . . . . . ] &lt;field name=&quot;_version_&quot; type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;!-- 商品 ID --&gt; &lt;field name=&quot;id&quot; type=&quot;int&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品名称 --&gt; &lt;field name=&quot;name&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品一级分类 --&gt; &lt;field name=&quot;sortName&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品二级分类 --&gt; &lt;field name=&quot;subSortName&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品价格 --&gt; &lt;field name=&quot;price&quot; type=&quot;double&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品销量 --&gt; &lt;field name=&quot;sales&quot; type=&quot;int&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 发货地 --&gt; &lt;field name=&quot;area&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 检索域 --&gt; &lt;field name=&quot;text&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot; required=&quot;false&quot;/&gt; &lt;!-- 唯一键 --&gt; &lt;uniqueKey&gt;id&lt;/uniqueKey&gt; &lt;!-- 把需要检索的字段, 拷贝到 text 字段中 --&gt; &lt;copyField source=&quot;name&quot; dest=&quot;text&quot;/&gt; &lt;!-- 把需要检索的字段, 拷贝到 text 字段中 --&gt; &lt;copyField source=&quot;sortName&quot; dest=&quot;text&quot;/&gt; &lt;!-- 把需要检索的字段, 拷贝到 text 字段中 --&gt; &lt;copyField source=&quot;subSortName&quot; dest=&quot;text&quot;/&gt; &lt;!-- 采用 IK 中文分词的字段类型 --&gt; &lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot; positionIncrementGap=&quot;100&quot;&gt; &lt;analyzer type=&quot;index&quot;&gt; &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;false&quot; /&gt; &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt; &lt;/analyzer&gt; &lt;analyzer type=&quot;query&quot;&gt; &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;true&quot; /&gt; &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt; &lt;/analyzer&gt; &lt;/fieldType&gt; [ . . . . . . ]&lt;/schema&gt; Solr 服务启动报错： Caused by: org.apache.solr.common.SolrException: Invalid Number: MA147LL/A 解决办法： 将 $SOLR_HOME/core1/conf/elevate.xml（竞价排名）配置文件中的 id 的值改为整型值即可 使用 JDBC 从数据库获取数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package org.fanlychie.dao;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.ArrayList;import java.util.List;import org.fanlychie.model.Product;public class ProductDao &#123; public static List&lt;Product&gt; getAll() &#123; Connection conn = null; try &#123; String username = &quot;root&quot;; String password = &quot;root&quot;; String url = &quot;jdbc:mysql://localhost:3306/product_repo&quot;; conn = DriverManager.getConnection(url, username, password); PreparedStatement pstmt = conn.prepareStatement(&quot;select * from product&quot;); ResultSet rs = pstmt.executeQuery(); List&lt;Product&gt; products = new ArrayList&lt;Product&gt;(); while (rs.next()) &#123; Product product = new Product(); product.setId(rs.getInt(&quot;id&quot;)); product.setSales(rs.getInt(&quot;sales&quot;)); product.setArea(rs.getString(&quot;area&quot;)); product.setName(rs.getString(&quot;name&quot;)); product.setPrice(rs.getDouble(&quot;price&quot;)); product.setSortName(rs.getString(&quot;sort_name&quot;)); product.setSubSortName(rs.getString(&quot;sub_sort_name&quot;)); products.add(product); &#125; return products; &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; finally &#123; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (Exception e) &#123;&#125; &#125; &#125; &#125; static &#123; try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; log4j.xml 配置123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;http://toolkit.alibaba-inc.com/dtd/log4j/log4j.dtd&quot;&gt;&lt;log4j:configuration xmlns:log4j=&apos;http://jakarta.apache.org/log4j/&apos;&gt; &lt;appender name=&quot;console&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%n%p %d&#123;yyyy-MM-dd HH:mm:ss&#125; %c : %L %n%m%n%n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=&quot;org.apache&quot; additivity=&quot;true&quot;&gt; &lt;level value=&quot;WARN&quot; /&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.http.impl.conn.DefaultClientConnection&quot; additivity=&quot;true&quot;&gt; &lt;level value=&quot;DEBUG&quot; /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=&quot;DEBUG&quot; /&gt; &lt;appender-ref ref=&quot;console&quot; /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 建立索引123456789101112131415161718192021222324252627282930313233343536373839private static final int RESPONSE_STATUS_OK = 0; public static void main(String[] args) throws Throwable &#123; // 创建一个 Solr 客户端 SolrClient solrClient = new HttpSolrClient(&quot;http://192.168.1.102:8081/solr/core1&quot;); // 文档对象绑定器 DocumentObjectBinder binder = solrClient.getBinder(); // Solr 输入文档 List&lt;SolrInputDocument&gt; documents = new ArrayList&lt;SolrInputDocument&gt;(); // 从数据库中取得需要建立索引的数据 List&lt;Product&gt; products = ProductDao.getAll(); for (Product product : products) &#123; // 将 Bean 转换成 Solr 文档 documents.add(binder.toSolrInputDocument(product)); &#125; // 添加文档到客户端 solrClient.add(documents); // 提交事务 UpdateResponse response = solrClient.commit(); if (response.getStatus() == RESPONSE_STATUS_OK) &#123; System.out.println(&quot;创建索引成功！&quot;); &#125; else &#123; System.out.println(&quot;创建索引失败！&quot;); &#125; // 关闭 solrClient.close();&#125; 检索文档123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) throws Throwable &#123; // 创建一个 Solr 客户端 SolrClient solrClient = new HttpSolrClient(&quot;http://192.168.1.102:8081/solr/core1&quot;); // 创建一个 Solr 查询 SolrQuery solrQuery = new SolrQuery(); // 设置查询串 solrQuery.setQuery(&quot;打底加绒上衣男&quot;); // 执行查询得到查询响应对象 QueryResponse response = solrClient.query(solrQuery); // 从查询响应对象中获取查询结果 SolrDocumentList documentList = response.getResults(); // 文档对象绑定器 DocumentObjectBinder binder = solrClient.getBinder(); List&lt;Product&gt; products = new ArrayList&lt;Product&gt;(); for (SolrDocument document : documentList) &#123; // 将 Solr 文档对象转换成 Bean 对象 products.add(binder.getBean(Product.class, document)); &#125; // 关闭客户端 solrClient.close(); // 打印消息 System.out.println(products);&#125; 搜索结果 1234567891011121314151617DEBUG 2015-12-02 21:51:06 org.apache.http.impl.conn.DefaultClientConnection : 268 Sending request: GET /solr/core1/select?q=%E6%89%93%E5%BA%95%E5%8A%A0%E7%BB%92%E4%B8%8A%E8%A1%A3%E7%94%B7&amp;wt=javabin&amp;version=2 HTTP/1.1DEBUG 2015-12-02 21:51:06 org.apache.http.impl.conn.DefaultClientConnection : 253 Receiving response: HTTP/1.1 200 OKDEBUG 2015-12-02 21:51:06 org.apache.http.impl.conn.DefaultClientConnection : 176 Connection 0.0.0.0:53836&lt;-&gt;192.168.1.102:8081 closedDEBUG 2015-12-02 21:51:06 org.apache.http.impl.conn.DefaultClientConnection : 176 Connection 0.0.0.0:53836&lt;-&gt;192.168.1.102:8081 closed[ Product [id=371, name=男士长袖t恤男装高领紧身秋衣男青少年加绒加厚打底衫韩版上衣服, sortName=男装, subSortName=T恤, price=30.0, sales=7681, area=浙江 杭州], Product [id=310, name=男装长袖T恤冬季加绒加厚保暖衣青少年V领打底上衣潮男冬装加大码, sortName=男装, subSortName=T恤, price=48.0, sales=631, area=广东 深圳]] POST 请求1QueryResponse response = solrClient.query(solrQuery, SolrRequest.METHOD.POST); 最小匹配1solrQuery.setQuery(&quot;打底加绒上衣男&quot;); 执行查询请求，服务器端记录的日志信息 1[core1] webapp=/solr path=/select params=&#123;q=打底加绒上衣男&amp;wt=javabin&amp;version=2&#125; hits=2 status=0 QTime=1 hits = 2，即该请求匹配到 2 个文档。 123solrQuery.setQuery(&quot;打底加绒上衣男&quot;); solrQuery.setParam(&quot;mm&quot;, &quot;2&quot;); mm（minimal should match）最小应该匹配多少个短语（查询串分词后的短语）。 再次执行查询请求，服务器端记录的日志信息 1[core1] webapp=/solr path=/select params=&#123;mm=2&amp;q=打底加绒上衣男&amp;wt=javabin&amp;version=2&#125; hits=120 status=0 QTime=4 hits = 120，即该请求匹配到 120 个文档。 查询参数1solrQuery.setQuery(&quot;sortName:男装 AND area:广东\\\\ 广州&quot;); 查询分类是男装，发货地是广东广州的商品（广东广州有空格，需要转义） 1[core1] webapp=/solr path=/select params=&#123;q=sortName:男装+AND+area:广东\\+广州&amp;wt=javabin&amp;version=2&#125; hits=19 status=0 QTime=3 结果排序12345solrQuery.setQuery(&quot;羽绒服女&quot;); solrQuery.addSort(&quot;price&quot;, SolrQuery.ORDER.asc); solrQuery.addSort(&quot;sales&quot;, SolrQuery.ORDER.desc); 先按价格升序排序，价格相同按销量降序排序。注意不能用 setSort，如 12345solrQuery.setQuery(&quot;羽绒服女&quot;); solrQuery.setSort(&quot;price&quot;, SolrQuery.ORDER.asc); solrQuery.setSort(&quot;sales&quot;, SolrQuery.ORDER.desc); 该方式只会按销量降序排序，价格的排序被覆盖掉不起作用。 facet 查询Facet 是 solr 的高级搜索功能之一，在检索文档的同时，能够按照 Facet 的域（字段）进行分组统计。Facet 的字段必须被索引，一般来说该字段无需分词，无需存储。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static void main(String[] args) throws Throwable &#123; // 创建一个 Solr 客户端 SolrClient solrClient = new HttpSolrClient(&quot;http://192.168.1.102:8081/solr/core1&quot;); // 创建一个 Solr 查询 SolrQuery solrQuery = new SolrQuery(); solrQuery.setRows(Integer.MAX_VALUE); // 设置查询串 solrQuery.setQuery(&quot;女装&quot;); // facet 查询 solrQuery.setFacet(true); // 每个分组中的数据至少有一个值才返回 solrQuery.setFacetMinCount(1); // 不统计 NULL 的值 solrQuery.setFacetMissing(false); // 排序 solrQuery.setFacetSort(FacetParams.FACET_SORT_COUNT); // facet 结果的返回行数 solrQuery.setFacetLimit(200); // 分组统计的域 solrQuery.addFacetField(&quot;sortName&quot;, &quot;subSortName&quot;); // 执行查询得到查询响应对象 QueryResponse response = solrClient.query(solrQuery, SolrRequest.METHOD.POST); List&lt;FacetField&gt; facetFieldList = response.getFacetFields(); for (FacetField facetField : facetFieldList) &#123; System.out.println(facetField.getName()); System.out.println(&quot;---------------------------------------------------&quot;); List&lt;Count&gt; counts = facetField.getValues(); for (Count count : counts) &#123; System.out.println(count.getName() + &quot; : &quot; + count.getCount()); &#125; System.out.println(); &#125; solrClient.close();&#125; 输出结果 123456789101112sortName---------------------------------------------------女装 : 348男装 : 1subSortName---------------------------------------------------羽绒服 : 76T恤 : 75毛呢外套 : 75连衣裙 : 75鞋子 : 48","tags":[{"name":"Solr","slug":"Solr","permalink":"http://yoursite.com/tags/Solr/"}]},{"title":"Solr solrconfig.xml 配置","date":"2015-11-07T20:02:42.000Z","path":"post/solr-solrconfig-config.html","text":"luceneMatchVersion1&lt;luceneMatchVersion&gt;5.2.0&lt;/luceneMatchVersion&gt; solr 底层使用的 lucene 版本 dataDir1&lt;dataDir&gt;$&#123;solr.data.dir:/opt/apache-tomcat-solr/conf/solr/core1/data&#125;&lt;/dataDir&gt; 配置索引数据文件存放的目录，默认的目录是 $SOLR_HOME/data directoryFactory1&lt;directoryFactory name=&quot;DirectoryFactory&quot; class=&quot;$&#123;solr.directoryFactory:solr.NRTCachingDirectoryFactory&#125;&quot; /&gt; 目录工厂，决定了索引存储的方式。 工厂 描述 StandardDirectoryFactory 基于文件系统，依赖当前操作系统和 java 虚拟机 MMapDirectoryFactory 使用虚拟内存和内核中一个叫 mmap 的特性来访问存在磁盘中的索引文件。它允许 Lucene 直接访问 I/O 缓存，当不需要近实时搜索（Near Real Time Search），这是一个不错的选择 NIOFSDirectoryFactory 适用于多线程环境，在 Windows 平台不能很好的工作 NRTCachingDirectoryFactory&nbsp;&nbsp;&nbsp;&nbsp; 将部分索引存储在内存中，提升近实时搜索（Near Real Time Search）的效率 SimpleFSDirectoryFactory 适用于小型应用程序，不支持大数据和多线程 RAMDirectoryFactory 索引存储在 RAM 内存中，不支持持久化存储。服务重启等会造成索引丢失 updateHandler1234&lt;updateLog&gt; &lt;str name=&quot;dir&quot;&gt;$&#123;solr.ulog.dir:&#125;&lt;/str&gt; &lt;int name=&quot;numVersionBuckets&quot;&gt;$&#123;solr.ulog.numVersionBuckets:65536&#125;&lt;/int&gt;&lt;/updateLog&gt; 设置索引库的更新日志，默认的目录是 $SOLR_HOME/data/tlog 12345&lt;autoCommit&gt; &lt;maxDocs&gt;10000&lt;/maxDocs&gt; &lt;maxTime&gt;$&#123;solr.autoCommit.maxTime:30000&#125;&lt;/maxTime&gt; &lt;openSearcher&gt;true&lt;/openSearcher&gt; &lt;/autoCommit&gt; 设置自动硬提交的方式。自动硬提交对性能有一定的影响，它确保索引数据同步到磁盘，因此不会因为宕机等异常状况而造成大量数据丢失。硬提交后的文档是不可见的，需要重新打开一个新的 Searcher，才能看得见变化 参数 描述 maxDocs 设置达到多少个文档时提交一次 maxTime 设置达到多长时间时提交一次 openSearcher&nbsp;&nbsp;&nbsp;&nbsp; 文档提交后是否开启新的 Searcherfalse：文档只是提交到索引库，搜索结果中搜不到此次提交的文档true&nbsp;：文档提交到索引库，搜索结果中也能搜到此次提交的文档 1234&lt;autoSoftCommit&gt; &lt;maxDocs&gt;1000&lt;/maxDocs&gt; &lt;maxTime&gt;2000&lt;/maxTime&gt;&lt;/autoSoftCommit&gt; 自动软提交，只确保变化是看得见的，但不保证数据同步到磁盘。软提交后的文档立即可用 query1&lt;maxBooleanClauses&gt;1024&lt;/maxBooleanClauses&gt; 条件搜索时，会产生大量的 boolean 条件，如果条件数达到设定的这个阀值时，将抛出异常，限制这个条件数，可以防止条件过多查询等待时间过长 1234&lt;filterCache class=&quot;solr.FastLRUCache&quot; size=&quot;2048&quot; initialSize=&quot;2048&quot; autowarmCount=&quot;512&quot;/&gt; 配置过滤器缓存。filterCache 存储了无序的文档的 ID 集合。如 filter queries（&quot;fq&quot; 参数）得到的文档的 ID 集合结果等 LRUCache 是基于 LinkedHashMap，读写操作都是对 map 的全局锁，并发性方面稍差 FastLRUCache 是基于 ConcurrentHashMap ，具有更快的读取能力和较好的并发性能 参数 描述 size 缓存中的最大数目 initialSize 初始容量 autowarmCount&nbsp;&nbsp;&nbsp;&nbsp; 当打开一个新的 Searcher 时，可以对新的 Searcher 做预热处理。即从老的 Searcher 中取该值指定的缓存条目数目填充到新的 Searcher 中。如果使用的是 LRUCache，则取最近访问的条目填充到新的 Searcher 中 1234&lt;queryResultCache class=&quot;solr.LRUCache&quot; size=&quot;4096&quot; initialSize=&quot;4096&quot; autowarmCount=&quot;512&quot;/&gt; 配置查询结果缓存。查询结果缓存的是查询条件的结果的有序文档的 ID 集合。同 filterCache 参数 1234&lt;documentCache class=&quot;solr.LRUCache&quot; size=&quot;5120&quot; initialSize=&quot;5120&quot; autowarmCount=&quot;0&quot;/&gt; 配置文档缓存。文档缓存的是 &lt; 文档 ID, 文档对象 &gt; 键值对。参数与 filterCache 同 1234&lt;fieldValueCache class=&quot;solr.FastLRUCache&quot; size=&quot;512&quot; autowarmCount=&quot;128&quot; showItems=&quot;32&quot; /&gt; 配置字段值缓存。字段缓存使用文档 ID 进行快速访问。默认情况下创建 fieldValueCache，即使这里没有配置 1&lt;enableLazyFieldLoading&gt;true&lt;/enableLazyFieldLoading&gt; 是否允许字段延迟加载。若为 true，非必须字段（required = &quot;false&quot;）将被延迟加载，特别是一些大的压缩文本字段，延迟加载可以提升性能 1&lt;queryResultWindowSize&gt;50&lt;/queryResultWindowSize&gt; 优化 queryResultCache（查询结果缓存）。如从查询结果每次取匹配的 10 个文档，如 10 到 19，那么文档 0 到 49 将被用来收集和缓存条目用。下次请求 20 到 39 的数据时，直接命中缓存，很快就能拿到结果。该值越大，查询结果缓存的文档的 ID 集合就越大，命中缓存的概率也就越大，但是这样也会很浪费内存 1&lt;queryResultMaxDocsCached&gt;800&lt;/queryResultMaxDocsCached&gt; 查询结果最大缓存的文档的数目。 1&lt;useColdSearcher&gt;true&lt;/useColdSearcher&gt; 是否使用冷搜索。当一个搜索请求到来时，如果当前没有注册的搜索可用，那么将立即注册一个，并且需等到自热后才能使用它。若该值为 false，那么，所有的搜索请求将阻塞在第一个搜索，直到第一个搜索注册并自热完成 1&lt;maxWarmingSearchers&gt;2&lt;/maxWarmingSearchers&gt; 设置最大的 Searcher 数量，这些 Searcher 都是事先预热好的，随时可以使用。如果超过这个数量，将会报错。 在一个只读的索引库中，2 个预热的 Searcher 是相对合理的；如果是读写的索引库中，可以给一个相对大一点的值 1&lt;requestDispatcher handleSelect=&quot;false&quot;&gt; 配置请求分发器。当访问的 URL 为 /select，如 /select?qt=xxx 若 handleSelect=&quot;true&quot;，SolrDispatchFilter 将请求转发给 qt 指定的处理器（前提是 /select 已经注册） 当 handleSelect=&quot;false&quot; 时会直接访问 /select，若 /select 未注册则报 404 123456789101112&lt;requestHandler name=&quot;/select&quot; class=&quot;solr.SearchHandler&quot; default=&quot;true&quot;&gt; &lt;lst name=&quot;defaults&quot;&gt; &lt;str name=&quot;echoParams&quot;&gt;explicit&lt;/str&gt; &lt;int name=&quot;rows&quot;&gt;10&lt;/int&gt; &lt;str name=&quot;q.op&quot;&gt;AND&lt;/str&gt; &lt;str name=&quot;q.alt&quot;&gt;*:*&lt;/str&gt; &lt;str name=&quot;fl&quot;&gt;*,score&lt;/str&gt; &lt;!-- &lt;str name=&quot;df&quot;&gt;text&lt;/str&gt; --&gt; &lt;str name=&quot;defType&quot;&gt;edismax&lt;/str&gt; &lt;str name=&quot;qf&quot;&gt;name^5 sortName^2 subSortName^3&lt;/str&gt; &lt;/lst&gt;&lt;/requestHandler&gt; 配置请求处理器。更多参数见如下表格 查询参数 描述 q 查询字符串 start 用于分页查询的结果。指定第一条记录在查询结果中的偏移量。默认值为 0 rows 指定从搜索结果中取多少条数据。与 start 配合使用 sort 搜索结果排序。默认为 score desc（按文档的得分降序排序） fl 用来指定文档结果中应返回的字段列表。多个字段之间用逗号分隔，默认为 &quot;*&quot; 指返回所有的字段。score 返回文档的得分，如： *,score q.alt 当查询串 q 为空时，使用该值，通常设置 q.alt 为 *:* wt 指定查询结果输出的格式，如 json，xml 等，默认为 xml 格式 fq 过滤查询。在 q 查询的结果中，再用 fq 条件过滤一次结果 q.op 搜索串中有空格时，使用 OR 逻辑 还是 AND 逻辑 df 指定默认的查询字段 qt 当访问的 url 为 /select，如 /select?qt=xxx，solr 将使用 qt 参数的值来确定使用哪个 requestHandler 来处理查询请求 indent 返回的结果是否缩进，默认关闭，一般调试输出才有必要用这个参数 echoParams&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 是否显示查询参数。none：不显示；explicit：只显示查询参数；all：显示所有的参数 qf 指定从哪些字段中查询，如果没有配置，则使用 df 的值 defType 指定处理查询的 Query Parser。如 defType=lucene&nbsp;&nbsp;&nbsp;（Standard Query Parser）defType=dismax&nbsp;&nbsp;（DisMax Query Parser）defType=edismax（Extended DisMax Query Parser）","tags":[{"name":"Solr","slug":"Solr","permalink":"http://yoursite.com/tags/Solr/"}]},{"title":"Solr IKAnalyzer 中文分词配置","date":"2015-11-07T18:33:50.000Z","path":"post/solr-ikanalyzer.html","text":"下载 IKAnalyzer-2012FF_hf1_support_solr5.jar，并将它放到 solr 应用的 WEB-INF / lib 目录下 打开并编辑 $SOLR_HOME 下的 schema.xml 配置文件，加入如下配置 12345678&lt;fieldType name=\"text_ik\" class=\"solr.TextField\" positionIncrementGap=\"100\"&gt; &lt;analyzer type=\"index\"&gt; &lt;tokenizer class=\"org.wltea.analyzer.lucene.IKTokenizerFactory\" useSmart=\"false\" /&gt; &lt;/analyzer&gt; &lt;analyzer type=\"query\"&gt; &lt;tokenizer class=\"org.wltea.analyzer.lucene.IKTokenizerFactory\" useSmart=\"true\" /&gt; &lt;/analyzer&gt;&lt;/fieldType&gt; &lt;analyzer type=&quot;index&quot;&gt; 配置索引分词 &lt;analyzer type=&quot;query&quot;&gt; 配置搜索分词 useSmart=&quot;false&quot; 使用细粒度分词，useSmart=&quot;true&quot; 使用智能分词。 男士运动鞋中文分词结果 类别 分词 索引（细粒度分词） 男士，运动鞋，运动，鞋 搜索（智能分词） 男士，运动鞋","tags":[{"name":"Solr","slug":"Solr","permalink":"http://yoursite.com/tags/Solr/"}]},{"title":"Solr schema.xml 配置","date":"2015-11-07T08:01:36.000Z","path":"post/solr-schema-config.html","text":"schema1&lt;schema name=&quot;core1&quot; version=&quot;1.5&quot;&gt; 参数 描述 name schema 的名称，仅用于展示 version solr 的 schema 语法的版本号 fieldType1&lt;fieldType name=&quot;string&quot; class=&quot;solr.StrField&quot; sortMissingLast=&quot;true&quot; /&gt; 参数 描述 name 字段类型的名称 class 以“solr.”开始，后面为对应的 java 类的短类名构成其中，solr.TextField 类型的 fieldType 还有 analyzer 属性具体可参见 solr-core-5.jar / org.apache.solr.schema 包 sortMissingLast 若为 true，检索结果中，没有该字段类型的数据排在有该字段类型的数据之后，而不管排序请求时设定的排序规则 sortMissingFirst 若为 true，检索结果中，没有该字段类型的数据排在有该字段类型的数据之前，而不管排序请求时设定的排序规则 positionIncrementGap&nbsp;&nbsp;&nbsp;&nbsp; 用于多值字段（multiValued = true）的短语查询如一个文档有两个 tag（标签）：tag1&nbsp; :&nbsp;&nbsp; AB &nbsp; CDtag2&nbsp; :&nbsp;&nbsp; XY &nbsp; ZW若 positionIncrementGap = 0，那么这 4 个词的位置分别为 0, 1, 2, 3如果搜索 CD &nbsp; XY，那么这个文档将会被匹配如果认为该文档不应该被匹配，可将 positionIncrementGap 调大一些，如 positionIncrementGap = 100，那么现在这 4 个词的位置分别为 0, 1 , 100, 101。这样短语查询就不会匹配到该文档 field1&lt;field name=&quot;id&quot; type=&quot;int&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot; /&gt; 参数 描述 name 具体字段的名称 type 字段类型的名称，参考 &lt;fieldType&gt; 节点 indexed 是否被索引，不需要被检索的字段应该设为 false，以提升性能 stored 是否被存储，需要返回内容值的字段应该设为 true，否则在检索结果中取不到值 docValues 是否有文档值，仅支持 StrField，UUIDField，Trie*Field multiValued&nbsp;&nbsp;&nbsp;&nbsp; 是否有多个值，默认 false omitNorms 是否省略规范，规范是用来提升字段长度标准化和索引时间。只有全文本和需要提升索引时间的字段需要规范。若为 true，solr 不会存储规范，因此索引大小会变小，节省内存，默认为 true required 字段是否是必须的。若为 true，建立索引的时候该字段必须有值，否则抛出异常 default 字段没有值时，默认使用的值 dynamicField动态字段 name = “*_i” 将匹配所有以 “_i” 结束的字段名，如 id_i，age_i 参数属性参考 &lt;field&gt; 1&lt;dynamicField name=&quot;*_i&quot; type=&quot;int&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; uniqueKey设置文档的唯一键，不同的键值表示不同的文档对象 1&lt;uniqueKey&gt;id&lt;/uniqueKey&gt; copyField将 source 指定的字段名称拷贝到 dest 指定的字段名中，以便进行统一的检索 12345&lt;copyField source=&quot;name&quot; dest=&quot;text&quot;/&gt;&lt;copyField source=&quot;sortName&quot; dest=&quot;text&quot;/&gt;&lt;copyField source=&quot;subSortName&quot; dest=&quot;text&quot;/&gt; 附完整配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;schema name=&quot;core1&quot; version=&quot;1.5&quot;&gt; &lt;field name=&quot;_version_&quot; type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;!-- 商品 ID --&gt; &lt;field name=&quot;id&quot; type=&quot;int&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品名称 --&gt; &lt;field name=&quot;name&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品一级分类 --&gt; &lt;field name=&quot;sortName&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品二级分类 --&gt; &lt;field name=&quot;subSortName&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品价格 --&gt; &lt;field name=&quot;price&quot; type=&quot;double&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 商品销量 --&gt; &lt;field name=&quot;sales&quot; type=&quot;int&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 发货地 --&gt; &lt;field name=&quot;area&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot;/&gt; &lt;!-- 检索域 --&gt; &lt;field name=&quot;text&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot; required=&quot;false&quot;/&gt; &lt;dynamicField name=&quot;*_i&quot; type=&quot;int&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_is&quot; type=&quot;int&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_s&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt; &lt;dynamicField name=&quot;*_ss&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_l&quot; type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_ls&quot; type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_t&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_txt&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_b&quot; type=&quot;boolean&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_bs&quot; type=&quot;boolean&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_f&quot; type=&quot;float&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_fs&quot; type=&quot;float&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_d&quot; type=&quot;double&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_ds&quot; type=&quot;double&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_dt&quot; type=&quot;date&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_dts&quot; type=&quot;date&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_ti&quot; type=&quot;tint&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_tl&quot; type=&quot;tlong&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_tf&quot; type=&quot;tfloat&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_td&quot; type=&quot;tdouble&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_tdt&quot; type=&quot;tdate&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;*_c&quot; type=&quot;currency&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;ignored_*&quot; type=&quot;ignored&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;attr_*&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot;/&gt; &lt;dynamicField name=&quot;random_*&quot; type=&quot;random&quot; /&gt; &lt;uniqueKey&gt;id&lt;/uniqueKey&gt; &lt;copyField source=&quot;name&quot; dest=&quot;text&quot;/&gt; &lt;copyField source=&quot;sortName&quot; dest=&quot;text&quot;/&gt; &lt;copyField source=&quot;subSortName&quot; dest=&quot;text&quot;/&gt; &lt;fieldType name=&quot;string&quot; class=&quot;solr.StrField&quot; sortMissingLast=&quot;true&quot; /&gt; &lt;fieldType name=&quot;boolean&quot; class=&quot;solr.BoolField&quot; sortMissingLast=&quot;true&quot;/&gt; &lt;fieldType name=&quot;int&quot; class=&quot;solr.TrieIntField&quot; precisionStep=&quot;0&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;float&quot; class=&quot;solr.TrieFloatField&quot; precisionStep=&quot;0&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;long&quot; class=&quot;solr.TrieLongField&quot; precisionStep=&quot;0&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;double&quot; class=&quot;solr.TrieDoubleField&quot; precisionStep=&quot;0&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;tint&quot; class=&quot;solr.TrieIntField&quot; precisionStep=&quot;8&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;tfloat&quot; class=&quot;solr.TrieFloatField&quot; precisionStep=&quot;8&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;tlong&quot; class=&quot;solr.TrieLongField&quot; precisionStep=&quot;8&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;tdouble&quot; class=&quot;solr.TrieDoubleField&quot; precisionStep=&quot;8&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;date&quot; class=&quot;solr.TrieDateField&quot; precisionStep=&quot;0&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;tdate&quot; class=&quot;solr.TrieDateField&quot; precisionStep=&quot;6&quot; positionIncrementGap=&quot;0&quot;/&gt; &lt;fieldType name=&quot;binary&quot; class=&quot;solr.BinaryField&quot;/&gt; &lt;fieldType name=&quot;random&quot; class=&quot;solr.RandomSortField&quot; indexed=&quot;true&quot; /&gt; &lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot; positionIncrementGap=&quot;100&quot;&gt; &lt;analyzer type=&quot;index&quot;&gt; &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;false&quot; /&gt; &lt;filter class=&quot;solr.StopFilterFactory&quot; ignoreCase=&quot;true&quot; words=&quot;stopwords.txt&quot; /&gt; &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt; &lt;/analyzer&gt; &lt;analyzer type=&quot;query&quot;&gt; &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;true&quot; /&gt; &lt;filter class=&quot;solr.StopFilterFactory&quot; ignoreCase=&quot;true&quot; words=&quot;stopwords.txt&quot; /&gt; &lt;filter class=&quot;solr.SynonymFilterFactory&quot; synonyms=&quot;synonyms.txt&quot; ignoreCase=&quot;true&quot; expand=&quot;true&quot;/&gt; &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt; &lt;/analyzer&gt; &lt;/fieldType&gt; &lt;fieldType name=&quot;text_ws&quot; class=&quot;solr.TextField&quot; positionIncrementGap=&quot;100&quot;&gt; &lt;analyzer&gt; &lt;tokenizer class=&quot;solr.WhitespaceTokenizerFactory&quot;/&gt; &lt;/analyzer&gt; &lt;/fieldType&gt; &lt;fieldType name=&quot;ignored&quot; stored=&quot;false&quot; indexed=&quot;false&quot; multiValued=&quot;true&quot; class=&quot;solr.StrField&quot; /&gt; &lt;fieldType name=&quot;currency&quot; class=&quot;solr.CurrencyField&quot; precisionStep=&quot;8&quot; defaultCurrency=&quot;USD&quot; currencyConfig=&quot;currency.xml&quot; /&gt;&lt;/schema&gt;","tags":[{"name":"Solr","slug":"Solr","permalink":"http://yoursite.com/tags/Solr/"}]},{"title":"Solr 环境搭建","date":"2015-11-07T03:30:33.000Z","path":"post/solr-setup.html","text":"Solr 是一个独立的企业级搜索应用服务器，基于 Lucene 的全文搜索服务器。同时对其进行了扩展，提供了比 Lucene 更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。 安装环境 CentOS 6.5 Solr 5.2.0 JDK 1.7 Tomcat 7 安装 到 Solr 官网下载所需版本文件，本文使用 Solr 5.2.0，安装文件 solr-5.2.0.tgz 在服务器端创建 $CATALINA_HOME/webapps/solr 目录 其中，$CATALINA_HOME 表示 Tomcat 安装的根目录，以下同 本地解压缩 solr-5.2.0.tgz，得到 solr-5.2.0 目录 并将 solr-5.2.0/server/webapps/solr.war 上传到服务器 $CATALINA_HOME/webapps/solr 解压缩 $CATALINA_HOME/webapps/solr/solr.war 包，并备份 solr.war 包 123# cd $CATALINA_HOME/webapps/solr# jar xvf solr.war# mv solr.war solr.war_5.2.0_backup 以 JNDI 的方式设置 SOLR_HOME 变量，SOLR_HOME 是 Tomcat 安装 Solr 实例必不可少的配置 在 $CATALINA_HOME/conf/Catalina/localhost 目录下新建一个 solr.xml 配置文件，内容如下 123&lt;Context docBase=\"/opt/apache-tomcat-solr/webapps/solr\" debug=\"0\" crossContext=\"true\" &gt; &lt;Environment name=\"solr/home\" type=\"java.lang.String\" value=\"/opt/apache-tomcat-solr/conf/solr\" override=\"true\" /&gt;&lt;/Context&gt; docBase 指定到 solr 应用的目录，solr/home 的值指定到 SOLR_HOME 的根目录 将 solr-5.2.0/server/solr 整个文件夹上传到 $CATALINA_HOME/conf/ 下 形成的 $CATALINA_HOME/conf/solr 即是 SOLR_HOME 的目录（以下用 $SOLR_HOME 表示） 删掉 $SOLR_HOME/configsets 目录 12# cd $SOLR_HOME# rm -rf configsets 新建 $SOLR_HOME/core1 目录 1# mkdir core1 新建 $SOLR_HOME/core1/conf 目录 1# mkdir core1/conf 新建 $SOLR_HOME/core1/data 目录 1# mkdir core1/data 将 solr-5.2.0/server/solr/configsets/sample_techproducts_configs 下面的文件 全部上传到 $SOLR_HOME/core1/conf 目录下 将 solr-5.2.0/server/lib/ext 下的 jar 包 全部上传到 $CATALINA_HOME/webapps/solr/WEB-INF/lib 目录下 在 $CATALINA_HOME/webapps/solr/WEB-INF 下创建文件夹 classes 将 solr-5.2.0/server/resources/log4j.properties 上传到 $CATALINA_HOME/webapps/solr/WEB-INF/classes 目录下 添加 core 配置 启动 tomcat，访问 http://192.168.1.102:8081/solr 在 Core Admin 菜单栏，填写如上图表单，点击 Add Core，添加一个 Core 前提：$SOLR_HOME 目录下必须已存在与上图 instanceDir 名称相同的目录， 且该目录存在 data/，conf/schema.xml，conf/solrconfig.xml 目录文件。 否则添加会发生异常导致失败。若添加成功，图示 在左侧菜单栏 Core Selector 下拉框中选择刚添加的 core1，图示 至此，Solr 5.2.0 在 linux 环境下搭建完成。","tags":[{"name":"Solr","slug":"Solr","permalink":"http://yoursite.com/tags/Solr/"}]},{"title":"ActiveMQ 收发消息","date":"2015-11-04T15:20:50.000Z","path":"post/activemq-usage.html","text":"pom.xml 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-core&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.4&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; log4j.xml 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM \"http://toolkit.alibaba-inc.com/dtd/log4j/log4j.dtd\"&gt;&lt;log4j:configuration xmlns:log4j='http://jakarta.apache.org/log4j/'&gt; &lt;appender name=\"console\" class=\"org.apache.log4j.ConsoleAppender\"&gt; &lt;layout class=\"org.apache.log4j.PatternLayout\"&gt; &lt;param name=\"ConversionPattern\" value=\"%n%p %d&#123;yyyy-MM-dd HH:mm:ss&#125; %c : %L %n%m%n%n\" /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=\"org.apache.activemq\" additivity=\"true\"&gt; &lt;level value=\"WARN\" /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=\"DEBUG\" /&gt; &lt;appender-ref ref=\"console\" /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 生产者示例清单 12345678910111213141516171819202122232425262728293031323334353637383940import javax.jms.Session;import javax.jms.Connection;import javax.jms.Destination;import javax.jms.TextMessage;import javax.jms.DeliveryMode;import javax.jms.MessageProducer;import javax.jms.ConnectionFactory;import org.apache.activemq.ActiveMQConnectionFactory;public class TextMessageProducer &#123; public static void main(String[] args) throws Throwable &#123; // 连接工厂 ConnectionFactory factory = new ActiveMQConnectionFactory(\"tcp://192.168.1.102:61616\"); // 创建一条连接 Connection conn = factory.createConnection(); // 启动连接 conn.start(); // 创建会话 Session session = conn.createSession(true, Session.AUTO_ACKNOWLEDGE); // 发送目的地 Destination destination = session.createQueue(\"TEST.QUEUE\"); // 消息生产者 MessageProducer producer = session.createProducer(destination); // 非持久化, MQ 重启后消息会丢失, 视场景而定 producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT); // 发送 20 条消息 for (int i = 0; i &lt; 20; i++) &#123; // 文本内容消息 TextMessage message = session.createTextMessage(String.format(\"第 %d 条消息\", i + 1)); // 发送到目的地 producer.send(message); &#125; // 提交事务 session.commit(); // 关闭连接 conn.close(); &#125; &#125; 消费者示例清单 1234567891011121314151617181920212223242526272829303132333435import javax.jms.Session;import javax.jms.Connection;import javax.jms.Destination;import javax.jms.TextMessage;import javax.jms.MessageConsumer;import javax.jms.ConnectionFactory;import java.util.concurrent.TimeUnit;import org.apache.activemq.ActiveMQConnectionFactory;public class TextMessageConsumer &#123; public static void main(String[] args) throws Throwable &#123; // 连接工厂 ConnectionFactory factory = new ActiveMQConnectionFactory(\"tcp://192.168.1.102:61616\"); // 创建一条连接 Connection conn = factory.createConnection(); // 启动连接 conn.start(); // 创建会话 Session session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE); // 发送目的地 Destination destination = session.createQueue(\"TEST.QUEUE\"); // 消息消费者 MessageConsumer consumer = session.createConsumer(destination); while (true) &#123; // 接收消息 TextMessage message = (TextMessage) consumer.receive(); // 模拟业务处理 TimeUnit.SECONDS.sleep(3); // 打印接收到的消息 System.out.println(String.format(\"「接收」%s\", message.getText())); &#125; &#125;&#125; ActiveMQ 控制台 运行示例清单中的消息生产者，以产生 MQ 消息。访问 http://192.168.1.102:8161 参数 描述 Name 队列的名称 Number Of Pending Messages 积压（未消费）的消息数量 Number Of Consumers 消费者实例的数量 Messages Enqueued 入队的消息数量（该数量只会增加，不会减少） Messages Dequeued 出队的消息数量（已消费的消息数量） 当 Number Of Pending Messages = 0 且 Messages Enqueued = Messages Dequeued 时，表明队列中的消息已全部被消费完成。 发送文本消息 12Message message = session.createTextMessage(\"Hello World\");producer.send(message); 接收文本消息 12TextMessage message = (TextMessage) consumer.receive();String text = message.getText(); 发送对象消息 12Message message = session.createObjectMessage(new Date());producer.send(message); 接收对象消息 12ObjectMessage message = (ObjectMessage) consumer.receive();Date date = (Date) message.getObject(); 发送 Map 消息 123MapMessage message = session.createMapMessage();message.setString(\"key\", \"Hello World\");producer.send(message); 接收 Map 消息 12MapMessage message = (MapMessage) consumer.receive();String value = message.getString(\"key\"); 发送字节消息 123BytesMessage message = session.createBytesMessage();message.writeBytes(\"Hello World\".getBytes());producer.send(message); 接收字节消息 1234567BytesMessage message = (BytesMessage) consumer.receive();StringBuilder builder = new StringBuilder();byte[] bytes = new byte[1024 / 2];int read;while ((read = message.readBytes(bytes)) != -1) &#123; builder.append(new String(bytes, 0, read));&#125;","tags":[{"name":"MQ","slug":"MQ","permalink":"http://yoursite.com/tags/MQ/"},{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"http://yoursite.com/tags/ActiveMQ/"}]},{"title":"ActiveMQ 安装","date":"2015-11-03T15:02:42.000Z","path":"post/activemq-setup.html","text":"安装环境 CentOS 6.5 apache-activemq-5.11.2-bin.tar.gz 安装 ActiveMQ 到 ActiveMQ 官网下载所需版本的安装文件，上传到服务器（如：/usr/local） 123tar xvfz apache-activemq-5.11.2-bin.tar.gzrm -f apache-activemq-5.11.2-bin.tar.gz 开启防火墙端口 1vi /etc/sysconfig/iptables 加入如下两行配置 123-A INPUT -m state --state NEW -m tcp -p tcp --dport 8161 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 61616 -j ACCEPT 端口 描述 8161 ActiveMQ 默认的控制台管理服务端口 61616 ActiveMQ 默认的 JMS 服务端口 重启防火墙服务 1# service iptables restart 启动 ActiveMQ 1# /usr/local/apache-activemq-5.11.2/bin/activemq start 访问控制台服务：http://192.168.1.102:8161，默认的账户密码：admin / admin 查看 ActiveMQ 进程 1# ps -ef | grep activemq 重启 ActiveMQ 1# /usr/local/apache-activemq-5.11.2/bin/activemq restart 关闭 ActiveMQ 1# /usr/local/apache-activemq-5.11.2/bin/activemq stop","tags":[{"name":"MQ","slug":"MQ","permalink":"http://yoursite.com/tags/MQ/"},{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"http://yoursite.com/tags/ActiveMQ/"}]},{"title":"定时任务","date":"2015-10-31T09:42:10.000Z","path":"post/java-scheduled-task.html","text":"实现方式一：Timerschedule 示例清单1234567891011121314151617181920import java.util.Timer;import java.util.TimerTask;public class TimerDemo &#123; public static void main(String[] args) &#123; // 从现在开始, 此后每隔 3 秒执行一次任务 new Timer().schedule(new TimerTask() &#123; @Override public void run() &#123; System.out.println(&quot;execute task&quot;); &#125; &#125;, 0, 3 * 1000); &#125; &#125; 特性：任务由同一个线程调度，串行执行。下一个任务按照前一个任务的实际执行完成的时间起算向后推一个时间间隔的时长，若前一个任务发生延迟，下一个任务也会被延后执行。不存在线程安全问题。 scheduleAtFixedRate 示例清单1234567891011121314151617181920import java.util.Timer;import java.util.TimerTask;public class TimerDemo &#123; public static void main(String[] args) &#123; // 从现在开始, 此后每隔 3 秒执行一次任务 new Timer().scheduleAtFixedRate(new TimerTask() &#123; @Override public void run() &#123; System.out.println(&quot;execute task&quot;); &#125; &#125;, 0, 3 * 1000); &#125; &#125; 特性：下一个任务按照前一个任务开始执行的时间开始计算，若前一个任务发生延迟，下一个任务不会被延后，存在并发性的可能性，需要考虑线程安全问题。 实现方式二：ScheduledExecutorServicescheduleWithFixedDelay 示例清单1234567891011121314151617181920212223import java.util.concurrent.TimeUnit;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;public class ScheduledExecutorServiceDemo &#123; public static void main(String[] args) &#123; ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor(); // 从现在开始, 此后每隔 3 秒执行一次任务 service.scheduleWithFixedDelay(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;execute task&quot;); &#125; &#125;, 0, 3, TimeUnit.SECONDS); &#125; &#125; newSingleThreadScheduledExecutor() 等效于 Executors.newScheduledThreadPool(1)。 特性：下一个任务按照前一个任务的实际执行完成的时间起算向后推一个时间间隔的时长，若前一个任务发生延迟，下一个任务也会被延后执行。是基于不固定时间间隔进行的任务调度。 scheduleAtFixedRate 示例清单1234567891011121314151617181920212223import java.util.concurrent.TimeUnit;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;public class ScheduledExecutorServiceDemo &#123; public static void main(String[] args) &#123; ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor(); // 从现在开始, 此后每隔 3 秒执行一次任务 service.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;execute task&quot;); &#125; &#125;, 0, 3, TimeUnit.SECONDS); &#125; &#125; newSingleThreadScheduledExecutor() 等效于 Executors.newScheduledThreadPool(1)。 特性：下一个任务按照前一个任务开始执行的时间开始计算，若前一个任务发生延迟，下一个任务不会被延后，是基于固定时间间隔进行的任务调度。 借助 Calendar 实现复杂的任务调度123456789101112131415161718192021222324252627282930313233import java.util.Calendar;import java.util.concurrent.TimeUnit;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;public class ScheduledExecutorServiceDemo &#123; public static void main(String[] args) &#123; ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor(); Calendar calendar = Calendar.getInstance(); calendar.set(Calendar.HOUR_OF_DAY, 4); calendar.set(Calendar.MINUTE, 0); calendar.set(Calendar.SECOND, 0); calendar.set(Calendar.MILLISECOND, 0); // 距凌晨 04 点的时间戳 long delay = calendar.getTime().getTime() - System.currentTimeMillis(); // 每天凌晨 04 点执行任务 service.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;execute task&quot;); &#125; &#125;, delay, 24 * 60 * 60 * 1000, TimeUnit.MILLISECONDS); &#125; &#125; 实现方式三：QuartzCron 触发器表达式格式：秒 分 时 日 月 周 年 [ 可选 ] 字段名 值范围 特殊字符 秒 0 - 59 ,&nbsp;&nbsp;-&nbsp;&nbsp;*&nbsp;&nbsp;/ 分 0 - 59 ,&nbsp;&nbsp;-&nbsp;&nbsp;*&nbsp;&nbsp;/ 时 0 - 23 ,&nbsp;&nbsp;-&nbsp;&nbsp;*&nbsp;&nbsp;/ 日 0 - 31 ,&nbsp;&nbsp;-&nbsp;&nbsp;*&nbsp;&nbsp;/&nbsp;&nbsp;L&nbsp;&nbsp;W&nbsp;&nbsp;C&nbsp;&nbsp;? 月 1 - 12 [ JAN - DEC ] ,&nbsp;&nbsp;-&nbsp;&nbsp;*&nbsp;&nbsp;/ 周 1 - 7 &nbsp;&nbsp;[ SUN - SAT ] ,&nbsp;&nbsp;-&nbsp;&nbsp;*&nbsp;&nbsp;/&nbsp;&nbsp;L&nbsp;&nbsp;C&nbsp;&nbsp;#&nbsp;&nbsp;? 年 1970 - 2099 ,&nbsp;&nbsp;-&nbsp;&nbsp;*&nbsp;&nbsp;/ &nbsp; 特殊字符&nbsp;&nbsp;&nbsp;&nbsp; 含义描述 , 用于指定多个值。如在周字段中，MON, WED, FRI 表示一三五 - 用于指定一个范围的值。如在时字段中，03-04 表示凌晨 3 至 4 点 * 表示任意值 / 表示增量值。如在分字段中，5/30 表示从第 5 分钟起，每 30 分钟一次 # 只用于周字段，表示月的第几周，如 MON#2 表示该月的第二个星期一 ? 表示不确定值，是什么值不重要。 C Calendar 的缩写，表示基于日历计算出来的值。 L Last 的缩写，在日字段中单独出现，表示该月最后一天；在周字段中单独出现表示 7 或 SAT，组合出现，如 7L，表示该月最后一个周六 W 表示工作日（周一 至 周五） &nbsp; 示例&nbsp;&nbsp;&nbsp;&nbsp; 描述 0 0 3 * * * 每天凌晨 3 点触发 0 0 3 * * ? 每天凌晨 3 点触发 0 0 3 * * ? * 每天凌晨 3 点触发 0 * 3 * * ? 每天凌晨 3 点 至 3 点 59 分，每分钟触发一次 0 */5 * * * ? 每隔 5 分钟触发一次 0 */5 3 * * ? 每天凌晨 3 点 至 3 点 59 分，每 5 分钟触发一次 0 0 3-4 * * ? 每天凌晨 3 至 4 点，每小时触发一次 0 0 3 * * MON,WED,FRI 每个周一、周三、周五的凌晨 3 点触发一次 0 0 3 L * ? 每个月的最后一天凌晨 3 点触发 0 0 3 * * 2L 每个月的最后一个周一的凌晨 3 点触发 0 0 3 * * MON#2 每个月的第二个周一的凌晨 3 点触发 &nbsp; 示例清单 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class CronDemo &#123; public static void main(String[] args) throws Throwable &#123; // 从工厂中获取一个实例 Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); // 作业实例, 名称 &quot;MY-JOB&quot; JobDetail job = JobBuilder.newJob(MyJob.class).withIdentity(&quot;MY-JOB&quot;).build(); JobDataMap jobDataMap = job.getJobDataMap(); // 键值对信息 jobDataMap.put(&quot;msg&quot;, &quot;Hello World！&quot;); // Cron 触发器, 每 5 秒触发一次 CronTrigger trigger = TriggerBuilder.newTrigger() .withSchedule(CronScheduleBuilder.cronSchedule(&quot;0/5 * * * * ?&quot;)).build(); scheduler.scheduleJob(job, trigger); scheduler.start(); &#125; public static class MyJob implements Job &#123; @Override public void execute(JobExecutionContext context) throws JobExecutionException &#123; JobDetail jobDetail = context.getJobDetail(); JobKey jobKey = jobDetail.getKey(); JobDataMap jobDataMap = jobDetail.getJobDataMap(); // 任务执行时, 打印一条消息 System.out.println(&quot;Executing &quot; + jobKey + &quot; : &quot; + jobDataMap.getString(&quot;msg&quot;)); &#125; &#125;&#125; pom.xml 123456789101112131415&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; log4j.xml 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;http://toolkit.alibaba-inc.com/dtd/log4j/log4j.dtd&quot;&gt;&lt;log4j:configuration xmlns:log4j=&apos;http://jakarta.apache.org/log4j/&apos;&gt; &lt;appender name=&quot;console&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%n%p %d&#123;yyyy-MM-dd HH:mm:ss&#125; %c : %L %n%m%n%n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=&quot;org.quartz&quot; additivity=&quot;true&quot;&gt; &lt;level value=&quot;WARN&quot; /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=&quot;DEBUG&quot; /&gt; &lt;appender-ref ref=&quot;console&quot; /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 与 spring 整合整合示例清单1234567891011121314151617181920212223242526package org.fanlychie.cron;import org.quartz.JobKey;import org.quartz.JobDetail;import org.quartz.JobDataMap;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;import org.springframework.scheduling.quartz.QuartzJobBean;public class MyJob extends QuartzJobBean &#123; @Override protected void executeInternal(JobExecutionContext context) throws JobExecutionException &#123; JobDetail jobDetail = context.getJobDetail(); JobKey jobKey = jobDetail.getKey(); JobDataMap jobDataMap = jobDetail.getJobDataMap(); // 任务执行时, 打印一条消息 System.out.println(&quot;Executing &quot; + jobKey + &quot; : &quot; + jobDataMap.getString(&quot;msg&quot;)); &#125;&#125; pom.xml 12345678910111213141516171819202122232425262728293031323334&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; beans.xml 12345678910111213141516171819202122232425&lt;bean id=&quot;jobDetail&quot; class=&quot;org.springframework.scheduling.quartz.JobDetailFactoryBean&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;MY-JOB&quot; /&gt; &lt;property name=&quot;jobClass&quot; value=&quot;org.fanlychie.cron.MyJob&quot; /&gt; &lt;property name=&quot;jobDataAsMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;msg&quot;&gt; &lt;value&gt;Hello World！&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;durability&quot; value=&quot;true&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;cronTrigger&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt; &lt;property name=&quot;jobDetail&quot; ref=&quot;jobDetail&quot; /&gt; &lt;property name=&quot;cronExpression&quot; value=&quot;0/5 * * * * ?&quot; /&gt;&lt;/bean&gt;&lt;bean class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt; &lt;property name=&quot;triggers&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;cronTrigger&quot; /&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; log4j.xml 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;http://toolkit.alibaba-inc.com/dtd/log4j/log4j.dtd&quot;&gt;&lt;log4j:configuration xmlns:log4j=&apos;http://jakarta.apache.org/log4j/&apos;&gt; &lt;appender name=&quot;console&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%n%p %d&#123;yyyy-MM-dd HH:mm:ss&#125; %c : %L %n%m%n%n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=&quot;org.quartz&quot; additivity=&quot;true&quot;&gt; &lt;level value=&quot;WARN&quot; /&gt; &lt;/logger&gt; &lt;logger name=&quot;org.springframework&quot; additivity=&quot;true&quot;&gt; &lt;level value=&quot;WARN&quot; /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=&quot;DEBUG&quot; /&gt; &lt;appender-ref ref=&quot;console&quot; /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 测试清单 123456789public class CronTest &#123; public static void main(String[] args) throws Throwable &#123; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"图形验证码","date":"2015-10-31T07:49:37.000Z","path":"post/java-identifying-code.html","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class CaptchaServlet extends HttpServlet &#123; // 验证码宽度 private static int width = 80; // 验证码高度 private static int height = 28; // 验证码字符长度 private static int captchaCharLength = 4; // 验证码的字符集 private static char[] captchaChars = \"ABCEHKN23456789PRSTXYZ\".toCharArray(); // 验证码的字符集大小 private static int captchaCharsSize = captchaChars.length; // 验证码存储在 session 的键名 private static final String CAPTCHA_KEY = \"_CAPTCHA_SESSION_KEY_\"; private static final long serialVersionUID = 5438961220479548231L; @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; response.setHeader(\"Cache-Control\", \"no-store\"); response.setHeader(\"Pragma\", \"no-cache\"); response.setDateHeader(\"Expires\", 0); response.setContentType(\"image/jpeg\"); String captchaText = generateRandomCode(); BufferedImage image = generateImage(captchaText); HttpSession session = request.getSession(); session.setAttribute(CAPTCHA_KEY, captchaText); try (OutputStream out = response.getOutputStream()) &#123; ImageIO.write(image, \"jpg\", out); &#125; &#125; /** * 生成随机码字符串 */ private String generateRandomCode() &#123; Random random = ThreadLocalRandom.current(); StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; captchaCharLength; i++) &#123; builder.append(captchaChars[random.nextInt(captchaCharsSize)]); &#125; return builder.toString(); &#125; /** * 生成验证码图片 * * @param captchaText * 验证码字符串 * @return BufferedImage */ private BufferedImage generateImage(String captchaText) &#123; BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics2D graphics = (Graphics2D) image.getGraphics(); // 设置背景颜色 graphics.setColor(Color.WHITE); graphics.fillRect(0, 0, width, height); // 设置边框 graphics.setColor(Color.GRAY); graphics.drawRect(0, 0, width - 1, height - 1); // 设置字体 graphics.setColor(Color.BLACK); graphics.setFont(new Font(\"Calibri\", Font.BOLD, height - 6)); // 平滑不锯齿 graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); int length = captchaText.length(); char[] chars = captchaText.toCharArray(); // 绘制验证码字符 for (int i = 0; i &lt; length; i++) &#123; graphics.drawChars(chars, i, 1, ((width - 8) / length) * i + 7, height / 2 + length / 2 + 6); &#125; graphics.dispose(); return image; &#125;&#125; web.xml 12345678&lt;servlet&gt; &lt;servlet-name&gt;CaptchaServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.fanlychie.servlet.CaptchaServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;CaptchaServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/captcha&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; JSP 1&lt;img src=\"captcha\" onclick=\"this.src+=''\" style=\"cursor:pointer;\" title=\"看不清？换一个\"&gt; 干扰线 在 graphics.dispose(); 前调用 drawLine(graphics); 12345678910111213141516171819202122232425262728293031323334353637383940private void drawLine(Graphics2D graphics) &#123; Point2D[] point2ds = getPoints(.1f, .3f, .5f, .9f); graphics.setRenderingHints(new RenderingHints( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON)); graphics.setColor(Color.BLACK); graphics.setStroke(new BasicStroke(2)); for (int i = 0; i &lt; point2ds.length - 1; i++) &#123; graphics.drawLine( (int) point2ds[i].getX(), (int) point2ds[i].getY(), (int) point2ds[i + 1].getX(), (int) point2ds[i + 1].getY()); &#125;&#125;private Point2D[] getPoints(float f1, float f2, float f3, float f4) &#123; Random rand = ThreadLocalRandom.current(); CubicCurve2D curve2d = new CubicCurve2D.Float( width * f1, (height * (rand.nextInt(8) + 2)) * .1f, width * f2, (height * (rand.nextInt(8) + 2)) * .1f, width * f3, (height * (rand.nextInt(8) + 2)) * .1f, width * f4, (height * (rand.nextInt(8) + 2)) * .1f); PathIterator iterator = curve2d.getPathIterator(null, 3); Point2D point2ds[] = new Point2D[200]; int count = 0; float[] coords = new float[6]; while (!iterator.isDone()) &#123; switch (iterator.currentSegment(coords)) &#123; case PathIterator.SEG_MOVETO: case PathIterator.SEG_LINETO: point2ds[count] = new Point2D.Float(coords[0], coords[1]); &#125; count++; iterator.next(); &#125; Point2D[] points = new Point2D[count]; System.arraycopy(point2ds, 0, points, 0, count); return points;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"memcached 客户端","date":"2015-10-25T08:07:48.000Z","path":"post/memcached-client.html","text":"常用客户端一：memcached java client12345&lt;dependency&gt; &lt;groupId&gt;com.whalin&lt;/groupId&gt; &lt;artifactId&gt;Memcached-Java-Client&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt;&lt;/dependency&gt; 客户端代码 12345678910111213141516171819202122232425262728293031323334353637public class MemcachedJavaClientTest &#123; public static void main(String[] args) &#123; SockIOPool pool = SockIOPool.getInstance(&quot;memcachedPool&quot;); pool.setServers(new String[]&#123;&quot;192.168.1.102:11211&quot;, &quot;192.168.1.103:11211&quot;&#125;); pool.setInitConn(20); pool.setMinConn(10); pool.setMaxConn(50); pool.setMaintSleep(5000); pool.setNagle(false); pool.setAliveCheck(false); pool.setSocketTO(3000); pool.setSocketConnectTO(5000); pool.initialize(); MemCachedClient client = new MemCachedClient(&quot;memcachedPool&quot;); client.set(&quot;client_message&quot;, &quot;Memcached Java Client&quot;); Object obj = client.get(&quot;client_message&quot;); System.out.println(obj); &#125; &#125; 与 spring 集成 123456789101112131415161718192021222324252627282930313233343536373839&lt;context:property-placeholder location=&quot;classpath:memcached.properties&quot; /&gt;&lt;bean class=&quot;com.whalin.MemCached.SockIOPool&quot; factory-method=&quot;getInstance&quot; init-method=&quot;initialize&quot; destroy-method=&quot;shutDown&quot; lazy-init=&quot;false&quot;&gt; &lt;constructor-arg value=&quot;memcachedPool&quot; /&gt; &lt;property name=&quot;servers&quot;&gt; &lt;list&gt; &lt;value&gt;$&#123;memcached.servers&#125;&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;initConn&quot;&gt; &lt;value&gt;$&#123;memcached.initConn&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;minConn&quot;&gt; &lt;value&gt;$&#123;memcached.minConn&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;maxConn&quot;&gt; &lt;value&gt;$&#123;memcached.maxConn&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;maintSleep&quot;&gt; &lt;value&gt;$&#123;memcached.maintSleep&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;nagle&quot;&gt; &lt;value&gt;$&#123;memcached.nagle&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;aliveCheck&quot;&gt; &lt;value&gt;$&#123;memcached.aliveCheck&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;socketTO&quot;&gt; &lt;value&gt;$&#123;memcached.socketTO&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;socketConnectTO&quot;&gt; &lt;value&gt;$&#123;memcached.socketConnectTO&#125;&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean class=&quot;com.whalin.MemCached.MemCachedClient&quot;&gt; &lt;constructor-arg value=&quot;memcachedPool&quot; /&gt;&lt;/bean&gt; memcached.properties 配置项 123456789101112131415161718# 服务器地址memcached.servers = 192.168.1.102:11211,192.168.1.103:11211# 初始化连接的数目memcached.initConn = 20# 最小的连接数memcached.minConn = 10# 最大的连接数memcached.maxConn = 50# 自查线程周期休眠时间memcached.maintSleep = 5000# 关闭 Nagle 算法memcached.nagle = false# 不检查连接是否有效memcached.aliveCheck = false# Socket 阻塞读取数据的超时时间memcached.socketTO = 3000# Socket 阻塞读取数据的超时时间memcached.socketConnectTO = 5000 客户端测试 123456789101112131415161718@ContextConfiguration(&quot;/beans.xml&quot;)@RunWith(SpringJUnit4ClassRunner.class)public class MemcachedJavaClientTest extends AbstractJUnit4SpringContextTests &#123; @Test public void testSet() &#123; MemCachedClient client = applicationContext.getBean(MemCachedClient.class); client.set(&quot;client_message&quot;, &quot;Memcached Java Client&quot;); &#125; @Test public void testGet() &#123; MemCachedClient client = applicationContext.getBean(MemCachedClient.class); Object obj = client.get(&quot;client_message&quot;); System.out.println(obj); &#125; &#125; 常用客户端二：spymemcached12345&lt;dependency&gt; &lt;groupId&gt;net.spy&lt;/groupId&gt; &lt;artifactId&gt;spymemcached&lt;/artifactId&gt; &lt;version&gt;2.11.6&lt;/version&gt;&lt;/dependency&gt; 客户端代码 1234567891011121314151617181920212223242526272829303132333435public class SpyMemcachedJavaClientTest &#123; public static void main(String[] args) throws Throwable &#123; ConnectionFactoryBuilder builder = new ConnectionFactoryBuilder(); builder.setDaemon(true); builder.setFailureMode(FailureMode.Redistribute); builder.setHashAlg(DefaultHashAlgorithm.KETAMA_HASH); builder.setLocatorType(Locator.CONSISTENT); builder.setUseNagleAlgorithm(false); builder.setOpTimeout(3000); builder.setProtocol(Protocol.BINARY); builder.setTranscoder(new SerializingTranscoder()); String servers = &quot;192.168.1.102:11211,192.168.1.103:11211&quot;; MemcachedClient client = new MemcachedClient(builder.build(), AddrUtil.getAddresses(servers)); client.set(&quot;client_message&quot;, 0, &quot;spymemcached&quot;); Object obj = client.get(&quot;client_message&quot;); System.out.println(obj); &#125;&#125; 与 spring 集成 12345678910111213141516171819202122232425262728293031&lt;context:property-placeholder location=&quot;classpath:spymemcached.properties&quot; /&gt;&lt;bean class=&quot;net.spy.memcached.spring.MemcachedClientFactoryBean&quot;&gt; &lt;property name=&quot;servers&quot;&gt; &lt;value&gt;$&#123;memcached.servers&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;daemon&quot;&gt; &lt;value&gt;$&#123;memcached.daemon&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;failureMode&quot;&gt; &lt;value&gt;$&#123;memcached.failureMode&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;hashAlg&quot;&gt; &lt;value type=&quot;net.spy.memcached.DefaultHashAlgorithm&quot;&gt;$&#123;memcached.hashAlg&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;locatorType&quot;&gt; &lt;value&gt;$&#123;memcached.locatorType&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;useNagleAlgorithm&quot;&gt; &lt;value&gt;$&#123;memcached.useNagleAlgorithm&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;protocol&quot;&gt; &lt;value&gt;$&#123;memcached.protocol&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;opTimeout&quot;&gt; &lt;value&gt;$&#123;memcached.opTimeout&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;transcoder&quot;&gt; &lt;bean class=&quot;net.spy.memcached.transcoders.SerializingTranscoder&quot; /&gt; &lt;/property&gt;&lt;/bean&gt; spymemcached.properties 配置项 12345678910111213141516# 服务器地址memcached.servers = 192.168.1.102:11211,192.168.1.103:11211# 设置 IO 线程的守护进程memcached.daemon = true# 发生故障重新分配连接memcached.failureMode = Redistribute# 一致性哈希算法memcached.hashAlg = KETAMA_HASH# 定位器类型memcached.locatorType = CONSISTENT# 关闭 Nagle 算法memcached.useNagleAlgorithm = false# 使用二进制协议memcached.protocol = BINARY# 操作超时时间memcached.opTimeout = 3000 客户端测试 123456789101112131415161718@ContextConfiguration(&quot;/beans.xml&quot;)@RunWith(SpringJUnit4ClassRunner.class)public class SpyMemcachedJavaClientTest extends AbstractJUnit4SpringContextTests &#123; @Test public void testSet() &#123; MemcachedClient client = applicationContext.getBean(MemcachedClient.class); client.set(&quot;client_message&quot;, 0, &quot;spymemcached&quot;); &#125; @Test public void testGet() &#123; MemcachedClient client = applicationContext.getBean(MemcachedClient.class); Object obj = client.get(&quot;client_message&quot;); System.out.println(obj); &#125; &#125; 常用客户端三：xmemcached12345&lt;dependency&gt; &lt;groupId&gt;com.googlecode.xmemcached&lt;/groupId&gt; &lt;artifactId&gt;xmemcached&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt; 客户端代码 123456789101112131415161718192021222324252627282930313233public class XMemcachedJavaClientTest &#123; public static void main(String[] args) throws Throwable &#123; List&lt;InetSocketAddress&gt; list = AddrUtil.getAddresses(&quot;192.168.1.102:11211 192.168.1.103:11211&quot;); XMemcachedClientBuilder builder = new XMemcachedClientBuilder(list, new int[] &#123; 1, 1 &#125;); builder.setConnectionPoolSize(1); builder.setFailureMode(true); builder.setOpTimeout(3000); builder.setConnectTimeout(5000); builder.setCommandFactory(new TextCommandFactory()); builder.setSessionLocator(new KetamaMemcachedSessionLocator()); builder.setTranscoder(new SerializingTranscoder()); MemcachedClient client = builder.build(); client.set(&quot;client_message&quot;, 0, &quot;xmemcached&quot;); Object obj = client.get(&quot;client_message&quot;); System.out.println(obj); &#125;&#125; 与 spring 集成 12345678910111213141516171819202122232425262728293031323334&lt;context:property-placeholder location=&quot;classpath:xmemcached.properties&quot; /&gt;&lt;bean class=&quot;net.rubyeye.xmemcached.utils.XMemcachedClientFactoryBean&quot;&gt; &lt;property name=&quot;servers&quot;&gt; &lt;value&gt;$&#123;memcached.servers&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;weights&quot;&gt; &lt;list&gt; &lt;value&gt;$&#123;memcached.server1&#125;&lt;/value&gt; &lt;value&gt;$&#123;memcached.server2&#125;&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;failureMode&quot;&gt; &lt;value&gt;$&#123;memcached.failureMode&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;opTimeout&quot;&gt; &lt;value&gt;$&#123;memcached.opTimeout&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;connectTimeout&quot;&gt; &lt;value&gt;$&#123;memcached.connectTimeout&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;connectionPoolSize&quot;&gt; &lt;value&gt;$&#123;memcached.connectionPoolSize&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;commandFactory&quot;&gt; &lt;bean class=&quot;net.rubyeye.xmemcached.command.TextCommandFactory&quot; /&gt; &lt;/property&gt; &lt;property name=&quot;sessionLocator&quot;&gt; &lt;bean class=&quot;net.rubyeye.xmemcached.impl.KetamaMemcachedSessionLocator&quot; /&gt; &lt;/property&gt; &lt;property name=&quot;transcoder&quot;&gt; &lt;bean class=&quot;net.rubyeye.xmemcached.transcoders.SerializingTranscoder&quot; /&gt; &lt;/property&gt;&lt;/bean&gt; xmemcached.properties 配置项 1234567891011121314# 服务器地址memcached.servers = 192.168.1.102:11211 192.168.1.103:11211# 权重设置memcached.server1 = 1# 权重设置memcached.server2 = 1# 连接池大小memcached.connectionPoolSize = 1# 宕机警报memcached.failureMode = true# 连接超时memcached.connectTimeout = 5000# 等待超时memcached.opTimeout = 3000 客户端测试 123456789101112131415161718@ContextConfiguration(&quot;/beans.xml&quot;)@RunWith(SpringJUnit4ClassRunner.class)public class XMemcachedJavaClientTest extends AbstractJUnit4SpringContextTests &#123; @Test public void testSet() throws Throwable &#123; MemcachedClient client = applicationContext.getBean(MemcachedClient.class); client.set(&quot;client_message&quot;, 0, &quot;xmemcached&quot;); &#125; @Test public void testGet() throws Throwable &#123; MemcachedClient client = applicationContext.getBean(MemcachedClient.class); Object obj = client.get(&quot;client_message&quot;); System.out.println(obj); &#125; &#125;","tags":[{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/缓存/"},{"name":"Memcached","slug":"Memcached","permalink":"http://yoursite.com/tags/Memcached/"}]},{"title":"memcached 命令","date":"2015-10-25T03:15:23.000Z","path":"post/memcached- command.html","text":"连接服务器使用 telnet 客户端工具可以连接到 memcached 服务器。 1telnet 192.168.1.102 11211 第一次进来需要摸黑输入，可以敲个回车，同时忽略 ERROR 消息。 set 语法123set key flags exptime bytesvalue 参数 描述 key 键的名称 flags 32位无符号整数，用于存储键值对的额外信息 exptime 缓存过期时间（单位秒），0 表示永不过期 bytes 缓存的 value 值的字节数，不是键的字节数 value 缓存的 value 值，在新的一行赋予 作用：若 key 不存在，则存储该键值对；若 key 已经存在，则更新该 key 的 value 值。 示例： 12345set name 0 0 9fanlychieSTORED STORED 表示成功，ERROR 表示错误。 get 语法1get key 作用：获取 key 映射的 value 值。 示例： 1234567get nameVALUE name 0 9fanlychieEND “VALUE name 0 9” 0 是 flags 的值，9 是 value 的字节数。 add 语法123add key flags exptime bytesvalue 参数含义参考 set 语法参数。 作用：添加一个新的键，如果该键已经存在，则返回 NOT_STORED。 示例： 12345add sex 0 0 4maleSTORED append 语法123append key flags exptime bytesvalue 参数含义参考 set 语法参数。 作用：追加新的值到一个现有的键映射的值中，如果键不存在，则返回 NOT_STORED。 示例： 1234567get sexVALUE sex 0 4maleEND 12345append sex 0 0 3abcSTORED 1234567get sexVALUE sex 0 4maleabcEND replace 语法123replace key flags exptime bytesvalue 参数含义参考 set 语法参数。 作用：替换一个现有的键映射的值，如果键不存在，则返回 NOT_STORED。 示例： 1234567get sexVALUE sex 0 4maleabcEND 12345replace sex 0 0 4maleSTORED 1234567get sexVALUE sex 0 4maleEND delete 语法1delete key 作用：删除缓存。若 key 不存在，则返回 NOT_FOUND；成功则返回 DELETE。 示例： 123delete sexDELETE incr 语法1incr key increment_value 作用：使键映射的值增长。 示例： 12345set age 0 0 221STORED 123incr age 122 decr 语法1decr key increment_value 作用：使键映射的值减小。 示例： 12345set age 0 0 221STORED 123decr age 120 stats 语法1stats 作用：统计服务器信息。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107statsSTAT pid 32586STAT uptime 1887STAT time 1445786677STAT version 1.4.24STAT libevent 2.0.22-stableSTAT pointer_size 64STAT rusage_user 0.085986STAT rusage_system 0.249962STAT curr_connections 10STAT total_connections 11STAT connection_structures 11STAT reserved_fds 20STAT cmd_get 12STAT cmd_set 20STAT cmd_flush 0STAT cmd_touch 0STAT get_hits 7STAT get_misses 5STAT delete_misses 0STAT delete_hits 1STAT incr_misses 0STAT incr_hits 1STAT decr_misses 0STAT decr_hits 1STAT cas_misses 0STAT cas_hits 0STAT cas_badval 0STAT touch_hits 0STAT touch_misses 0STAT auth_cmds 0STAT auth_errors 0STAT bytes_read 986STAT bytes_written 4495STAT limit_maxbytes 134217728STAT accepting_conns 1STAT listen_disabled_num 0STAT threads 4STAT conn_yields 0STAT hash_power_level 16STAT hash_bytes 524288STAT hash_is_expanding 0STAT malloc_fails 0STAT bytes 220STAT curr_items 3STAT total_items 6STAT expired_unfetched 0STAT evicted_unfetched 0STAT evictions 0STAT reclaimed 0STAT crawler_reclaimed 0STAT crawler_items_checked 0STAT lrutail_reflocked 0END 消息 描述 pid Memcache 进程 ID uptime 服务器已运行秒数 time 服务器当前 Unix 时间戳 version Memcache 版本 pointer_size 操作系统指针大小 curr_connections 当前连接数量 total_connections Memcached 运行以来连接总数 connection_structures Memcached 分配的连接结构数量 cmd_get get 命令请求次数 cmd_set set 命令请求次数 cmd_flush flush 命令请求次数 get_hits get 命令命中次数 get_misses get 命令未命中次数 delete_misses delete 命令未命中次数 delete_hits delete 命令命中次数 incr_misses incr 命令未命中次数 incr_hits incr 命令命中次数 decr_misses decr 命令未命中次数 decr_hits decr 命令命中次数 cas_misses cas 命令未命中次数 cas_hits cas 命令命中次数 cas_badval 使用擦拭次数 auth_cmds 认证命令处理的次数 auth_errors 认证失败数目 bytes_read 读取总字节数 bytes_written 发送总字节数 limit_maxbytes 分配的内存总大小（字节） accepting_conns 接受新的连接 listen_disabled_num 失效的监听数 threads 当前线程数 conn_yields 连接操作主动放弃数目 bytes 当前存储占用的字节数 curr_items 当前存储的数据总数 total_items 启动以来存储的数据总数 evictions LRU 释放的对象数目 unix 时间戳转换（java） 1234567891011public static void main(String[] args) &#123; Date date = new Date(1445786677L * 1000); DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); String dateStr = format.format(date); System.out.println(dateStr); &#125; stats items 语法1stats items 作用：统计分配的项信息。 示例： 1234567891011121314151617181920212223242526272829stats itemsSTAT items:1:number 3STAT items:1:age 1794STAT items:1:evicted 0STAT items:1:evicted_nonzero 0STAT items:1:evicted_time 0STAT items:1:outofmemory 0STAT items:1:tailrepairs 0STAT items:1:reclaimed 0STAT items:1:expired_unfetched 0STAT items:1:evicted_unfetched 0STAT items:1:crawler_reclaimed 0STAT items:1:crawler_items_checked 0STAT items:1:lrutail_reflocked 0END “STAT items:1:number 3”，1 是 slab_id，3 表示总共有 3 条缓存数据。 stats cachedump 语法1stats cachedump slab_id limit_num 参数 描述 slab_id slab 编号 limit_num 返回的记录条数，0 表示不限制，即所有 作用：返回指定编号的 slab 中键的信息列表。 示例： 123456789stats cachedump 1 0ITEM sex [4 b; 1445784730 s]ITEM age [2 b; 1445784730 s]ITEM name [9 b; 1445784730 s]END “ITEM sex [4 b; 1445784730 s]”，sex 为键的名称，4 为键映射的 value 值的字节数，1445784730 为过期时间。 flush_all 语法1flush_all 作用：清除所有缓存数据。 示例： 123flush_allOK","tags":[{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/缓存/"},{"name":"Memcached","slug":"Memcached","permalink":"http://yoursite.com/tags/Memcached/"}]},{"title":"memcached 安装","date":"2015-10-18T15:36:47.000Z","path":"post/memcached-setup.html","text":"Memcached 是一个高性能的分布式内存对象缓存系统，用于动态 Web 应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。Memcached 是基于一个存储 key / value 的 hashmap。 安装环境 CentOS 6.5 libevent-2.0.22-stable.tar.gz memcached-1.4.24.tar.gz 安装 libeventmemcached 依赖 libevent 库，检查 libevent 是否已安装 1# rpm -qa | grep libevent 到 libevent 官网下载所需版本的安装文件 123456789# tar zxvf libevent-2.0.22-stable.tar.gz# cd libevent-2.0.22-stable# ./configure --prefix=/usr/local/libevent# make# make install 安装 memcached到 memcached 官网下载所需版本的安装文件 123456789# tar zxvf memcached-1.4.24.tar.gz# cd memcached-1.4.24# ./configure --prefix=/usr/local/memcached --with-libevent=/usr/local/libevent/# make# make install 启动 memcached1# /usr/local/memcached/bin/memcached -d -m 128 -u root -p 11211 -c 1024 –P /tmp/memcached.pid 启动参数 描述 -d 启动一个守护进程 -m 分配给 memcached 的内存大小，单位 MB -u 启动 memcached 的用户 -c 最大运行的并发连接数 -p 设置 memcached 监听的端口 -P 设置保存 memcached 的 pid 文件 查看 memcached1# ps -ef | grep memcached 关闭 memcached12345# ps -ef | grep memcachedroot 9291 1 0 09:09 ? 00:00:00 /usr/local/memcached/bin/memcached -d -m 128 -u root -p 11211 -c 1024 –P /tmp/memcached.pid# kill -9 9291 防火墙开启 11211 端口1# vi /etc/sysconfig/iptables 加入如下一行配置 1-A INPUT -m state --state NEW -m tcp -p tcp --dport 11211 -j ACCEPT 重启防火墙服务 1# service iptables restart","tags":[{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/缓存/"},{"name":"Memcached","slug":"Memcached","permalink":"http://yoursite.com/tags/Memcached/"}]}]